{"version":3,"names":[],"mappings":"","sources":["GeoJSON.js"],"sourcesContent":["/**\n * @module ol/format/GeoJSON\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Feature from '../../node_modules/ol/Feature.js';\nimport GeometryCollection from '../../node_modules/ol/geom/GeometryCollection.js';\nimport GeometryType from '../../node_modules/ol/geom/GeometryType.js';\nimport JSONFeature from '../../node_modules/ol/format/JSONFeature.js';\nimport LineString from '../../node_modules/ol/geom/LineString.js';\nimport MultiLineString from '../../node_modules/ol/geom/MultiLineString.js';\nimport MultiPoint from '../../node_modules/ol/geom/MultiPoint.js';\nimport MultiPolygon from '../../node_modules/ol/geom/MultiPolygon.js';\nimport Point from '../../node_modules/ol/geom/Point.js';\nimport Polygon from '../../node_modules/ol/geom/Polygon.js';\nimport { assert } from '../../node_modules/ol/asserts.js';\nimport { assign, isEmpty } from '../../node_modules/ol/obj.js';\nimport { get as getProjection } from '../../node_modules/ol/proj.js';\nimport { transformGeometryWithOptions } from '../../node_modules/ol/format/Feature.js';\n/**\n * @typedef {import(\"geojson\").GeoJSON} GeoJSONObject\n * @typedef {import(\"geojson\").Feature} GeoJSONFeature\n * @typedef {import(\"geojson\").FeatureCollection} GeoJSONFeatureCollection\n * @typedef {import(\"geojson\").Geometry} GeoJSONGeometry\n * @typedef {import(\"geojson\").Point} GeoJSONPoint\n * @typedef {import(\"geojson\").LineString} GeoJSONLineString\n * @typedef {import(\"geojson\").Polygon} GeoJSONPolygon\n * @typedef {import(\"geojson\").MultiPoint} GeoJSONMultiPoint\n * @typedef {import(\"geojson\").MultiLineString} GeoJSONMultiLineString\n * @typedef {import(\"geojson\").MultiPolygon} GeoJSONMultiPolygon\n * @typedef {import(\"geojson\").GeometryCollection} GeoJSONGeometryCollection\n */\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection for features read or\n * written by the format.  Options passed to read or write methods will take precedence.\n * @property {string} [geometryName] Geometry name to use when creating features.\n * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include\n * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader\n * will look for that field to set the geometry name. If both this field is set to `true`\n * and a `geometryName` is provided, the `geometryName` will take precedence.\n */\n/**\n * @classdesc\n * Feature format for reading and writing data in the GeoJSON format.\n *\n * @api\n */\nvar GeoJSON = /** @class */ (function (_super) {\n    __extends(GeoJSON, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function GeoJSON(opt_options) {\n        var _this = this;\n        var options = opt_options ? opt_options : {};\n        _this = _super.call(this) || this;\n        /**\n         * @type {import(\"../proj/Projection.js\").default}\n         */\n        _this.dataProjection = getProjection(options.dataProjection ? options.dataProjection : 'EPSG:4326');\n        if (options.featureProjection) {\n            _this.defaultFeatureProjection = getProjection(options.featureProjection);\n        }\n        /**\n         * Name of the geometry attribute for features.\n         * @type {string|undefined}\n         * @private\n         */\n        _this.geometryName_ = options.geometryName;\n        /**\n         * Look for the geometry name in the feature GeoJSON\n         * @type {boolean|undefined}\n         * @private\n         */\n        _this.extractGeometryName_ = options.extractGeometryName;\n        _this.supportedMediaTypes = [\n            'application/geo+json',\n            'application/vnd.geo+json',\n        ];\n        return _this;\n    }\n    /**\n     * @param {Object} object Object.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @protected\n     * @return {import(\"../Feature.js\").default} Feature.\n     */\n    GeoJSON.prototype.readFeatureFromObject = function (object, opt_options) {\n        /**\n         * @type {GeoJSONFeature}\n         */\n        var geoJSONFeature = null;\n        if (object['type'] === 'Feature') {\n            geoJSONFeature = /** @type {GeoJSONFeature} */ (object);\n        }\n        else {\n            geoJSONFeature = {\n                'type': 'Feature',\n                'geometry': /** @type {GeoJSONGeometry} */ (object),\n                'properties': null,\n            };\n        }\n        //var geometry = readGeometry(geoJSONFeature['geometry'], opt_options);\n        const geometry = (geoJSONFeature['geometry'] && geoJSONFeature['geometry'][\"coordinates\"] && geoJSONFeature['geometry'][\"coordinates\"].length) ? readGeometry(geoJSONFeature['geometry'], opt_options) : null;\n        var feature = new Feature();\n        if (this.geometryName_) {\n            feature.setGeometryName(this.geometryName_);\n        }\n        else if (this.extractGeometryName_ &&\n            'geometry_name' in geoJSONFeature !== undefined) {\n            feature.setGeometryName(geoJSONFeature['geometry_name']);\n        }\n        feature.setGeometry(geometry);\n        if ('id' in geoJSONFeature) {\n            feature.setId(geoJSONFeature['id']);\n        }\n        if (geoJSONFeature['properties']) {\n            feature.setProperties(geoJSONFeature['properties'], true);\n        }\n        return feature;\n    };\n    /**\n     * @param {Object} object Object.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @protected\n     * @return {Array<Feature>} Features.\n     */\n    GeoJSON.prototype.readFeaturesFromObject = function (object, opt_options) {\n        var geoJSONObject = /** @type {GeoJSONObject} */ (object);\n        /** @type {Array<import(\"../Feature.js\").default>} */\n        var features = null;\n        if (geoJSONObject['type'] === 'FeatureCollection') {\n            var geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ (object);\n            features = [];\n            var geoJSONFeatures = geoJSONFeatureCollection['features'];\n            for (var i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {\n                features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));\n            }\n        }\n        else {\n            features = [this.readFeatureFromObject(object, opt_options)];\n        }\n        return features;\n    };\n    /**\n     * @param {GeoJSONGeometry} object Object.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @protected\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     */\n    GeoJSON.prototype.readGeometryFromObject = function (object, opt_options) {\n        return readGeometry(object, opt_options);\n    };\n    /**\n     * @param {Object} object Object.\n     * @protected\n     * @return {import(\"../proj/Projection.js\").default} Projection.\n     */\n    GeoJSON.prototype.readProjectionFromObject = function (object) {\n        var crs = object['crs'];\n        var projection;\n        if (crs) {\n            if (crs['type'] == 'name') {\n                projection = getProjection(crs['properties']['name']);\n            }\n            else if (crs['type'] === 'EPSG') {\n                projection = getProjection('EPSG:' + crs['properties']['code']);\n            }\n            else {\n                assert(false, 36); // Unknown SRS type\n            }\n        }\n        else {\n            projection = this.dataProjection;\n        }\n        return /** @type {import(\"../proj/Projection.js\").default} */ (projection);\n    };\n    /**\n     * Encode a feature as a GeoJSON Feature object.\n     *\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {GeoJSONFeature} Object.\n     * @api\n     */\n    GeoJSON.prototype.writeFeatureObject = function (feature, opt_options) {\n        opt_options = this.adaptOptions(opt_options);\n        /** @type {GeoJSONFeature} */\n        var object = {\n            'type': 'Feature',\n            geometry: null,\n            properties: null,\n        };\n        var id = feature.getId();\n        if (id !== undefined) {\n            object.id = id;\n        }\n        if (!feature.hasProperties()) {\n            return object;\n        }\n        var properties = feature.getProperties();\n        var geometry = feature.getGeometry();\n        if (geometry) {\n            object.geometry = writeGeometry(geometry, opt_options);\n            delete properties[feature.getGeometryName()];\n        }\n        if (!isEmpty(properties)) {\n            object.properties = properties;\n        }\n        return object;\n    };\n    /**\n     * Encode an array of features as a GeoJSON object.\n     *\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {GeoJSONFeatureCollection} GeoJSON Object.\n     * @api\n     */\n    GeoJSON.prototype.writeFeaturesObject = function (features, opt_options) {\n        opt_options = this.adaptOptions(opt_options);\n        var objects = [];\n        for (var i = 0, ii = features.length; i < ii; ++i) {\n            objects.push(this.writeFeatureObject(features[i], opt_options));\n        }\n        return {\n            type: 'FeatureCollection',\n            features: objects,\n        };\n    };\n    /**\n     * Encode a geometry as a GeoJSON object.\n     *\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.\n     * @api\n     */\n    GeoJSON.prototype.writeGeometryObject = function (geometry, opt_options) {\n        return writeGeometry(geometry, this.adaptOptions(opt_options));\n    };\n    return GeoJSON;\n}(JSONFeature));\n/**\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readGeometry(object, opt_options) {\n    if (!object) {\n        return null;\n    }\n    /**\n     * @type {import(\"../geom/Geometry.js\").default}\n     */\n    var geometry;\n    switch (object['type']) {\n        case GeometryType.POINT: {\n            geometry = readPointGeometry(/** @type {GeoJSONPoint} */ (object));\n            break;\n        }\n        case GeometryType.LINE_STRING: {\n            geometry = readLineStringGeometry(\n            /** @type {GeoJSONLineString} */ (object));\n            break;\n        }\n        case GeometryType.POLYGON: {\n            geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */ (object));\n            break;\n        }\n        case GeometryType.MULTI_POINT: {\n            geometry = readMultiPointGeometry(\n            /** @type {GeoJSONMultiPoint} */ (object));\n            break;\n        }\n        case GeometryType.MULTI_LINE_STRING: {\n            geometry = readMultiLineStringGeometry(\n            /** @type {GeoJSONMultiLineString} */ (object));\n            break;\n        }\n        case GeometryType.MULTI_POLYGON: {\n            geometry = readMultiPolygonGeometry(\n            /** @type {GeoJSONMultiPolygon} */ (object));\n            break;\n        }\n        case GeometryType.GEOMETRY_COLLECTION: {\n            geometry = readGeometryCollectionGeometry(\n            /** @type {GeoJSONGeometryCollection} */ (object));\n            break;\n        }\n        default: {\n            throw new Error('Unsupported GeoJSON type: ' + object.type);\n        }\n    }\n    return transformGeometryWithOptions(geometry, false, opt_options);\n}\n/**\n * @param {GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n * @return {GeometryCollection} Geometry collection.\n */\nfunction readGeometryCollectionGeometry(object, opt_options) {\n    var geometries = object['geometries'].map(\n    /**\n     * @param {GeoJSONGeometry} geometry Geometry.\n     * @return {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     */\n    function (geometry) {\n        return readGeometry(geometry, opt_options);\n    });\n    return new GeometryCollection(geometries);\n}\n/**\n * @param {GeoJSONPoint} object Object.\n * @return {Point} Point.\n */\nfunction readPointGeometry(object) {\n    return new Point(object['coordinates']);\n}\n/**\n * @param {GeoJSONLineString} object Object.\n * @return {LineString} LineString.\n */\nfunction readLineStringGeometry(object) {\n    return new LineString(object['coordinates']);\n}\n/**\n * @param {GeoJSONMultiLineString} object Object.\n * @return {MultiLineString} MultiLineString.\n */\nfunction readMultiLineStringGeometry(object) {\n    return new MultiLineString(object['coordinates']);\n}\n/**\n * @param {GeoJSONMultiPoint} object Object.\n * @return {MultiPoint} MultiPoint.\n */\nfunction readMultiPointGeometry(object) {\n    return new MultiPoint(object['coordinates']);\n}\n/**\n * @param {GeoJSONMultiPolygon} object Object.\n * @return {MultiPolygon} MultiPolygon.\n */\nfunction readMultiPolygonGeometry(object) {\n    return new MultiPolygon(object['coordinates']);\n}\n/**\n * @param {GeoJSONPolygon} object Object.\n * @return {Polygon} Polygon.\n */\nfunction readPolygonGeometry(object) {\n    return new Polygon(object['coordinates']);\n}\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeGeometry(geometry, opt_options) {\n    geometry = transformGeometryWithOptions(geometry, true, opt_options);\n    var type = geometry.getType();\n    /** @type {GeoJSONGeometry} */\n    var geoJSON;\n    switch (type) {\n        case GeometryType.POINT: {\n            geoJSON = writePointGeometry(\n            /** @type {Point} */ (geometry), opt_options);\n            break;\n        }\n        case GeometryType.LINE_STRING: {\n            geoJSON = writeLineStringGeometry(\n            /** @type {LineString} */ (geometry), opt_options);\n            break;\n        }\n        case GeometryType.POLYGON: {\n            geoJSON = writePolygonGeometry(\n            /** @type {Polygon} */ (geometry), opt_options);\n            break;\n        }\n        case GeometryType.MULTI_POINT: {\n            geoJSON = writeMultiPointGeometry(\n            /** @type {MultiPoint} */ (geometry), opt_options);\n            break;\n        }\n        case GeometryType.MULTI_LINE_STRING: {\n            geoJSON = writeMultiLineStringGeometry(\n            /** @type {MultiLineString} */ (geometry), opt_options);\n            break;\n        }\n        case GeometryType.MULTI_POLYGON: {\n            geoJSON = writeMultiPolygonGeometry(\n            /** @type {MultiPolygon} */ (geometry), opt_options);\n            break;\n        }\n        case GeometryType.GEOMETRY_COLLECTION: {\n            geoJSON = writeGeometryCollectionGeometry(\n            /** @type {GeometryCollection} */ (geometry), opt_options);\n            break;\n        }\n        case GeometryType.CIRCLE: {\n            geoJSON = {\n                type: 'GeometryCollection',\n                geometries: [],\n            };\n            break;\n        }\n        default: {\n            throw new Error('Unsupported geometry type: ' + type);\n        }\n    }\n    return geoJSON;\n}\n/**\n * @param {GeometryCollection} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.\n */\nfunction writeGeometryCollectionGeometry(geometry, opt_options) {\n    var geometries = geometry.getGeometriesArray().map(function (geometry) {\n        var options = assign({}, opt_options);\n        delete options.featureProjection;\n        return writeGeometry(geometry, options);\n    });\n    return {\n        type: 'GeometryCollection',\n        geometries: geometries,\n    };\n}\n/**\n * @param {LineString} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeLineStringGeometry(geometry, opt_options) {\n    return {\n        type: 'LineString',\n        coordinates: geometry.getCoordinates(),\n    };\n}\n/**\n * @param {MultiLineString} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiLineStringGeometry(geometry, opt_options) {\n    return {\n        type: 'MultiLineString',\n        coordinates: geometry.getCoordinates(),\n    };\n}\n/**\n * @param {MultiPoint} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPointGeometry(geometry, opt_options) {\n    return {\n        type: 'MultiPoint',\n        coordinates: geometry.getCoordinates(),\n    };\n}\n/**\n * @param {MultiPolygon} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPolygonGeometry(geometry, opt_options) {\n    var right;\n    if (opt_options) {\n        right = opt_options.rightHanded;\n    }\n    return {\n        type: 'MultiPolygon',\n        coordinates: geometry.getCoordinates(right),\n    };\n}\n/**\n * @param {Point} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePointGeometry(geometry, opt_options) {\n    return {\n        type: 'Point',\n        coordinates: geometry.getCoordinates(),\n    };\n}\n/**\n * @param {Polygon} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePolygonGeometry(geometry, opt_options) {\n    var right;\n    if (opt_options) {\n        right = opt_options.rightHanded;\n    }\n    return {\n        type: 'Polygon',\n        coordinates: geometry.getCoordinates(right),\n    };\n}\nexport default GeoJSON;\n"],"file":"GeoJSON.js"}