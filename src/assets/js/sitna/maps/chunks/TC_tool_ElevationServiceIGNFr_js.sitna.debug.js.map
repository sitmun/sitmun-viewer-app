{"version":3,"file":"chunks/TC_tool_ElevationServiceIGNFr_js.sitna.debug.js","mappings":";;;;;;;;;;;;;;;AAA0B;AACA;AAC1B;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA,kEAAkE,mBAAmB;AACrF,eAAe,QAAQ;AACvB,8EAA8E,mBAAmB;AACjG;AACA;AACA,eAAe,QAAQ,yGAAyG,mBAAmB;AACnJ,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAe;AAC3B;AACA;AACA,YAAY,wDAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8JAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gDAAO;AAC1C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,gBAAgB;;;;;;;;;;;;;;;;AC7FmB;AACvB;AAC3B;AACA,oCAAoC,yDAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAc;AAC3C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,0CAA0C,+CAA+C;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,6BAA6B,uDAAc;AAC3C;AACA,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;AACA;AACA,iEAAe,qBAAqB","sources":["webpack://SITNA/./TC/tool/ElevationService.js","webpack://SITNA/./TC/tool/ElevationServiceIGNFr.js"],"sourcesContent":["import TC from '../../TC';\r\nimport Util from '../Util'\r\n/**\r\n  * Opciones de servicio de obtención de elevaciones de puntos.\r\n  * @typedef ElevationServiceOptions\r\n  * @memberof SITNA\r\n  * @see SITNA.ElevationOptions\r\n  * @property {string[]} [allowedGeometryTypes] - Si se establece, indica para qué geometrías se van a hacer consultas \r\n  * de elevación al servicio. Esto es conveniente por ejemplo si el servicio solo permite obtener elevaciones de un punto simple,\r\n  * invalidándolo para la consulta si la geometría es un polígono o una línea. Los elementos del array tienen que ser cadenas \r\n  * cuyos valores deben ser los definidos por [SITNA.Consts.geom]{@link SITNA.Consts}.\r\n  * @property {string} [googleMapsKey] - Valor de una clave válida de la API de Google Maps. Solamente es necesaria cuando \r\n  * el valor de la propiedad `name` es [SITNA.Consts.elevationService.GOOGLE]{@link SITNA.Consts}.\r\n  *\r\n  * Puede obtener más información en el [sitio para desarrolladores de Google](https://developers.google.com/maps/documentation/javascript/get-api-key).\r\n  * @property {string} name - Nombre del servicio que queremos utilizar. Debe tener un valor de [SITNA.Consts.elevationService]{@link SITNA.Consts}.\r\n  * @property {string} [url] - URL del servicio. Cada servicio de elevaciones de puntos tiene asignada una URL por defecto, \r\n  * así que rara vez será necesario establecer esta propiedad.\r\n  */\r\n\r\nclass ElevationService { \r\n    constructor(options) {\r\n        const self = this;\r\n        self.options = options || {};\r\n        self.url = self.options.url;\r\n        self.process = self.options.process;\r\n        self.minimumElevation = self.options.minimumElevation;\r\n        if (Util.isFunction(self.options.request)) {\r\n            self.request = self.options.request;\r\n        }\r\n        if (Util.isFunction(self.options.parseResponse)) {\r\n            self.parseResponse = self.options.parseResponse;\r\n        }\r\n    }\r\n\r\n    async getElevation(options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (options.resolution === undefined) {\r\n            options.resolution = self.options.resolution;\r\n        }\r\n        if (options.sampleNumber === undefined) {\r\n            options.sampleNumber = self.options.sampleNumber;\r\n        }\r\n        const response = await self.request(options);\r\n        return (options.responseCallback || self.parseResponse).call(self, response, options);\r\n    }\r\n\r\n    async request(options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (options.dataInputs || options.body) {\r\n            const WPS = await import('../format/WPS');\r\n            const data = {\r\n                process: options.process || self.process,\r\n                dataInputs: options.dataInputs,\r\n                responseType: SITNA.Consts.mimeType.JSON,\r\n                version: options.serviceVersion || self.serviceVersion || '1.0.0',\r\n                output: options.output\r\n            };\r\n            const contentType = typeof options.contentType === 'boolean' ? options.contentType : options.contentType || SITNA.Consts.mimeType.XML;\r\n            const response = await TC.ajax({\r\n                url: self.url,\r\n                method: 'POST',\r\n                contentType: contentType,\r\n                responseType: SITNA.Consts.mimeType.JSON,\r\n                data: options.body || WPS.buildExecuteQuery(data)\r\n            });\r\n            return response.data;\r\n        }\r\n        else {\r\n            throw Error('Request is not valid for elevation service');\r\n        }\r\n    }\r\n\r\n    parseResponse(response, _options) {\r\n        var self = this;\r\n        if (response.coordinates) {\r\n            const coords = response.coordinates;\r\n            coords.forEach(function (coord) {\r\n                if (coord[2] < self.minimumElevation) {\r\n                    coord[2] = null;\r\n                }\r\n            });\r\n        }\r\n        return response.coordinates || [];\r\n    }\r\n\r\n    cancelRequest(_id) {\r\n\r\n    }\r\n}\r\n\r\nexport default ElevationService;","import ElevationService from './ElevationService';\r\nimport Util from '../Util';\r\n\r\nclass ElevationServiceIGNFr extends ElevationService {\r\n    constructor() {\r\n        super(...arguments);\r\n        const self = this;\r\n        self.url = self.options.url || '//wxs.ign.fr/essentiels/alti/wps';\r\n        self.process = self.options.process || 'gs:WPSElevation';\r\n        self.profileProcess = self.options.profileProcess || 'gs:WPSLineElevation';\r\n        self.minimumElevation = self.options.minimumElevation || -99998;\r\n        self.nativeCRS = 'EPSG:4326';\r\n    }\r\n\r\n    request(options) {\r\n        const self = this;\r\n        options = options || {};\r\n        let coordinateList = options.coordinates;\r\n        if (options.crs && options.crs !== self.nativeCRS) {\r\n            coordinateList = Util.reproject(coordinateList, options.crs, self.nativeCRS);\r\n        }\r\n        const dataInputs = {\r\n            lon: coordinateList.map(function (coord) {\r\n                return coord[0];\r\n            }).join('|'),\r\n            lat: coordinateList.map(function (coord) {\r\n                return coord[1];\r\n            }).join('|'),\r\n            crs: 'crs:84',\r\n            format: 'json'\r\n        };\r\n        return super.request.call(self, { dataInputs: dataInputs, process: self.process });\r\n    }\r\n\r\n    parseResponse(response, options) {\r\n        const self = this;\r\n        if (response.elevations) {\r\n            var elevations = response.elevations.map(function (elev) {\r\n                return [elev.lon, elev.lat, elev.z];\r\n            });\r\n            if (options.crs && options.crs !== self.nativeCRS) {\r\n                elevations = Util.reproject(elevations, self.nativeCRS, options.crs);\r\n            }\r\n            return super.parseResponse.call(self, { coordinates: elevations }, options);\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default ElevationServiceIGNFr;"],"names":[],"sourceRoot":""}