{"version":3,"file":"chunks/4759.sitna.js","mappings":"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","sources":["webpack://SITNA/./TC/tool/ lazy ^\\.\\/.*$ namespace object","webpack://SITNA/./TC/tool/Elevation.js"],"sourcesContent":["var map = {\n\t\"./Elevation\": [\n\t\t2331\n\t],\n\t\"./Elevation.js\": [\n\t\t2331\n\t],\n\t\"./ElevationService\": [\n\t\t2026,\n\t\t2026\n\t],\n\t\"./ElevationService.js\": [\n\t\t2026,\n\t\t2026\n\t],\n\t\"./ElevationServiceGoogle\": [\n\t\t4736,\n\t\t4736\n\t],\n\t\"./ElevationServiceGoogle.js\": [\n\t\t4736,\n\t\t4736\n\t],\n\t\"./ElevationServiceIDENA\": [\n\t\t7612,\n\t\t7612\n\t],\n\t\"./ElevationServiceIDENA.js\": [\n\t\t7612,\n\t\t7612\n\t],\n\t\"./ElevationServiceIGNEs\": [\n\t\t3688,\n\t\t3688\n\t],\n\t\"./ElevationServiceIGNEs.js\": [\n\t\t3688,\n\t\t3688\n\t],\n\t\"./ElevationServiceIGNFr\": [\n\t\t6468,\n\t\t6468\n\t],\n\t\"./ElevationServiceIGNFr.js\": [\n\t\t6468,\n\t\t6468\n\t],\n\t\"./ExcelExport\": [\n\t\t1446\n\t],\n\t\"./ExcelExport.js\": [\n\t\t1446\n\t],\n\t\"./Proxification\": [\n\t\t4676\n\t],\n\t\"./Proxification.js\": [\n\t\t4676\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn Promise.all(ids.slice(1).map(__webpack_require__.e)).then(() => {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = 800;\nmodule.exports = webpackAsyncContext;","import TC from '../../TC';\r\nimport Consts from '../Consts';\r\nimport Util from '../Util';\r\nimport Geometry from '../Geometry';\r\n\r\n/**\r\n * Colección de identificadores de servicios para obtener elevaciones de puntos.\r\n * @member elevationService\r\n * @memberof SITNA.Consts\r\n * @readonly\r\n * @property {string} GOOGLE - Identificador del servicio de elevación de la API de Google Maps.\r\n * @property {string} IDENA - Identificador del servicio de elevación de IDENA.\r\n * @property {string} IGN_ES - Identificador del servicio de elevación del Instituto Geográfico Nacional de España.\r\n * @property {string} IGN_FR - Identificador del servicio de elevación del Instituto Geográfico Nacional Francés.\r\n * @see SITNA.ElevationOptions\r\n */\r\nConsts.elevationService = {\r\n    GOOGLE: 'elevationServiceGoogle',\r\n    IDENA: 'elevationServiceIDENA',\r\n    IGN_ES: 'elevationServiceIGNEs',\r\n    IGN_FR: 'elevationServiceIGNFr'\r\n};\r\n\r\n/**\r\n * Opciones de la herramienta de elevación.\r\n * @typedef ElevationOptions\r\n * @memberof SITNA\r\n * @see SITNA.control.DrawMeasureModifyOptions\r\n * @property {number} [resolution] - Distancia máxima en metros entre puntos con elevaciones. \r\n * Si la distancia entre vértices de la geometría de la que queremos obtener los valores de elevación es mayor \r\n * que este valor, se añaden puntos intermedios hasta que esa distancia sea menor o igual a este valor.\r\n * @property {number} [sampleNumber] - Número total de puntos de la geometría con elevación.\r\n * \r\n * Si la geometría tiene más puntos que el valor de esta propiedad, se elminarán de manera repartida los \r\n * puntos sobrantes.\r\n * \r\n * Si la geometría tiene menos puntos que este valor, se insertarán puntos de manera repartida a lo largo de la geometría.\r\n * \r\n * Si esta propiedad entra en conflicto con la propiedad `resolution`, prevalece `resolution`.\r\n * @property {string[]|SITNA.ElevationServiceOptions[]} [services=[SITNA.Consts.elevationService.IDENA]{@link SITNA.Consts}, [SITNA.Consts.elevationService.IGN_FR]{@link SITNA.Consts}, [SITNA.Consts.elevationService.IGN_ES]{@link SITNA.Consts}] - Lista priorizada con identificadores de servicio de elevación\r\n * (miembros de [SITNA.Consts.elevationService]{@link SITNA.Consts}) u objetos de configuración de servicio a los que se consulta para obtener el dato de elevación.\r\n * Si varios servicios devuelven un valor válido para un punto, se toma el valor del servicio que esté representado antes en esta lista.\r\n */\r\n\r\nTC.tool = TC.tool || {};\r\n\r\nconst Elevation = function (options) {\r\n    const self = this;\r\n    self.options = options || {};\r\n    self._servicePromises = [];\r\n    const serviceOptions = self.options.services || [\r\n        Consts.elevationService.IDENA,\r\n        Consts.elevationService.IGN_FR,\r\n        Consts.elevationService.IGN_ES/*,\r\n        Consts.elevationService.GOOGLE*/\r\n    ];      \r\n\r\n    serviceOptions.forEach(function (srv, idx) {\r\n        self._servicePromises[idx] = new Promise(function (resolve, _reject) {\r\n            const serviceName = typeof srv === 'string' ? srv : srv.name;\r\n            const ctorName = serviceName.substr(0, 1).toUpperCase() + serviceName.substr(1);\r\n            \r\n            const srvOptions = typeof srv === 'string' ? {} : srv;\r\n            import('./' + ctorName).then(function (elevationModule) {\r\n                const ElevationService = elevationModule.default;\r\n                TC.tool[ctorName] = ElevationService;\r\n                resolve(new ElevationService(srvOptions));\r\n            });\r\n        });\r\n    });\r\n};\r\n\r\n(function () {\r\n    const toolProto = Elevation.prototype;\r\n\r\n    let requestUID = 1;\r\n    const getRequestUID = function () {\r\n        const result = requestUID.toString();\r\n        requestUID++;\r\n        return result;\r\n    };\r\n\r\n    toolProto.getService = function (idx) {\r\n        return this._servicePromises[idx];\r\n    };\r\n\r\n    toolProto.getServices = function () {\r\n        return Promise.all(this._servicePromises);\r\n    };\r\n\r\n    toolProto.getElevation = async function (options) {\r\n        const self = this;\r\n        const opts = Object.assign({}, options);\r\n        opts.id = getRequestUID();\r\n        if (opts.resolution === undefined) {\r\n            opts.resolution = self.options.resolution;\r\n        }\r\n        if (opts.sampleNumber === undefined) {\r\n            opts.sampleNumber = self.options.sampleNumber;\r\n        }\r\n        let done = false;\r\n        let partialResult;\r\n        let partialCallback;\r\n        if (Util.isFunction(opts.partialCallback)) {\r\n            partialCallback = opts.partialCallback;\r\n        }\r\n\r\n        const isSinglePoint = opts.coordinates.length === 1;\r\n        opts.coordinates = Geometry.interpolate(opts.coordinates, opts);\r\n        opts.resolution = 0;\r\n        opts.sampleNumber = 0;\r\n\r\n        partialResult = opts.coordinates.map(p => [p[0], p[1], null]);\r\n\r\n        if (!Object.prototype.hasOwnProperty.call(opts, 'includeHeights')) {\r\n            opts.includeHeights = isSinglePoint;\r\n        }\r\n        const services = await self.getServices();\r\n        const responses = new Array(services.length);\r\n        responses.fill(false);\r\n        for (var i = 0, ii = services.length; i < ii; i++) {\r\n            const idx = i;\r\n            const srv = services[i];\r\n\r\n            // Creamos una promesa que se resuelve falle o no la petición\r\n            const request = async function () {\r\n                if (navigator.onLine) {\r\n                    try {\r\n                        const response = await srv.request(opts);\r\n                        if (done) {\r\n                            return null; // Ya no escuchamos a esta respuesta porque hemos terminado el proceso antes\r\n                        }\r\n                        else {\r\n                            return srv.parseResponse(response, opts);\r\n                        }\r\n                    }\r\n                    catch (_e) {\r\n                        return null;\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n            let response;\r\n            try {\r\n                response = await request();\r\n            }\r\n            catch (error) {\r\n                console.error(error);\r\n            }\r\n\r\n            if (!done) {\r\n                responses[idx] = response;\r\n                if (response === null) {\r\n                    // Respuesta fallida. Comprobamos si han fallado todas para terminar.\r\n                    if (responses.every(r => r === null)) {\r\n                        throw Error('No services available');\r\n                    }\r\n                }\r\n                else {\r\n                    if (self._updatePartialResult(partialResult, responses)) {\r\n                        done = true;\r\n                    }\r\n                    if (partialCallback) {\r\n                        partialCallback(partialResult);\r\n                    }\r\n                }\r\n                if (done) {\r\n                    responses.forEach((r, ri) => r === false && services[ri].cancelRequest(options.id));\r\n                    return partialResult.some(p => p[2] !== null) ? partialResult : [];\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    toolProto.setGeometry = async function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        const features = options.features || [];\r\n\r\n        if (features.length) {\r\n\r\n            const conditionToPromises = function (promises, resolve, reject) {\r\n                Promise.all(promises).then(\r\n                    function (results) {\r\n                        resolve(results);\r\n                    },\r\n                    function (error) {\r\n                        reject(error);\r\n                    }\r\n                );\r\n            };\r\n\r\n            if (options.maxCoordQuantity) {\r\n                if (options.resolution) {\r\n                    // Validador de número de coordenadas máximo\r\n                    const numPoints = features.reduce(function (acc, feat) {\r\n                        if (feat) {\r\n                            acc = acc + feat.getCoords({ pointArray: true }).length;\r\n                            switch (true) {\r\n                                case SITNA.feature.Polyline && feat instanceof SITNA.feature.Polyline:\r\n                                case SITNA.feature.Polygon && feat instanceof SITNA.feature.Polygon:\r\n                                case SITNA.feature.MultiPolyline && feat instanceof SITNA.feature.MultiPolyline:\r\n                                case SITNA.feature.MultiPolygon && feat instanceof SITNA.feature.MultiPolygon:\r\n                                    acc = acc + Math.floor(feat.getLength() / options.resolution);\r\n                                    break;\r\n                                default:\r\n                                    break;\r\n                            }\r\n                        }\r\n                        return acc;\r\n                    }, 0);\r\n                    if (numPoints > options.maxCoordQuantity) {\r\n                        throw Error(Elevation.errors.MAX_COORD_QUANTITY_EXCEEDED);\r\n                    }\r\n                }\r\n            }\r\n            const resolution = options.resolution || 0;\r\n            const getElevOptions = function (coords) {\r\n                return {\r\n                    crs: options.crs,\r\n                    coordinates: coords,\r\n                    resolution: resolution,\r\n                    sampleNumber: 0\r\n                };\r\n            };\r\n            const getRingElevPromises = function (ring) {\r\n                return self.getElevation(getElevOptions(ring));\r\n            };\r\n            const coordPromises = features.map(function (feature) {\r\n                return new Promise(function (res, rej) {\r\n\r\n                    switch (true) {\r\n                        case !feature:\r\n                            res(null);\r\n                            break;\r\n                        case SITNA.feature && SITNA.feature.MultiPolygon && feature instanceof SITNA.feature.MultiPolygon: {\r\n                            const polPromises = feature\r\n                                .getCoords()\r\n                                .map(function (polygon) {\r\n                                    return new Promise(function (rs, rj) {\r\n                                        conditionToPromises(polygon.map(getRingElevPromises), rs, rj);\r\n                                    });\r\n                                });\r\n                            conditionToPromises(polPromises, res, rej);\r\n                            break;\r\n                        }\r\n                        case SITNA.feature && SITNA.feature.Polygon && feature instanceof SITNA.feature.Polygon:\r\n                        case SITNA.feature && SITNA.feature.MultiPolyline && feature instanceof SITNA.feature.MultiPolyline: {\r\n                            const ringPromises = feature\r\n                                .getCoords()\r\n                                .map(getRingElevPromises);\r\n                            conditionToPromises(ringPromises, res, rej);\r\n                            break;\r\n                        }\r\n                        case SITNA.feature && SITNA.feature.Polyline && feature instanceof SITNA.feature.Polyline:\r\n                            self.getElevation(getElevOptions(feature.getCoords())).then(\r\n                                function (coords) {\r\n                                    res(coords);\r\n                                },\r\n                                function (error) {\r\n                                    rej(Error(error));\r\n                                }\r\n                            );\r\n                            break;\r\n                        case SITNA.feature && SITNA.feature.Point && feature instanceof SITNA.feature.Point:\r\n                            self.getElevation(getElevOptions([feature.getCoords()])).then(\r\n                                function (coords) {\r\n                                    res(coords[0]);\r\n                                },\r\n                                function (error) {\r\n                                    rej(Error(error));\r\n                                }\r\n                            );\r\n                            break;\r\n                        default:\r\n                            rej(Error(\"Geometry not supported\"));\r\n                            break;\r\n                    }\r\n                });\r\n            });\r\n\r\n            const coordsArray = await Promise.all(coordPromises);\r\n            const copyElevation = function (source, target) {\r\n                if (Geometry.isPoint(source)) {\r\n                    target[2] = source[2];\r\n                    if (source.length > 3) {\r\n                        target[3] = source[3];\r\n                    }\r\n                }\r\n                else if (Array.isArray(source)) {\r\n                    source.forEach(function (node, idx) {\r\n                        copyElevation(node, target[idx]);\r\n                    });\r\n                }\r\n            };\r\n            const getNumVertices = function (coords) {\r\n                if (Geometry.isPoint(coords)) {\r\n                    return 1;\r\n                }\r\n                if (Array.isArray(coords)) {\r\n                    return coords.reduce((prev, cur) => prev + getNumVertices(cur), 0);\r\n                }\r\n                return 0;\r\n            };\r\n            coordsArray.forEach(function (coords, idx) {\r\n                const feat = features[idx];\r\n                if (feat) {\r\n                    if (TC.isDebug) {\r\n                        console.log(\"Estableciendo elevaciones a entidad:\", feat);\r\n                    }\r\n                    const featCoords = feat.getCoords();\r\n                    if (getNumVertices(featCoords) === getNumVertices(coords)) {\r\n                        copyElevation(coords, featCoords);\r\n                        feat.setCoordinates(featCoords);\r\n                    }\r\n                    else if (coords) {\r\n                        feat.setCoordinates(coords);\r\n                    }\r\n                }\r\n            });\r\n            return features;\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    };\r\n\r\n    toolProto._updatePartialResult = function (coordinates, responses) {\r\n        let done = false;\r\n        let pending = false;\r\n        for (var i = 0, ii = coordinates.length; i < ii; i++) {\r\n            const point = coordinates[i];\r\n            let elevation = null;\r\n            let height = null;\r\n            const validResponses = responses.filter(r => r !== null);\r\n            for (var j = 0, jj = validResponses.length; j < jj; j++) {\r\n                const r = validResponses[j];\r\n                if (r === false) {\r\n                    pending = true;\r\n                }\r\n                if (Array.isArray(r)) {\r\n                    const rPoint = r[i];\r\n                    if (elevation === null && rPoint) {\r\n                        elevation = rPoint[2];\r\n                        if (rPoint.length > 3 && height === null) {\r\n                            height = rPoint[3];\r\n                        }\r\n                    }\r\n                }\r\n                if (elevation !== null) {\r\n                    point[2] = elevation;\r\n                    if (height !== null) {\r\n                        point[3] = height;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // Condiciones para acabar:\r\n        // 1: Tengo todas las elevaciones y no hay peticiones más prioritarias pendientes\r\n        // 2: Han contestado todos los servicios\r\n        done = !pending && coordinates.every(p => p[2] !== null) || responses.every(r => r !== false);\r\n        return done;\r\n    };\r\n\r\n})();\r\n\r\nElevation.errors = {\r\n    MAX_COORD_QUANTITY_EXCEEDED: 'max_coord_quantity_exceeded',\r\n    UNDEFINED: 'undefined'\r\n};\r\n\r\nElevation.getElevationGain = function (options) {\r\n    return Util.getElevationGain(options);\r\n};\r\n\r\nTC.tool.Elevation = Elevation;\r\nexport default Elevation;\r\n"],"names":["map","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","then","e","Error","code","ids","id","all","slice","keys","Object","module","exports","Consts","GOOGLE","IDENA","IGN_ES","IGN_FR","TC","Elevation","options","self","this","_servicePromises","services","forEach","srv","idx","_reject","serviceName","name","ctorName","substr","toUpperCase","srvOptions","elevationModule","ElevationService","default","toolProto","prototype","requestUID","getService","getServices","getElevation","async","opts","assign","result","toString","getRequestUID","undefined","resolution","sampleNumber","partialResult","partialCallback","done","Util","isSinglePoint","coordinates","length","Geometry","p","hasOwnProperty","call","includeHeights","responses","Array","fill","i","ii","request","navigator","onLine","response","parseResponse","_e","error","console","every","r","_updatePartialResult","ri","cancelRequest","some","setGeometry","features","conditionToPromises","promises","reject","results","maxCoordQuantity","reduce","acc","feat","getCoords","pointArray","SITNA","feature","Polyline","Polygon","MultiPolyline","MultiPolygon","Math","floor","getLength","errors","MAX_COORD_QUANTITY_EXCEEDED","getElevOptions","coords","crs","getRingElevPromises","ring","coordPromises","res","rej","polPromises","polygon","rs","rj","ringPromises","Point","coordsArray","copyElevation","source","target","isArray","node","getNumVertices","prev","cur","log","featCoords","setCoordinates","pending","point","elevation","height","validResponses","filter","j","jj","rPoint","UNDEFINED","getElevationGain"],"sourceRoot":""}