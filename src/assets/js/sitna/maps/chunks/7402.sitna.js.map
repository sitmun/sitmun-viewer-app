{"version":3,"file":"chunks/7402.sitna.js","mappings":"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","sources":["webpack://SITNA/./TC/cesium/mergeTerrainProvider/MergeTerrainProvider.js","webpack://SITNA/./node_modules/d3-polygon/src/contains.js"],"sourcesContent":["/* MergeTerrainProvider */\r\n\r\nimport * as D3 from 'd3-polygon';\r\n\r\nconst MergeTerrainProvider = function (options, view, fallbackOptions) {\r\n\r\n    this.noDataValue = options.noDataValue;\r\n    this.view = view;\r\n\r\n    this.commutingProvidersReady = false;\r\n    this.commutingProvidersPromises = cesium.when.defer();\r\n\r\n    this.surfaceHasTilesToRender = cesium.when.defer();\r\n    this.surfaceTilesToRender = 0;\r\n\r\n    this.fallback = fallbackOptions.fallback || [];\r\n    this.fallbackProvider = [];\r\n\r\n    this.fallbackProvider = this.fallback.map(function (options, index) {\r\n        if (options.type === \"WMTS\" || (!options.type && options.url.indexOf(\"WMTS\") >= 0)) {\r\n            return new cesium.WMTSTerrainProvider(options, view);\r\n        }\r\n        else\r\n            return new cesium.WCSTerrainProvider(options, view);\r\n    });\r\n\r\n    this.defaultFallbackProvider = new cesium.EllipsoidTerrainProvider();\r\n\r\n    this.attributions = {};\r\n\r\n    if (options.attributions) {\r\n        this.attributions = options.attributions;\r\n        this.view.map.trigger(SITNA.Consts.event.TERRAINPROVIDERADD, { terrainProvider: this });\r\n    }\r\n\r\n    if (!(options.url instanceof cesium.Resource)) {\r\n        options.url = new cesium.Resource({\r\n            url: options.url.trim()\r\n        });\r\n    }\r\n\r\n    cesium.CesiumTerrainProvider.call(this, options);\r\n\r\n    this.boundaries = Array.isArray(fallbackOptions.boundaries) ? fallbackOptions.boundaries : [fallbackOptions.boundaries];\r\n\r\n    cesium.when.all([this._readyPromise, this.fallbackProvider[0].readyPromise, this.surfaceHasTilesToRender], function () {\r\n        this.commutingProvidersReady = true;\r\n        this.commutingProvidersPromises.resolve();\r\n    }.bind(this))\r\n};\r\n(function () { \r\n\r\n    MergeTerrainProvider.prototype = Object.create(cesium.CesiumTerrainProvider.prototype, {\r\n        fallback: { /* array con las opciones de los servicios WCS */\r\n            value: null,\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true\r\n        },\r\n        fallbackProvider: { /* array con los proveedores WCS */\r\n            value: null,\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true\r\n        },\r\n        defaultFallbackProvider: { /* proveedor de ltimo recurso */\r\n            value: null,\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true\r\n        },\r\n        allReady: {\r\n            get: function () {\r\n                return this.commutingProvidersReady;\r\n            }\r\n        },\r\n        allReadyPromise: {\r\n            get: function () {\r\n                return this.commutingProvidersPromises;\r\n            }\r\n        }\r\n    });\r\n    MergeTerrainProvider.prototype.constructor = MergeTerrainProvider;\r\n\r\n    //MergeTerrainProvider.prototype.loadPolygonContains = function () {\r\n    //    return new Promise(async function (resolve) {\r\n    //        if (!D3) {\r\n    //            D3 = await import('d3-polygon');\r\n    //        }\r\n    //        resolve(D3);\r\n    //    })        \r\n    //};\r\n\r\n    MergeTerrainProvider.prototype.isPointInDefaultBoundaries = function (cartographic) {\r\n        var self = this;\r\n        if (!self.boundaries.length)\r\n            return true;\r\n        return self.isPointInBoundaries(cartographic, self.boundaries[0]);\r\n    };\r\n\r\n    MergeTerrainProvider.prototype.isInDefaultBoundaries = function (x, y, level) {\r\n        var self = this;\r\n        if (!self.boundaries.length)\r\n            return true;\r\n        return self.isInBoundaries(x, y, level, self.boundaries[0]);\r\n    };\r\n    MergeTerrainProvider.prototype.isPointInBoundaries = function (cartographic, boundaries) {\r\n        \r\n        return boundaries.some((bound) => D3.polygonContains(bound, [cesium.Math.toDegrees(cartographic.longitude), cesium.Math.toDegrees(cartographic.latitude)]));\r\n    };\r\n    MergeTerrainProvider.prototype.isInBoundaries = function (x, y, level, boundaries) {\r\n        var self = this;\r\n\r\n        var toCheck = [];\r\n        var rectangle = this.tilingScheme.tileXYToRectangle(x, y, level);\r\n\r\n        toCheck.push(new cesium.Cartographic(rectangle.west, rectangle.south));\r\n        toCheck.push(new cesium.Cartographic(rectangle.west, rectangle.north));\r\n        toCheck.push(new cesium.Cartographic(rectangle.east, rectangle.south));\r\n        toCheck.push(new cesium.Cartographic(rectangle.east, rectangle.north));\r\n\r\n        for (var i = 0; i < toCheck.length; i++) {\r\n            if (!self.isPointInBoundaries(toCheck[i], boundaries)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    MergeTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {\r\n\r\n        ///* la disponibilidad del globo depende de que haya tiles renderizados/pendientes de rederizar. Si resuelvo la promesa al instanciar, \r\n        //   no al pedir tiles, llega a usar el globo antes de estar disponible.  */\r\n        if (this.surfaceTilesToRender > 5) {\r\n            this.surfaceHasTilesToRender.resolve();\r\n        }\r\n        this.surfaceTilesToRender++;\r\n\r\n        /* Si estamos en Navarra y el nivel que se va a pedir es mayor que el disponible en nuestro terreno nos ahorramos la peticin */\r\n        if (level > this._availability._maximumLevel && this.isInDefaultBoundaries(x, y, level)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    MergeTerrainProvider.prototype.getAttribution = function () {\r\n        var self = this;\r\n\r\n        return self.attributions;\r\n    };\r\n\r\n    MergeTerrainProvider.prototype.requestTileGeometry = function (x, y, level) {\r\n        const self = this;\r\n        let promise = cesium.when.defer();\r\n\r\n        const manageAttributions = function (provider) {\r\n            self.view.map.trigger(SITNA.Consts.event.TERRAINPROVIDERADD, { terrainProvider: provider });\r\n        };\r\n\r\n        const otherwise = function () {\r\n\r\n            if (self.fallbackProvider) {\r\n                //desechamos los que no est preparados\r\n                const fallbackProvider = self.fallbackProvider.filter((fbp) => fbp.ready)\r\n                    //buscamos el provider que corresponda\r\n                    .find((fbp, index, arr) => {\r\n                        return arr.length === 1 || (index + 1 === self.boundaries.length) || self.isInBoundaries(x, y, level, self.boundaries[index + 1])\r\n\r\n                    })\r\n                if (fallbackProvider) {\r\n                    fallbackProvider.requestTileGeometry.apply(self, [x, y, level])\r\n                        .then(function (terrainData) {\r\n                            manageAttributions(fallbackProvider);\r\n                            promise.resolve(terrainData);\r\n                        }).otherwise(function () {\r\n                            promise.resolve(self.defaultFallbackProvider.requestTileGeometry([x, y, level]));\r\n                        });\r\n                }\r\n                else\r\n                    promise.resolve(self.defaultFallbackProvider.requestTileGeometry([x, y, level]));\r\n            }\r\n            else\r\n                promise.resolve(self.defaultFallbackProvider.requestTileGeometry([x, y, level]));\r\n\r\n        };\r\n\r\n\r\n        // as controlamos que las peticiones fuera de Navarra y mayor nivel que el soportado no se pidan y\r\n        // vamos directamente al proveedor de respaldo.\r\n        if (level > this._availability._maximumLevel) {\r\n            otherwise();\r\n        } else if (!this.isInDefaultBoundaries(x, y, level)) {\r\n            otherwise();\r\n        } else {\r\n            cesium.CesiumTerrainProvider.prototype.requestTileGeometry.apply(self, [x, y, level])\r\n                .then(function (args, terrainData) {\r\n                    if (terrainData._minimumHeight === self.noDataValue) {\r\n                        if (self.fallbackProvider && self.fallbackProvider[0].ready) {\r\n                            self.fallbackProvider[0].requestTileGeometry.apply(self, args)\r\n                                .then(function (terrainData) {\r\n                                    manageAttributions(self.fallbackProvider[0]);\r\n                                    promise.resolve(terrainData);\r\n                                }).otherwise(function () {\r\n                                    promise.resolve(self.defaultFallbackProvider.requestTileGeometry([x, y, level]));\r\n                                });\r\n                        } else {\r\n                            promise.resolve(self.defaultFallbackProvider.requestTileGeometry([x, y, level]));\r\n                        }\r\n                    } else {\r\n                        manageAttributions(self);\r\n                        promise.resolve(terrainData);\r\n                    }\r\n                }.bind(this, arguments))\r\n                .otherwise(otherwise);\r\n        }\r\n\r\n        return promise.then(function (terrainData) {\r\n            return terrainData;\r\n        });\r\n    };\r\n\r\n    MergeTerrainProvider.prototype.sampleTerrainMostDetailed = function (positions) {\r\n        var rectangle = cesium.Rectangle.fromCartographicArray(positions);\r\n        var toCheck = [cesium.Rectangle.center(rectangle),\r\n        cesium.Rectangle.northeast(rectangle),\r\n        cesium.Rectangle.northwest(rectangle),\r\n        cesium.Rectangle.southeast(rectangle),\r\n        cesium.Rectangle.southwest(rectangle)];\r\n\r\n        if (toCheck.filter(async function (position) { return await !this.isPointInDefaultBoundaries(position); }.bind(this)).length === 0) {\r\n            return cesium.sampleTerrainMostDetailed(this, positions);\r\n        } else {\r\n            return this.fallbackProvider[0].sampleTerrainMostDetailed(positions);\r\n        }\r\n\r\n    }\r\n    cesium.MergeTerrainProvider = MergeTerrainProvider;\r\n\r\n\r\n    const OGCTerrainProvider = function OGCTerrainProvider(description, view) {\r\n        this.view = view;\r\n\r\n        var deferred = cesium.when.defer();\r\n        this._ready = false;\r\n        this._readyPromise = deferred;\r\n\r\n        if (!cesium.defined(description)) {\r\n            throw new cesium.DeveloperError('description is required.');\r\n        }\r\n\r\n        this.description = description;\r\n        this.url = description.url;\r\n        this.layerName = description.layerName;\r\n\r\n        var errorEvent = new cesium.Event();\r\n\r\n        this._eventHelper = new cesium.EventHelper();\r\n\r\n        var credit = description.credit;\r\n        if (typeof credit === 'string') {\r\n            credit = new cesium.Credit(credit);\r\n        }\r\n\r\n        this.tileCacheService = new TileCacheService(this.type + 'Tiles');\r\n        this.tileCacheService.createDB();\r\n\r\n        this.lastTile = undefined;\r\n        this.ready = false;\r\n\r\n        this.DefaultProvider = new cesium.EllipsoidTerrainProvider();\r\n\r\n        Object.defineProperties(this, {\r\n            errorEvent: {\r\n                get: function () {\r\n                    return errorEvent;\r\n                }\r\n            },\r\n            credit: {\r\n                get: function () {\r\n                    return credit;\r\n                }\r\n            },\r\n            hasVertexNormals: {\r\n                get: function () {\r\n                    return false;\r\n                }\r\n            },\r\n            readyPromise: {\r\n                get: function () {\r\n                    return this._readyPromise.promise;\r\n                }\r\n            }\r\n        });\r\n\r\n        this._heightmapWidth = 65;\r\n\r\n        this.noDataValue = description.noDataValue;\r\n\r\n        // atribuciones\r\n        this.urlofServer;\r\n        if (cesium.defined(this.url)) {\r\n            this.urlofServer = this.url;\r\n            var index = this.urlofServer.lastIndexOf(\"?\");\r\n            if (index > -1) {\r\n                this.urlofServer = this.urlofServer.substring(0, index);\r\n            }\r\n        }\r\n        TerrainParser.apply(this, [this.getCapabilities()]);\r\n        /**\r\n            * static array where CRS availables for OGCHelper are defined\r\n            */\r\n\r\n        this.OGCHelper.CRS = [{\r\n            name: \"CRS:84\",\r\n            ellipsoid: cesium.Ellipsoid.WGS84,\r\n            firstAxeIsLatitude: false,\r\n            tilingScheme: cesium.GeographicTilingScheme,\r\n            SupportedCRS: [\"urn:ogc:def:crs:OGC:2:84\"]\r\n        }, {\r\n            name: \"EPSG:4258\",\r\n            ellipsoid: cesium.Ellipsoid.WGS84,\r\n            firstAxeIsLatitude: true,\r\n            tilingScheme: cesium.GeographicTilingScheme,\r\n            SupportedCRS: [\"urn:ogc:def:crs:EPSG::4258\", \"EPSG:4258\", \"IGNF:WGS84G\"]\r\n        },\r\n        {\r\n            name: \"EPSG:4326\",\r\n            ellipsoid: cesium.Ellipsoid.WGS84,\r\n            firstAxeIsLatitude: true,\r\n            tilingScheme: cesium.GeographicTilingScheme,\r\n            SupportedCRS: [\"urn:ogc:def:crs:EPSG::4326\", \"EPSG:4326\"]\r\n        }, {\r\n            name: \"EPSG:3857\",\r\n            ellipsoid: cesium.Ellipsoid.WGS84,\r\n            firstAxeIsLatitude: false,\r\n            tilingScheme: cesium.WebMercatorTilingScheme,\r\n            SupportedCRS: [\"urn:ogc:def:crs:EPSG::3857\", \"EPSG:3857\"]\r\n        }, {\r\n            name: \"OSGEO:41001\",\r\n            ellipsoid: cesium.Ellipsoid.WGS84,\r\n            firstAxeIsLatitude: false,\r\n            tilingScheme: cesium.WebMercatorTilingScheme,\r\n            SupportedCRS: [\"urn:ogc:def:crs:EPSG::3857\"]\r\n        }];\r\n\r\n        this.OGCHelper.FormatImage = [{\r\n            format: \"image/png\",\r\n            extension: \"png\"\r\n        }, {\r\n            format: \"image/jpeg\",\r\n            extension: \"jpg\"\r\n        }, {\r\n            format: \"image/jpeg\",\r\n            extension: \"jpeg\"\r\n        }, {\r\n            format: \"image/gif\",\r\n            extension: \"gif\"\r\n        }, {\r\n            format: \"image/png; mode=8bit\",\r\n            extension: \"png\"\r\n        }, {\r\n            format: \"image/tiff\",\r\n            extension: \"tiff\"\r\n        }, {\r\n            format: \"image/tiff\",\r\n            extension: \"geotiff\"\r\n        },\r\n        {\r\n            format: \"image/tiff\",\r\n            extension: \"geotiffint16\"\r\n        }, {\r\n            format: \"image/x-bil;bits=32\",\r\n            extension: \"x-bil\"\r\n        }];\r\n\r\n        this.format = this.OGCHelper.FormatImage.find((f) => f.extension === description.format.toLowerCase()).format;\r\n    }\r\n    OGCTerrainProvider.prototype.getAttribution = function () {\r\n        var self = this;\r\n\r\n        return self.attributions;\r\n    };\r\n    OGCTerrainProvider.prototype.OGCHelper = {};\r\n\r\n    OGCTerrainProvider.TiledError = function () {\r\n        console.log(\"TiledError\");\r\n    };\r\n    OGCTerrainProvider.prototype.ImageToHeightmapTerrainData = function (noDataValue, arrayBuffer, size, x, y, level, tilingSc) {\r\n        if (this.format === \"image/tiff\")\r\n            return this.GeotiffToHeightmapTerrainData(noDataValue, arrayBuffer, size, x, y, level, tilingSc);\r\n        else if (this.format === \"image/x-bil;bits=32\")\r\n            debugger;\r\n        else\r\n            return imageToBuffer(arrayBuffer, {\r\n                offset: 0,\r\n                lowest: 0,\r\n                highest: 3700\r\n            }, size, true);\r\n\r\n\r\n    }\r\n\r\n    OGCTerrainProvider.prototype.GeotiffToHeightmapTerrainData = function (noDataValue, arrayBuffer, size, x, y, level, tilingSc) {\r\n\r\n        if (typeof (size) == \"number\") {\r\n            size = { width: size, height: size };\r\n        }\r\n\r\n        var parser = new GeotiffParser();\r\n        parser.parseHeader(arrayBuffer);\r\n        var width = parser.imageWidth;\r\n        var height = parser.imageLength;\r\n\r\n        //console.log(\"Level \" , level , \"w\" ,size.width, \"h\" , size.height);\r\n\r\n        var index = 0;\r\n        var heightBuffer = new Float32Array(size.height * size.width);\r\n\r\n        // Convert pixelValue to heightBuffer \r\n        //--------------------------------------\r\n        // We need to return a Heighmap of size 65x65\r\n        // The requested Tile from WCS should be cloth but not 65x65 \r\n        // We need to work in Native coordinate then get the pixel from the Parser.\r\n\r\n        // Here we need to check if the tilingScheme.CRS is the same of the Image \r\n        // If no we need to convert \r\n        // But It will to slow the processus then we should assume tilingScheme has been set \r\n        // with the CRS of the image \r\n\r\n        if (size.height != height || size.width != width) {\r\n            var rect = tilingSc.tileXYToNativeRectangle(x, y, level);\r\n            var xSpacing = (rect.east - rect.west) / size.width;\r\n            var ySpacing = (rect.north - rect.south) / size.height;\r\n\r\n            for (var j = 0; j < size.height; j++)\r\n                for (var i = 0; i < size.width; i++) {\r\n                    // Transform i,j of the Heighmap into res[1], res[2] of the downloaded image\r\n                    // if downloaded image is the same zize of heightBuffer this convertion wouldn't be done\r\n\r\n                    var lon = rect.west + xSpacing * i;\r\n                    var lat = rect.north - ySpacing * j;\r\n                    var res = parser.PCSToImage(lon, lat);\r\n                    if (res[0] == 1) {\r\n                        var pixelValue = parser.getPixelValueOnDemand(res[1], res[2]);\r\n                        if (!pixelValue || (pixelValue && pixelValue[0] <= noDataValue)) {\r\n                            heightBuffer[index] = 0.0;\r\n                        } else {\r\n                            heightBuffer[index] = pixelValue[0];\r\n                        }\r\n                    }\r\n                    else {\r\n                        heightBuffer[index] = 0.0;\r\n                    }\r\n                    index++;\r\n                }\r\n        }\r\n        else {\r\n            for (var j = 0; j < size.height; j++)\r\n                for (var i = 0; i < size.width; i++) {\r\n                    var pixelValue = parser.getPixelValueOnDemand(i, j);\r\n                    if (!pixelValue || (pixelValue && pixelValue[0] <= noDataValue)) {\r\n                        heightBuffer[index] = 0.0;\r\n                    } else {\r\n                        heightBuffer[index] = pixelValue[0];\r\n                    }\r\n                    index++;\r\n                }\r\n        }\r\n\r\n        return heightBuffer;\r\n    };\r\n\r\n    OGCTerrainProvider.prototype.HeightmapTerrainData = function (heightBuffer, size, childrenMask) {\r\n        if (typeof (size) == \"number\") {\r\n            size = { width: size, height: size };\r\n        }\r\n\r\n        if (!cesium.defined(heightBuffer)) {\r\n            throw new cesium.DeveloperError(\"no good size\");\r\n        }\r\n        var optionsHeihtmapTerrainData = {\r\n            buffer: heightBuffer,\r\n            width: size.width,\r\n            height: size.height,\r\n            childTileMask: childrenMask\r\n        };\r\n\r\n        return new cesium.HeightmapTerrainData(optionsHeihtmapTerrainData);\r\n    }\r\n\r\n\r\n    /*\r\n    https://github.com/xlhomme/WCSTerrainProvider/tree/master/\r\n    Modificado por GLS\r\n    WCSTerrainProvider  */\r\n    /*\r\n    Objeto del que heredarn WCSTerrainProvider y WMTSTerrainProvider\r\n     */\r\n\r\n\r\n\r\n    const WCSTerrainProvider = function WCSTerrainProvider(description, view) {\r\n\r\n        this.parse = function (description) {\r\n            var self = this;\r\n            var resultat;\r\n            description = cesium.defaultValue(description,\r\n                cesium.defaultValue.EMPTY_OBJECT);\r\n            if (cesium.defined(description.url)) {\r\n                var urlofServer = description.url;\r\n                var index = urlofServer.lastIndexOf(\"?\");\r\n                if (index > -1) {\r\n                    urlofServer = urlofServer.substring(0, index);\r\n                }\r\n                // get version of wcs\r\n                if (!cesium.defined(description.layerName)) {\r\n                    throw new cesium.DeveloperError(\r\n                        'description.layerName is required.');\r\n                }\r\n\r\n                var urlDescribeCoverage = urlofServer + '?SERVICE=WCS&VERSION=1.0.0&request=DescribeCoverage&CoverageId=' + description.layerName;\r\n\r\n                if (cesium.defined(description.proxy)) {\r\n                    urlDescribeCoverage = description.proxy.getURL(urlDescribeCoverage);\r\n                }\r\n\r\n                resultat = cesium.when(cesium.Resource.fetchXML({\r\n                    url: urlDescribeCoverage\r\n                }), function (xml) {\r\n                    return self.getDescribeCoverage(xml, description);\r\n                }).otherwise(function () {\r\n                    return cesium.when.defer.resolve(null);\r\n                });\r\n\r\n\r\n            } else if (cesium.defined(description.xml)) {\r\n                resultat = self.getDescribeCoverage(description.xml, description);\r\n            } else {\r\n                throw new cesium.DeveloperError(\r\n                    'either description.url or description.xml are required.');\r\n            }\r\n            resultat.type = \"WCS\";\r\n            return resultat;\r\n        };\r\n        this.getDescribeCoverage = function (coverage, description) {\r\n\r\n            var resultat = {};\r\n            const self = this;\r\n\r\n            if (!cesium.defined(description.layerName)) {\r\n                throw new cesium.DeveloperError(\r\n                    'description.layerName is required.');\r\n            }\r\n\r\n            var layerName = description.layerName;\r\n            resultat.minLevel = cesium.defaultValue(description.minLevel, undefined);\r\n            resultat.maxLevel = cesium.defaultValue(description.maxLevel, undefined);\r\n\r\n            resultat.heightMapWidth = cesium.defaultValue(description.heightMapWidth, 65);\r\n            resultat.heightMapHeight = cesium.defaultValue(description.heightMapHeight, resultat.heightMapWidth);\r\n\r\n            var corner = coverage.querySelector('lonLatEnvelope').textContent.trim().split(' ').filter(function (elm) { return elm.trim().length > 0 });\r\n\r\n            var lowerCorner = convertToFloat(corner.slice(0, 2));\r\n            var upperCorner = convertToFloat(corner.slice(2));\r\n\r\n            resultat.upperCorner = upperCorner;\r\n            resultat.lowerCorner = lowerCorner;\r\n\r\n            var low = convertToFloat(coverage.querySelector('gml\\\\:low, low').textContent.split(' '));\r\n            var high = convertToFloat(coverage.querySelector('gml\\\\:high, high').textContent.split(' '));\r\n\r\n            var epsgCode = 4326;\r\n            var projstring = 'EPSG:' + epsgCode.toString();\r\n            var getCRS = this.OGCHelper.CRS.filter(function (elt) {\r\n                return elt.name === projstring;\r\n            });\r\n            if (getCRS.length > 0)\r\n                resultat.tilingScheme = new getCRS[0].tilingScheme({\r\n                    ellipsoid: getCRS[0].ellipsoid\r\n                });\r\n            else\r\n                resultat.tilingScheme = undefined;\r\n\r\n            resultat.pixelSize = [65, 65];\r\n\r\n            resultat.levelZeroMaximumGeometricError = cesium.TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(resultat.tilingScheme._ellipsoid,\r\n                Math.min(resultat.heightMapWidth, resultat.heightMapHeight),\r\n                resultat.tilingScheme.getNumberOfXTilesAtLevel(0));\r\n\r\n            resultat.waterMask = false;\r\n            resultat.ready = true;\r\n\r\n            var bbox = {\r\n                'WKID': epsgCode,\r\n                'EPSG': projstring,\r\n                'coord': [[lowerCorner[0], upperCorner[1]], [lowerCorner[0], lowerCorner[1]], [upperCorner[0], lowerCorner[1]], [upperCorner[0], upperCorner[1]]],\r\n                'ulidx': 0,\r\n                'llidx': 1,\r\n                'lridx': 2,\r\n                'uridx': 3\r\n            };\r\n            resultat.bbox = bbox;\r\n\r\n\r\n            resultat.getTileDataAvailable = function (x, y, level) {\r\n                if (level <= resultat.maxLevel && resultat.isInTile(x, y, level))\r\n                    return true;\r\n                return false;\r\n            };\r\n\r\n            // Define the URL for GetCoverage\r\n            this.urlofServer = description.url;\r\n            var index = this.urlofServer.lastIndexOf(\"?\");\r\n            if (index > -1) {\r\n                this.urlofServer = this.urlofServer.substring(0, index);\r\n            }\r\n\r\n            /* WCS 1.0.0 */\r\n            var urlGetTerrain = this.urlofServer +\r\n                \"?SERVICE=WCS&VERSION=1.0.0&REQUEST=GetCoverage\" +\r\n                \"&COVERAGE=\" + description.layerName + \"&FORMAT=\" + description.format + \"&BBOX=\" + \"{west},{south},{east},{north}\" + \"&WIDTH=\" + 65 + \"&HEIGHT=\" + 65 + \"&CRS=EPSG:4326\";\r\n\r\n            resultat.urlGetTerrain = urlGetTerrain;\r\n\r\n            // Is the X,Y,Level define a tile that is contains in our bbox\r\n            resultat.isTileInside = function (x, y, level) {\r\n                var inside = true;\r\n                var bbox = resultat.bbox;\r\n                var rect = self.tilingScheme.tileXYToNativeRectangle(x, y, level);\r\n\r\n                if (bbox.coord[bbox.ulidx][0] >= rect.east || bbox.coord[bbox.lridx][0] <= rect.west ||\r\n                    bbox.coord[bbox.lridx][1] >= rect.north || bbox.coord[bbox.ulidx][1] <= rect.south) {\r\n                    inside = false;\r\n                }\r\n                return inside;\r\n            };\r\n            // Is the X,Y,Level define a tile that contains or ovelaps our bbox\r\n            resultat.isInTile = function (x, y, level) {\r\n                var inside = false;\r\n                var bbox = resultat.bbox;\r\n                var rect = resultat.tilingScheme.tileXYToNativeRectangle(x, y, level);\r\n                // One point of the bbox is in the tile\r\n                if ((bbox.coord[bbox.ulidx][0] >= rect.west && bbox.coord[bbox.ulidx][0] <= rect.east &&\r\n                    bbox.coord[bbox.ulidx][1] >= rect.south && bbox.coord[bbox.ulidx][1] <= rect.north) ||\r\n                    (bbox.coord[bbox.uridx][0] >= rect.west && bbox.coord[bbox.uridx][0] <= rect.east &&\r\n                        bbox.coord[bbox.uridx][1] >= rect.south && bbox.coord[bbox.uridx][1] <= rect.north) ||\r\n                    (bbox.coord[bbox.llidx][0] >= rect.west && bbox.coord[bbox.llidx][0] <= rect.east &&\r\n                        bbox.coord[bbox.llidx][1] >= rect.south && bbox.coord[bbox.llidx][1] <= rect.north) ||\r\n                    (bbox.coord[bbox.lridx][0] >= rect.west && bbox.coord[bbox.lridx][0] <= rect.east &&\r\n                        bbox.coord[bbox.lridx][1] >= rect.south && bbox.coord[bbox.lridx][1] <= rect.north) ||\r\n                    // or the tile is in the bbox\r\n                    (bbox.coord[bbox.ulidx][0] < rect.east && bbox.coord[bbox.lridx][0] > rect.west &&\r\n                        bbox.coord[bbox.lridx][1] < rect.north && bbox.coord[bbox.ulidx][1] > rect.south)\r\n                ) {\r\n                    inside = true;\r\n                }\r\n                return inside;\r\n\r\n            };\r\n            resultat.templateToURL = function (x, y, level) {\r\n                var rect = self.tilingScheme.tileXYToNativeRectangle(x, y, level);\r\n                var xSpacing = (rect.east - rect.west) / (self.heightMapWidth - 1);\r\n                var ySpacing = (rect.north - rect.south) / (self.heightMapHeight - 1);\r\n                rect.west -= xSpacing * 0.5;\r\n                rect.east += xSpacing * 0.5;\r\n                rect.south -= ySpacing * 0.5;\r\n                rect.north += ySpacing * 0.5;\r\n                return resultat.urlGetTerrain.replace(\"{south}\", rect.south).replace(\"{north}\", rect.north).replace(\"{west}\", rect.west).replace(\"{east}\", rect.east);\r\n            }\r\n\r\n            return resultat;\r\n        };\r\n\r\n        this.type = \"WCS\";\r\n        OGCTerrainProvider.apply(this, [description, view]);\r\n\r\n    };\r\n\r\n    WCSTerrainProvider.prototype = Object.create(OGCTerrainProvider.prototype);\r\n    WCSTerrainProvider.prototype.constructor = WCSTerrainProvider;\r\n\r\n    WCSTerrainProvider.prototype.getCapabilities = function () {\r\n\r\n        var urlGetCapabilities = this.urlofServer + '?SERVICE=WCS&VERSION=1.0.0&request=GetCapabilities';\r\n        cesium.when(cesium.Resource.fetchXML({\r\n            url: urlGetCapabilities\r\n        }), function (xml) {\r\n            if (xml.querySelector('Service')) {\r\n                this.attributions = {};\r\n                var labelNode = xml.querySelector('Service').querySelector('label');\r\n                if (labelNode) {\r\n                    this.attributions.name = labelNode.textContent.trim();\r\n                }\r\n                var linkNode = xml.querySelector('Service').querySelector('metadataLink');\r\n                if (linkNode) {\r\n                    this.attributions.site = linkNode.getAttribute('about');\r\n                }\r\n            }\r\n        }.bind(this));\r\n\r\n        this.description = cesium.defaultValue(this.description, cesium.defaultValue.EMPTY_OBJECT);\r\n        return this.parse.apply(this, [this.description]);\r\n    }\r\n\r\n    var WMTSTerrainProvider = function WMTSTerrainProvider(description, view) {\r\n\r\n        this._parse = function (description) {\r\n            var self = this;\r\n            var resultat;\r\n            description = cesium.defaultValue(description,\r\n                cesium.defaultValue.EMPTY_OBJECT);\r\n            if (cesium.defined(description.url)) {\r\n                var urlofServer = description.url;\r\n                var index = urlofServer.lastIndexOf(\"?\");\r\n                if (index > -1) {\r\n                    urlofServer = urlofServer.substring(0, index);\r\n                }\r\n                // get version of wcs\r\n                if (!cesium.defined(description.layerName)) {\r\n                    throw new cesium.DeveloperError(\r\n                        'description.layerName is required.');\r\n                }\r\n\r\n                var urlDescribeCoverage = urlofServer + '?SERVICE=WCS&VERSION=1.0.0&request=DescribeCoverage&CoverageId=' + description.layerName;\r\n\r\n                if (cesium.defined(description.proxy)) {\r\n                    urlDescribeCoverage = description.proxy.getURL(urlDescribeCoverage);\r\n                }\r\n\r\n                resultat = cesium.when(cesium.Resource.fetchXML({\r\n                    url: urlDescribeCoverage\r\n                }), function (xml) {\r\n                    return self.getDescribeCoverage(xml, description);\r\n                }).otherwise(function () {\r\n                    return cesium.when.defer.resolve(null);\r\n                });\r\n\r\n\r\n            } else if (cesium.defined(description.xml)) {\r\n                resultat = self.getDescribeCoverage(description.xml, description);\r\n            } else {\r\n                throw new cesium.DeveloperError(\r\n                    'either description.url or description.xml are required.');\r\n            }\r\n            resultat.type = \"WMTS\";\r\n            return resultat;\r\n        };\r\n        this.parse = function (xml, description) {\r\n            const self = this;\r\n            const maxLevel = description.maxLevel || 20;\r\n            const layerName = description.layerName;\r\n            let styleName = description.styleName;\r\n            let template = null;\r\n            let listTileMatrixSetLinkNode = [];\r\n            let urlKVP = null, urlRESTful = null;\r\n            let formatImage = null;\r\n            const proxy = description.proxy;\r\n            const resultat = self.OGCHelper.generate(description);\r\n            //KVP support for now\r\n\r\n            Array.from(xml.querySelectorAll('Operation[name=\"GetTile\"] HTTP Get'))\r\n                .map((elt) => ({ node: elt, type: elt.querySelector(\"Value\").textContent }))\r\n                .forEach(item => {\r\n                    if (item.type === \"RESTful\" && urlRESTful === null) {\r\n                        urlRESTful = item.node.getAttribute(\"xlink:href\");\r\n                        if (proxy) { urlRESTful = proxy.getURL(urlRESTful); }\r\n                    }\r\n                    if (item.type === \"KVP\" && urlKVP === null) {\r\n                        urlKVP = item.node.getAttribute(\"xlink:href\");\r\n                        if (proxy) { urlKVP = proxy.getURL(urlKVP); }\r\n                    }\r\n                });\r\n\r\n            const nodeIdentifiers = xml.querySelectorAll(\"Contents>Layer>Identifier\");\r\n            let layerNode = null;\r\n            for (let i = 0; i < nodeIdentifiers.length && layerNode === null; i++) {\r\n                if (layerName === nodeIdentifiers[i].textContent) {\r\n                    layerNode = nodeIdentifiers[i].parentNode;\r\n                }\r\n            }\r\n\r\n            if (layerNode !== null) {\r\n                //optionality of style in geoserver is not compliant with OGC requirements!!\r\n                let defaultStyle, selectedStyle;\r\n                Array.from(layerNode.querySelectorAll(\"Style\")).forEach(item => {\r\n                    const style = item.querySelector(\"Identifier\").textContent;\r\n                    if (item.getAttribute(\"isDefault\") != null) { defaultStyle = style; }\r\n                    if (style === styleName) { selectedStyle = style; }\r\n                });\r\n                //Work with attribute isDefault when no style was defined!!\r\n                if (!styleName || styleName !== selectedStyle) { styleName = defaultStyle || ''; }\r\n\r\n                //format\r\n                const nodeFormats = Array.from(layerNode.querySelectorAll(\"Format\"));\r\n                for (let l = 0; l < self.OGCHelper.FormatImage.length && formatImage === null; l++) {\r\n                    const validFormats = nodeFormats.filter(elt => elt.textContent === self.OGCHelper.FormatImage[l].format && elt.textContent === self.format);\r\n                    if (validFormats.length > 0) { formatImage = self.OGCHelper.FormatImage[l]; }\r\n                }\r\n                if (!formatImage)\r\n                    throw new cesium.DeveloperError(\r\n                        'image format not valid.');\r\n                //TileMatrixSetLink =>TileMatrixSet\r\n                listTileMatrixSetLinkNode = Array.from(layerNode.querySelectorAll(\"TileMatrixSetLink\"));\r\n            }\r\n\r\n            const nodeMatrixSetIds = Array.from(xml.querySelectorAll(\"TileMatrixSet>Identifier\"));\r\n            for (let a = 0; a < listTileMatrixSetLinkNode.length && !resultat.ready; a++) {\r\n                const matrixSetLinkNode = listTileMatrixSetLinkNode[a];\r\n                const tileMatrixSetLinkName = matrixSetLinkNode.querySelector(\"TileMatrixSet\").textContent;\r\n                let tileMatrixSetNode = null;\r\n                let CRSSelected = null;\r\n\r\n                for (let i = 0; i < nodeMatrixSetIds.length && tileMatrixSetNode === null; i++) {\r\n                    if (nodeMatrixSetIds[i].textContent === tileMatrixSetLinkName) { tileMatrixSetNode = nodeMatrixSetIds[i].parentNode; }\r\n                }\r\n\r\n                const supportedCRS = tileMatrixSetNode.querySelector(\"SupportedCRS\").textContent;\r\n                for (let n = 0; n < self.OGCHelper.CRS.length && CRSSelected === null; n++) {\r\n                    if (self.OGCHelper.CRS[n].SupportedCRS.includes(supportedCRS)) { CRSSelected = self.OGCHelper.CRS[n]; }\r\n                }\r\n\r\n                if (CRSSelected !== null) {\r\n\r\n                    const tileSets = Array.from(tileMatrixSetNode.querySelectorAll(\"TileMatrix\"))\r\n                        .map(function (noeud) {\r\n                            let id = noeud.querySelector(\"Identifier\").textContent;\r\n                            let maxWidth = parseInt(noeud.querySelector(\"MatrixWidth\").textContent, 10);\r\n                            let maxHeight = parseInt(noeud.querySelector(\"MatrixHeight\").textContent, 10);\r\n                            let tileWidth = parseInt(noeud.querySelector(\"TileWidth\").textContent, 10);\r\n                            let tileHeight = parseInt(noeud.querySelector(\"TileHeight\").textContent, 10);\r\n                            let scaleDenominator = parseFloat(noeud.querySelector(\"ScaleDenominator\").textContent);\r\n                            return {\r\n                                id,\r\n                                maxWidth,\r\n                                maxHeight,\r\n                                scaleDenominator,\r\n                                complete: false,\r\n                                tileWidth,\r\n                                tileHeight\r\n                            };\r\n                        })\r\n                        .sort((a, b) => b.scaleDenominator - a.scaleDenominator);\r\n\r\n                    const listTileMatrixLimits = Array.from(matrixSetLinkNode.querySelectorAll(\"TileMatrixSetLimits>TileMatrixLimits\"))\r\n                        .map(nodeLink => ({\r\n                            id: nodeLink.querySelector(\"TileMatrix\").textContent,\r\n                            bbox: {\r\n                                minTileRow: parseInt(nodeLink.querySelector(\"MinTileRow\").textContent, 10),\r\n                                maxTileRow: parseInt(nodeLink.querySelector(\"MaxTileRow\").textContent, 10),\r\n                                minTileCol: parseInt(nodeLink.querySelector(\"MinTileCol\").textContent, 10),\r\n                                maxTileCol: parseInt(nodeLink.querySelector(\"MaxTileCol\").textContent, 10)\r\n                            }\r\n                        }));\r\n                    tileSets.forEach(tile => {\r\n                        listTileMatrixLimits.forEach(nodeLink => {\r\n                            if (tile.id === nodeLink.id) {\r\n                                tile.bbox = nodeLink.bbox;\r\n                                tile.complete = true;\r\n                            }\r\n                        });\r\n                    });\r\n\r\n                    if (tileSets.length > 0) {\r\n                        resultat.tilingScheme = new CRSSelected.tilingScheme({\r\n                            ellipsoid: CRSSelected.ellipsoid\r\n                        });\r\n                        const resourceURL = layerNode.querySelector(\"ResourceURL[format='\" + formatImage.format + \"']\");\r\n\r\n                        if (resourceURL !== null) {\r\n                            template = resourceURL.getAttribute(\"template\").replace(\"{TileRow}\", \"{y}\").replace(\"{TileCol}\", \"{x}\").replace(\"{style}\", styleName).replace(\"{Style}\", styleName).\r\n                                replace(\"{TileMatrixSet}\", tileMatrixSetLinkName).replace(\"{layer}\", layerName).replace(\"{infoFormatExtension}\", formatImage.extension);\r\n                        } else if (urlKVP !== null) {\r\n                            template = urlKVP + \"service=WMTS&request=GetTile&version=1.0.0&layer=\" + layerName + \"&style=\" + styleName + \"&format=\" + formatImage.format + \"&TileMatrixSet=\" + tileMatrixSetLinkName + \"&TileMatrix={TileMatrix}&TileRow={y}&TileCol={x}\"\r\n                        }\r\n\r\n                        if (template !== null) {\r\n                            resultat.minLevel = tileSets.length;\r\n                            resultat.maxLevel = 0;\r\n\r\n                            resultat.isTileInside = function (x, y, level) {\r\n                                return true;\r\n                                /*var inside = true;\r\n                                var bbox = resultat.bbox;\r\n                                var rect = self.tilingScheme.tileXYToNativeRectangle(x, y, level);\r\n\r\n                                if (bbox.coord[bbox.ulidx][0] >= rect.east || bbox.coord[bbox.lridx][0] <= rect.west ||\r\n                                    bbox.coord[bbox.lridx][1] >= rect.north || bbox.coord[bbox.ulidx][1] <= rect.south) {\r\n                                    inside = false;\r\n                                }\r\n                                return inside;*/\r\n                            };\r\n                            resultat.getTileDataAvailable = (x, y, level) => {\r\n                                let retour = false;\r\n                                if (level < maxLevel && level < tileSets.length) {\r\n                                    const tile = tileSets[level];\r\n                                    const bbox = tile.bbox;\r\n                                    if (tile.complete) {\r\n                                        retour = (y <= bbox.maxTileRow && y >= bbox.minTileRow) && (x <= bbox.maxTileCol && x >= bbox.minTileCol);\r\n                                    } else {\r\n                                        retour = x < tile.maxWidth && y < tile.maxHeight;\r\n                                    }\r\n                                }\r\n                                return retour;\r\n                            };\r\n                            resultat.templateToURL = function (x, y, level) {\r\n                                let retour = \"\";\r\n                                if (self.getTileDataAvailable(x, y, level)) {\r\n                                    let tile = tileSets[level];\r\n                                    retour = template.replace(\"{TileMatrix}\", tile.id).replace(\"{x}\", x).replace(\"{y}\", y);\r\n                                }\r\n                                return retour;\r\n                            };\r\n\r\n                            const imageSize = {\r\n                                width: tileSets[0].tileWidth,\r\n                                height: tileSets[0].tileHeight\r\n                            };\r\n                            const checkSize = tileSets.filter(elt => elt.tileWidth != imageSize.width || elt.tileHeight != imageSize.height);\r\n                            if (checkSize.length === 0) {\r\n                                resultat.imageSize = imageSize;\r\n                            }\r\n                            resultat.heightMapWidth = cesium.defaultValue(imageSize.width, 256);\r\n                            resultat.heightMapHeight = cesium.defaultValue(imageSize.widht, 256);\r\n                            resultat.urlGetTile = template;\r\n                            resultat.ready = true;\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n            return resultat;\r\n        };\r\n\r\n        this.type = \"WMTS\";\r\n        OGCTerrainProvider.apply(this, [description, view]);\r\n    };\r\n\r\n    WMTSTerrainProvider.prototype = Object.create(OGCTerrainProvider.prototype);\r\n    WMTSTerrainProvider.prototype.constructor = WMTSTerrainProvider;\r\n    WMTSTerrainProvider._super = OGCTerrainProvider.prototype;\r\n\r\n    WMTSTerrainProvider.prototype.getCapabilities = function () {\r\n        const self = this;\r\n        var urlGetCapabilities = self.urlofServer + '?SERVICE=WMTS&request=GetCapabilities';\r\n\r\n        if (cesium.defined(self.description.proxy)) {\r\n            urlGetCapabilities = self.description.proxy.getURL(urlGetCapabilities);\r\n        }\r\n\r\n        description = cesium.defaultValue(self.description, cesium.defaultValue.EMPTY_OBJECT);\r\n        //var promise = OGCHelper.WMTSParser.generate(description);\r\n\r\n        const promises = cesium.when.defer();\r\n        cesium.when(cesium.Resource.fetchXML({\r\n            url: urlGetCapabilities\r\n        }), function (xml) {\r\n            this.attributions = {};\r\n            if (xml.querySelector('ServiceIdentification')) {\r\n                var labelNode = xml.querySelector('ServiceIdentification').querySelector('Title');\r\n                if (labelNode) {\r\n                    this.attributions.name = labelNode.textContent.trim();\r\n                }\r\n            }\r\n            if (xml.querySelector('ServiceProvider')) {\r\n                var linkNode = xml.querySelector('ServiceProvider').querySelector('ProviderSite');\r\n                if (linkNode) {\r\n                    this.attributions.site = linkNode.getAttribute('href');\r\n                }\r\n            }\r\n            promises.resolve(this.parse.apply(this, [xml, self.description]));\r\n\r\n        }.bind(this));\r\n        return promises;\r\n    }\r\n    WMTSTerrainProvider.prototype.OGCHelper.generate = function (description) {\r\n\r\n        var resultat = {};\r\n        //basicAssignResult(description, resultat);\r\n        resultat.heightMapWidth = description.heightMapWidth;\r\n        resultat.heightMapHeight = description.heightMapHeight;\r\n        resultat.ready = false;\r\n        resultat.maximumLevel = description.maxLevel\r\n        resultat.levelZeroMaximumGeometricError = undefined;\r\n        resultat.offset = description.offset;\r\n        resultat.highest = description.highest;\r\n        resultat.lowest = description.lowest;\r\n        resultat.hasStyledImage = description.hasStyledImage || typeof (description.styleName) === \"string\";\r\n        resultat.type = \"WMTS\";\r\n        return resultat;\r\n    };\r\n\r\n\r\n    const imageToBuffer = function (image, limitations, size, hasStyledImage) {\r\n        const dataPixels = cesium.getImagePixels(image, size.width, size.height);\r\n\r\n        const buffer = new Float32Array(dataPixels.length / 4);\r\n\r\n        for (let i = 0; i < dataPixels.length; i += 4) {\r\n            const msb = dataPixels[i];\r\n            buffer[i / 4] = (msb / 255 * (limitations.highest - limitations.lowest) + limitations.offset);\r\n        }\r\n        return buffer;\r\n\r\n        //const buffer = new Int16Array(dataPixels.length / 4);\r\n        //let goodCell = 0,\r\n        //    somme = 0;\r\n        //for (let i = 0; i < dataPixels.length; i += 4) {\r\n        //    const msb = dataPixels[i];\r\n        //    const lsb = dataPixels[i + 1];\r\n        //    const isCorrect = dataPixels[i + 2] > 128;\r\n        //    const valeur = (msb << 8 | lsb) - limitations.offset - 32768;\r\n        //    if (valeur > limitations.lowest && valeur < limitations.highest && (isCorrect || hasStyledImage)) {\r\n        //        buffer[i / 4] = valeur;\r\n        //        somme += valeur;\r\n        //        goodCell++;\r\n        //    } else {\r\n        //        buffer[i / 4] = (goodCell === 0 ? 0 : somme / goodCell);\r\n        //        //buffer[i / 4] = 0;\r\n        //    }\r\n        //}\r\n        //return buffer;\r\n    }\r\n\r\n    function TerrainParser(promise) {\r\n        const self = this;\r\n        cesium.when(promise, function (resultat) {\r\n            if (cesium.defined(resultat) && (resultat.ready)) {\r\n                self._ready = true;\r\n                self._readyPromise.resolve(true);\r\n\r\n                resultat.getHeightmapTerrainData = function (x, y, level) {\r\n                    var retour;\r\n\r\n                    if (!isNaN(x + y + level)) {\r\n                        const urlGetTileOrCoverage = resultat.templateToURL(x, y, level);\r\n\r\n                        var hasChildren = 0;\r\n                        if (level < resultat.minLevel) {\r\n                            // no need to test for all child --> we are in the case of isTileInside\r\n                            hasChildren |= 1;\r\n                            hasChildren |= 2;\r\n                            hasChildren |= 4;\r\n                            hasChildren |= 8;\r\n                        }\r\n\r\n                        // If the requested tile is the same as the last then return it\r\n                        if (self.lastTile != undefined &&\r\n                            self.lastTile.x == x &&\r\n                            self.lastTile.y == y &&\r\n                            self.lastTile.level == level) {\r\n                            //console.log(\"get  Last Tile \",x, y, level);\r\n                            return self.lastTile.value;\r\n                        }\r\n\r\n                        // If the requested tile is in the TileCacheService then return it\r\n                        // Otherwise use WCS Get Coverage to request the tile                              \r\n                        retour = cesium.when(self.tileCacheService.getTileData(x, y, level), function (tileData) {\r\n\r\n                            var myHeightmapTerrainData = self.HeightmapTerrainData(tileData.data, {\r\n                                width: self.heightMapHeight,\r\n                                height: self.heightMapHeight\r\n                            }, hasChildren);\r\n\r\n                            self.lastTile = { 'x': x, 'y': y, 'level': level, 'value': myHeightmapTerrainData };\r\n\r\n                            return myHeightmapTerrainData;\r\n\r\n                        }).otherwise(function (evt) {\r\n                            const fetchDataImage = self.format === \"image/tiff\" ? cesium.Resource.fetchArrayBuffer : cesium.Resource.fetchImage\r\n                            //retour = cesium.when(fetchDataImage({ url: urlGetTileOrCoverage }), function (image) {\r\n                            return cesium.when(fetchDataImage({ url: urlGetTileOrCoverage }), function (image) {\r\n\r\n                                var myHeightmapBuffer = self.ImageToHeightmapTerrainData(self.noDataValue, image, {\r\n                                    width: self.heightMapHeight,\r\n                                    height: self.heightMapHeight\r\n                                }, x, y, level, self.tilingScheme);\r\n\r\n                                self.tileCacheService.addTile(x, y, level, myHeightmapBuffer);\r\n\r\n                                var myHeightmapTerrainData = self.HeightmapTerrainData(myHeightmapBuffer, {\r\n                                    width: self.heightMapHeight,\r\n                                    height: self.heightMapHeight\r\n                                }, hasChildren);\r\n\r\n                                self.lastTile = { 'x': x, 'y': y, 'level': level, 'value': myHeightmapTerrainData };\r\n\r\n                                return myHeightmapTerrainData;\r\n\r\n                            }).otherwise(function () {\r\n\r\n                                return self.DefaultProvider.requestTileGeometry(x, y, level);\r\n                            });\r\n                        });\r\n                    }\r\n                    return retour;\r\n                };\r\n\r\n                self.getLevelMaximumGeometricError = function (level) {\r\n                    return resultat.levelZeroMaximumGeometricError / (1 << level);\r\n                };\r\n\r\n                self.requestTileGeometry = function (x, y, level) {\r\n                    var retour;\r\n\r\n                    if (cesium.defined(resultat.getHeightmapTerrainData)) {\r\n\r\n                        if (!self.adviced && level > 14) {\r\n                            self.view.map.toast(TC.Util.getLocaleString(self.view.map.options.locale, \"threed.terrainAdvice\"), { type: TC.Consts.msgType.INFO });\r\n                            self.adviced = true;\r\n                        }\r\n\r\n                        if (level <= resultat.minLevel &&\r\n                            level >= resultat.maxLevel) {\r\n\r\n                            if (resultat.isTileInside(x, y, level) == true) {\r\n                                retour = resultat.getHeightmapTerrainData(x, y, level);\r\n                            } else {\r\n                                retour = cesium.when.defer().reject();\r\n                            }\r\n                        } else {\r\n                            retour = cesium.when.defer().reject();\r\n                        }\r\n                    } else {\r\n                        retour = cesium.when.defer().reject();\r\n                    }\r\n\r\n                    return retour;\r\n                }\r\n\r\n                Object.defineProperties(self, {\r\n                    tilingScheme: {\r\n                        get: function () {\r\n                            return resultat.tilingScheme;\r\n                        }\r\n                    },\r\n                    ready: {\r\n                        get: function () {\r\n                            return resultat.ready;\r\n                        }\r\n                    },\r\n                    pixelSize: {\r\n                        get: function () {\r\n                            return resultat.pixelSize;\r\n                        }\r\n                    },\r\n                    hasWaterMask: {\r\n                        get: function () {\r\n                            return resultat.waterMask;\r\n                        }\r\n                    },\r\n                    heightMapHeight: {\r\n\r\n                        get: function () {\r\n                            return resultat.heightMapHeight;\r\n                        }\r\n                    },\r\n                    heightMapWidth: {\r\n                        get: function () {\r\n                            return resultat.heightMapWidth;\r\n                        }\r\n                    },\r\n                    getTileDataAvailable: {\r\n                        get: function () {\r\n                            return resultat.getTileDataAvailable;\r\n                        }\r\n                    },\r\n                    minLevel: {\r\n                        get: function () {\r\n                            return resultat.minLevel;\r\n                        }\r\n                    },\r\n                    maxLevel: {\r\n                        get: function () {\r\n                            return resultat.maxLevel;\r\n                        }\r\n                    }\r\n\r\n                });\r\n\r\n                if (resultat.minLevel == undefined || resultat.maxLevel == undefined) {\r\n                    // Test pour savoir dans quelle tuile se trouve mon WCS\r\n                    var bbox = resultat.bbox;\r\n                    var pgeo = new cesium.Cartographic(\r\n                        cesium.Math.toRadians(bbox.coord[bbox.ulidx][0]),\r\n                        cesium.Math.toRadians(bbox.coord[bbox.ulidx][1]),\r\n                        0);\r\n                    resultat.minLevel = 30;\r\n                    resultat.maxLevel = 0;\r\n\r\n                    for (var j = 0; j < 30; j++) {\r\n                        // var tile = provider.tilingScheme.positionToTileXY(pgeo,j);\r\n                        //var rect = provider.tilingScheme.tileXYToNativeRectangle(tile.x, tile.y, j);\r\n                        var rect = self.tilingScheme.tileXYToNativeRectangle(0, 0, j);\r\n                        var xSpacing = (rect.east - rect.west) / (self.heightMapWidth - 1);\r\n                        var ySpacing = (rect.north - rect.south) / (self.heightMapHeight - 1);\r\n                        var scalingX = self.pixelSize[0] / xSpacing\r\n                        var scalingY = self.pixelSize[1] / ySpacing;\r\n\r\n                        if (scalingX < 10 && scalingX > 1 / 10 && Math.abs(scalingY) < 10 && Math.abs(scalingY) > 1 / 10) {\r\n                            if (j < resultat.minLevel) resultat.minLevel = j;\r\n                            if (j > resultat.maxLevel) resultat.maxLevel = j;\r\n\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                console.log(\"Error al obtener terreno fuera de Navarra\");\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    function doSampling(terrainProvider, level, positions) {\r\n        var tilingScheme = terrainProvider.tilingScheme;\r\n\r\n        var i;\r\n\r\n        // Sort points into a set of tiles\r\n        var tileRequests = []; // Result will be an Array as it's easier to work with\r\n        var tileRequestSet = {}; // A unique set\r\n        for (i = 0; i < positions.length; ++i) {\r\n            var xy = tilingScheme.positionToTileXY(positions[i], level);\r\n            var key = xy.toString();\r\n\r\n            if (!tileRequestSet.hasOwnProperty(key)) {\r\n                // When tile is requested for the first time\r\n                var value = {\r\n                    x: xy.x,\r\n                    y: xy.y,\r\n                    level: level,\r\n                    tilingScheme: tilingScheme,\r\n                    terrainProvider: terrainProvider,\r\n                    positions: []\r\n                };\r\n                tileRequestSet[key] = value;\r\n                tileRequests.push(value);\r\n            }\r\n\r\n            // Now append to array of points for the tile\r\n            tileRequestSet[key].positions.push(positions[i]);\r\n        }\r\n\r\n        // Send request for each required tile\r\n        var tilePromises = [];\r\n        for (i = 0; i < tileRequests.length; ++i) {\r\n            var tileRequest = tileRequests[i];\r\n            var requestPromise = tileRequest.terrainProvider.requestTileGeometry(tileRequest.x, tileRequest.y, tileRequest.level, false);\r\n            var tilePromise = cesium.when(requestPromise, createInterpolateFunction(tileRequest), createMarkFailedFunction(tileRequest));\r\n            tilePromises.push(tilePromise);\r\n        }\r\n\r\n        return cesium.when.all(tilePromises, function () {\r\n            return positions;\r\n        });\r\n    }\r\n\r\n    function createInterpolateFunction(tileRequest) {\r\n        var tilePositions = tileRequest.positions;\r\n        var rectangle = tileRequest.tilingScheme.tileXYToRectangle(tileRequest.x, tileRequest.y, tileRequest.level);\r\n        return function (terrainData) {\r\n            for (var i = 0; i < tilePositions.length; ++i) {\r\n                var position = tilePositions[i];\r\n                position.height = terrainData.interpolateHeight(rectangle, position.longitude, position.latitude);\r\n            }\r\n        };\r\n    }\r\n\r\n    function createMarkFailedFunction(tileRequest) {\r\n        var tilePositions = tileRequest.positions;\r\n        return function () {\r\n            for (var i = 0; i < tilePositions.length; ++i) {\r\n                var position = tilePositions[i];\r\n                position.height = undefined;\r\n            }\r\n        };\r\n    }\r\n    WCSTerrainProvider.prototype.sampleTerrainMostDetailed = function (positions) {\r\n        var self = this;\r\n\r\n        var deferred = cesium.when.defer();\r\n\r\n        function doSamplingWhenReady() {\r\n            if (self.ready) {/* provisional: el nivel se puede extraer ? */\r\n                cesium.when(doSampling(self, 16, positions), function (updatedPositions) {\r\n                    deferred.resolve(updatedPositions);\r\n                });\r\n            } else {\r\n                setTimeout(doSamplingWhenReady, 10);\r\n            }\r\n        }\r\n\r\n        doSamplingWhenReady();\r\n\r\n        return deferred;\r\n    }\r\n\r\n    WMTSTerrainProvider.prototype.sampleTerrainMostDetailed = function (positions) {\r\n        var self = this;\r\n\r\n        var deferred = cesium.when.defer();\r\n\r\n        function doSamplingWhenReady() {\r\n            if (self.ready) {/* provisional: el nivel se puede extraer ? */\r\n                cesium.when(doSampling(self, 16, positions), function (updatedPositions) {\r\n                    deferred.resolve(updatedPositions);\r\n                });\r\n            } else {\r\n                setTimeout(doSamplingWhenReady, 10);\r\n            }\r\n        }\r\n\r\n        doSamplingWhenReady();\r\n\r\n        return deferred;\r\n    }\r\n\r\n    cesium.WCSTerrainProvider = WCSTerrainProvider;\r\n    cesium.WMTSTerrainProvider = WMTSTerrainProvider;\r\n\r\n    function TileCacheService(objectStoreName) {\r\n        this.database = null;\r\n        this.objectStoreName = objectStoreName;\r\n    }\r\n\r\n    TileCacheService.prototype = {\r\n        /* createDB : create the scheme of the database  */\r\n        createDB: function () {\r\n\r\n            // In the following line, you should include the prefixes of implementations you want to test.\r\n            if (!window.indexedDB)\r\n                window.indexedDB = window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\r\n            // DON'T use \"var indexedDB = ...\" if you're not in a function.\r\n            // Moreover, you may need references to some window.IDB* objects:\r\n            if (!window.IDBTransaction)\r\n                window.IDBTransaction = window.webkitIDBTransaction || window.msIDBTransaction;\r\n            if (!window.IDBKeyRange)\r\n                window.IDBKeyRange = window.webkitIDBKeyRange || window.msIDBKeyRange;\r\n            if (!window.indexedDB) {\r\n                window.alert(\"Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.\");\r\n            }\r\n\r\n            var request = window.indexedDB.open('TileCacheService', 1);\r\n            var that = this;\r\n            request.onsuccess = function (evt) {\r\n                that.database = evt.target.result;\r\n            };\r\n            request.onerror = function (evt) {\r\n                console.log(\"IndexedDB--> onerror \");\r\n            };\r\n            request.onupgradeneeded = function (evt) {\r\n                var thisDB = evt.target.result;\r\n                if (!thisDB.objectStoreNames.contains('WCSTiles')) {\r\n                    var store = thisDB.createObjectStore('WCSTiles', { keyPath: 'id' });\r\n                    store.createIndex(\"tile\", [\"level\", \"row\", \"column\"], { unique: true });\r\n                }\r\n\r\n                if (!thisDB.objectStoreNames.contains('WMTSTiles')) {\r\n                    var store = thisDB.createObjectStore('WMTSTiles', { keyPath: 'id' });\r\n                    store.createIndex(\"tile\", [\"level\", \"row\", \"column\"], { unique: true });\r\n                }\r\n\r\n                if (!thisDB.objectStoreNames.contains('ImageTiles')) {\r\n                    var store = thisDB.createObjectStore('ImageTiles', { keyPath: 'id' });\r\n                    store.createIndex(\"tile\", [\"level\", \"row\", \"column\"], { unique: true });\r\n                }\r\n\r\n            };\r\n        },\r\n        /* info on available storage */\r\n        info: function () {\r\n            // Request storage usage and capacity left\r\n            window.webkitStorageInfo.queryUsageAndQuota(window.TEMPORARY, //the type can be either TEMPORARY or PERSISTENT\r\n                function (used, remaining) {\r\n                    console.log(\"Used quota: \" + used + \", remaining quota: \" + remaining);\r\n                }, function (e) {\r\n                    console.log('Error', e);\r\n                });\r\n        },\r\n        /* isReady when objectStore has been created  */\r\n        isReady: function () {\r\n            if (!this.database)\r\n                return false;\r\n\r\n            return this.database.objectStoreNames.contains(this.objectStoreName);\r\n        },\r\n        /* get the requested tile */\r\n        getTileData: function (column, row, level) {\r\n\r\n            var deferred = cesium.when.defer();\r\n\r\n            if (!this.database) {\r\n                console.log(\"getTileData no database\", this.database);\r\n                deferred.reject(\"no IndexedDB\");\r\n            }\r\n            else {\r\n\r\n                var transaction = this.database.transaction(this.objectStoreName);\r\n                var tileIndex = transaction.objectStore(this.objectStoreName).index(\"tile\");\r\n\r\n                var requestGet = tileIndex.get([level, row, column]);\r\n                requestGet.onsuccess = function (evt) {\r\n                    var tile = null;\r\n                    if (evt.target.result) {\r\n                        tile = { data: evt.target.result.tileData };\r\n                        deferred.resolve(tile);\r\n                    }\r\n                    else {\r\n                        deferred.reject(\"no tile\");\r\n                    }\r\n\r\n                }\r\n\r\n                requestGet.onerror = function (evt) {\r\n                    deferred.reject(\"no tile get failed\");\r\n                }\r\n            }\r\n\r\n            return deferred.promise;\r\n        },\r\n        addTile: function (x, y, level, data) {\r\n\r\n            if (this.database) {\r\n                var transaction = this.database.transaction(this.objectStoreName, \"readwrite\");\r\n                try {\r\n                    // the transaction could abort because of a QuotaExceededError error\r\n                    var guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 0x3 | 0x8; return v.toString(16); });\r\n                    transaction.objectStore(this.objectStoreName).add({ id: guid, level: level, row: y, column: x, tileData: data });\r\n                    //\tconsole.log(\"addTile \");\r\n                }\r\n                catch (ex) {\r\n                    console.log(ex);\r\n                }\r\n\r\n            }\r\n            else\r\n                console.log(\"addTile no database\");\r\n\r\n        }\r\n    };\r\n\r\n    function GeotiffParser() {\r\n        this.tiffDataView = undefined;\r\n        this.littleEndian = undefined;\r\n        this.imageWidth = undefined;\r\n        this.imageLength = undefined;\r\n        this.bitsPerPixel = undefined;\r\n        this.samplesPerPixel = undefined;\r\n        this.photometricInterpretation = undefined;\r\n        this.compression = undefined;\r\n        this.fileDirectories = [];\r\n        this.sampleProperties = [];\r\n        this.geoKeys = [];\r\n        this.blocks = [];\r\n        this.colorMapValues = [];\r\n        this.colorMapSampleSize = undefined;\r\n        this.isPixelArea = 0;\r\n        this.planarConfiguration = 1;\r\n        this.extraSamplesValues = [];\r\n        this.numExtraSamples = 0;\r\n\r\n    }\r\n\r\n    /* GeotiffParser */\r\n    GeotiffParser.prototype = {\r\n\r\n        /* isLittleEndian from Tiff-js  */\r\n        isLittleEndian: function () {\r\n            // Get byte order mark.\r\n            var BOM = this.getBytes(2, 0);\r\n\r\n            // Find out the endianness.\r\n            if (BOM === 0x4949) {\r\n                this.littleEndian = true;\r\n            } else if (BOM === 0x4D4D) {\r\n                this.littleEndian = false;\r\n            } else {\r\n                console.log(BOM);\r\n                throw TypeError(\"Invalid byte order value.\");\r\n            }\r\n\r\n            return this.littleEndian;\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        hasTowel: function () {\r\n            // Check for towel.\r\n            if (this.getBytes(2, 2) !== 42) {\r\n                throw RangeError(\"You forgot your towel!\");\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        /* Translate LinearCode to string  */\r\n        getLinearUnitsName: function (linearUnitsCode) {\r\n            var LinearUnitsName;\r\n            switch (linearUnitsCode) {\r\n                case 0:\r\n                    LinearUnitsName = 'undefined';\r\n                    break;\r\n                case 9001:\r\n                    LinearUnitsName = 'Linear_Meter';\r\n                    break;\r\n                case 9002:\r\n                    LinearUnitsName = 'Linear_Foot';\r\n                    break;\r\n                case 9003:\r\n                    LinearUnitsName = 'Linear_Foot_US_Survey';\r\n                    break;\r\n                case 9004:\r\n                    LinearUnitsName = 'Linear_Foot_Modified_American';\r\n                    break;\r\n                case 9005:\r\n                    LinearUnitsName = 'Linear_Foot_Clarke ';\r\n                    break;\r\n                case 9006:\r\n                    LinearUnitsName = 'Linear_Foot_Indian ';\r\n                    break;\r\n                case 9007:\r\n                    LinearUnitsName = 'Linear_Link ';\r\n                    break;\r\n                case 9008:\r\n                    LinearUnitsName = 'Linear_Link_Benoit ';\r\n                    break;\r\n                case 9009:\r\n                    LinearUnitsName = 'Linear_Link_Sears';\r\n                    break;\r\n                case 9010:\r\n                    LinearUnitsName = 'Linear_Chain_Benoit';\r\n                    break;\r\n                case 9011:\r\n                    LinearUnitsName = 'Linear_Chain_Sears';\r\n                    break;\r\n                case 9012:\r\n                    LinearUnitsName = 'Linear_Yard_Sears';\r\n                    break;\r\n                case 9013:\r\n                    LinearUnitsName = 'Linear_Yard_Indian';\r\n                    break;\r\n                case 9014:\r\n                    LinearUnitsName = 'Linear_Fathom';\r\n                    break;\r\n                case 9015:\r\n                    LinearUnitsName = 'user-Linear_Mile_International_Nautical';\r\n                    break;\r\n                default:\r\n                    if (linearUnitsCode >= 9000 && linearUnitsCode <= 9099) LinearUnitsName = 'EPSG Linear Units';\r\n                    else if (linearUnitsCode >= 9100 && linearUnitsCode <= 9199) LinearUnitsName = 'EPSG Angular Units';\r\n                    else if (linearUnitsCode = 32767) LinearUnitsName = 'user-defined unit';\r\n                    else if (linearUnitsCode > 32767) LinearUnitsName = 'Private User Implementations';\r\n                    break;\r\n            }\r\n            return LinearUnitsName;\r\n        },\r\n\r\n        /* Translate LinearCode to string  */\r\n        getAngularUnitsName: function (angularUnitsCode) {\r\n            var AngularUnitsName;\r\n            switch (angularUnitsCode) {\r\n                case 0:\r\n                    AngularUnitsName = 'undefined';\r\n                    break;\r\n                case 9001:\r\n                    AngularUnitsName = 'Angular_Radian';\r\n                    break;\r\n                case 9002:\r\n                    AngularUnitsName = 'Angular_Degree';\r\n                    break;\r\n                case 9003:\r\n                    AngularUnitsName = 'Angular_Arc_Minute';\r\n                    break;\r\n                case 9004:\r\n                    AngularUnitsName = 'Angular_Arc_Second';\r\n                    break;\r\n                case 9005:\r\n                    AngularUnitsName = 'Angular_Grad';\r\n                    break;\r\n                case 9006:\r\n                    AngularUnitsName = 'Angular_Gon';\r\n                    break;\r\n                case 9007:\r\n                    AngularUnitsName = 'Angular_DMS';\r\n                    break;\r\n                case 9008:\r\n                    AngularUnitsName = 'Angular_DMS_Hemisphere';\r\n                    break;\r\n                default:\r\n                    if (angularUnitsCode >= 9000 && angularUnitsCode <= 9099) AngularUnitsName = 'EPSG Linear Units';\r\n                    else if (angularUnitsCode >= 9100 && angularUnitsCode <= 9199) AngularUnitsName = 'EPSG Angular Units';\r\n                    else if (angularUnitsCode = 32767) AngularUnitsName = 'user-defined unit';\r\n                    else if (angularUnitsCode > 32767) AngularUnitsName = 'Private User Implementations';\r\n                    break;\r\n            }\r\n            return AngularUnitsName;\r\n        },\r\n\r\n        /* Translate modelTypeCode to string  */\r\n        getModelTypeName: function (modelTypeCode) {\r\n            var modelTypeName;\r\n            switch (modelTypeCode) {\r\n                case 0:\r\n                    modelTypeName = 'undefined';\r\n                    break;\r\n                case 1:\r\n                    modelTypeName = 'ModelTypeProjected';\r\n                    break;\r\n                case 2:\r\n                    modelTypeName = 'ModelTypeGeographic';\r\n                    break;\r\n                case 3:\r\n                    modelTypeName = 'ModelTypeGeocentric';\r\n                    break;\r\n                case 32767:\r\n                    modelTypeName = 'user-defined';\r\n                    break;\r\n                default:\r\n                    if (modelTypeCode < 32767) modelTypeName = 'GeoTIFF Reserved Codes';\r\n                    else if (modelTypeCode > 32767) modelTypeName = 'Private User Implementations';\r\n                    break;\r\n            }\r\n            return modelTypeName;\r\n        },\r\n\r\n        /* Translate rasterTypeCode to string  */\r\n        getRasterTypeName: function (rasterTypeCode) {\r\n            var rasterTypeName;\r\n            switch (rasterTypeCode) {\r\n                case 0:\r\n                    rasterTypeName = 'undefined';\r\n                    break;\r\n                case 1:\r\n                    rasterTypeName = 'RasterPixelIsArea';\r\n                    break;\r\n                case 2:\r\n                    rasterTypeName = 'RasterPixelIsPoint';\r\n                    break;\r\n                case 32767:\r\n                    rasterTypeName = 'user-defined';\r\n                    break;\r\n                default:\r\n                    if (rasterTypeCode < 32767) rasterTypeName = 'GeoTIFF Reserved Codes';\r\n                    else if (rasterTypeCode > 32767) rasterTypeName = 'Private User Implementations';\r\n                    break;\r\n            }\r\n            return rasterTypeName;\r\n        },\r\n\r\n        /* Translate GeoKey to string  */\r\n        getGeoKeyName: function (geoKey) {\r\n            var geoKeyTagNames = {\r\n                1024: 'GTModelTypeGeoKey',\r\n                1025: 'GTRasterTypeGeoKey',\r\n                1026: 'GTCitationGeoKey',\r\n                2048: 'GeographicTypeGeoKey',\r\n                2049: 'GeogCitationGeoKey',\r\n                2050: 'GeogGeodeticDatumGeoKey',\r\n                2051: 'GeogPrimeMeridianGeoKey',\r\n                2052: 'GeogLinearUnitsGeoKey',\r\n                2053: 'GeogLinearUnitSizeGeoKey',\r\n                2054: 'GeogAngularUnitsGeoKey',\r\n                2055: 'GeogAngularUnitSizeGeoKey',\r\n                2056: 'GeogEllipsoidGeoKey',\r\n                2057: 'GeogSemiMajorAxisGeoKey',\r\n                2058: 'GeogSemiMinorAxisGeoKey',\r\n                2059: 'GeogInvFlatteningGeoKey',\r\n                2060: 'GeogAzimuthUnitsGeoKey',\r\n                2061: 'GeogPrimeMeridianLongGeoKey',\r\n                2062: 'GeogTOWGS84GeoKey',\r\n                3072: 'ProjectedCSTypeGeoKey',\r\n                3073: 'PCSCitationGeoKey',\r\n                3074: 'ProjectionGeoKey',\r\n                3075: 'ProjCoordTransGeoKey',\r\n                3076: 'ProjLinearUnitsGeoKey',\r\n                3077: 'ProjLinearUnitSizeGeoKey',\r\n                3078: 'ProjStdParallel1GeoKey',\r\n                3079: 'ProjStdParallel2GeoKey',\r\n                3080: 'ProjNatOriginLongGeoKey',\r\n                3081: 'ProjNatOriginLatGeoKey',\r\n                3082: 'ProjFalseEastingGeoKey',\r\n                3083: 'ProjFalseNorthingGeoKey',\r\n                3084: 'ProjFalseOriginLongGeoKey',\r\n                3085: 'ProjFalseOriginLatGeoKey',\r\n                3086: 'ProjFalseOriginEastingGeoKey',\r\n                3087: 'ProjFalseOriginNorthingGeoKey',\r\n                3088: 'ProjCenterLongGeoKey',\r\n                3089: 'ProjCenterLatGeoKey',\r\n                3090: 'ProjCenterEastingGeoKey',\r\n                3091: 'ProjCenterNorthingGeoKey',\r\n                3092: 'ProjScaleAtNatOriginGeoKey',\r\n                3093: 'ProjScaleAtCenterGeoKey',\r\n                3094: 'ProjAzimuthAngleGeoKey',\r\n                3095: 'ProjStraightVertPoleLongGeoKey',\r\n                3096: 'ProjRectifiedGridAngleGeoKey',\r\n                4096: 'VerticalCSTypeGeoKey',\r\n                4097: 'VerticalCitationGeoKey',\r\n                4098: 'VerticalDatumGeoKey',\r\n                4099: 'VerticalUnitsGeoKey'\r\n            };\r\n            var geoKeyName;\r\n\r\n            if (geoKey in geoKeyTagNames) {\r\n                geoKeyName = geoKeyTagNames[geoKey];\r\n            } else {\r\n                console.log(\"Unknown geoKey :\", geoKey);\r\n                geoKeyName = geoKey + \"GeoKey\";\r\n            }\r\n            return geoKeyName;\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        getFieldTagName: function (fieldTag) {\r\n            // See: http://www.digitizationguidelines.gov/guidelines/TIFF_Metadata_Final.pdf\r\n            // See: http://www.digitalpreservation.gov/formats/content/tiff_tags.shtml\r\n            var fieldTagNames = {\r\n                // TIFF Baseline\r\n                0x013B: 'Artist',\r\n                0x0102: 'BitsPerSample',\r\n                0x0109: 'CellLength',\r\n                0x0108: 'CellWidth',\r\n                0x0140: 'ColorMap',\r\n                0x0103: 'Compression',\r\n                0x8298: 'Copyright',\r\n                0x0132: 'DateTime',\r\n                0x0152: 'ExtraSamples',\r\n                0x010A: 'FillOrder',\r\n                0x0121: 'FreeByteCounts',\r\n                0x0120: 'FreeOffsets',\r\n                0x0123: 'GrayResponseCurve',\r\n                0x0122: 'GrayResponseUnit',\r\n                0x013C: 'HostComputer',\r\n                0x010E: 'ImageDescription',\r\n                0x0101: 'ImageLength',\r\n                0x0100: 'ImageWidth',\r\n                0x010F: 'Make',\r\n                0x0119: 'MaxSampleValue',\r\n                0x0118: 'MinSampleValue',\r\n                0x0110: 'Model',\r\n                0x00FE: 'NewSubfileType',\r\n                0x0112: 'Orientation',\r\n                0x0106: 'PhotometricInterpretation',\r\n                0x011C: 'PlanarConfiguration',\r\n                0x0128: 'ResolutionUnit',\r\n                0x0116: 'RowsPerStrip',\r\n                0x0115: 'SamplesPerPixel',\r\n                0x0131: 'Software',\r\n                0x0117: 'StripByteCounts',\r\n                0x0111: 'StripOffsets',\r\n                0x00FF: 'SubfileType',\r\n                0x0107: 'Threshholding',\r\n                0x011A: 'XResolution',\r\n                0x011B: 'YResolution',\r\n\r\n                // TIFF Extended\r\n                0x0146: 'BadFaxLines',\r\n                0x0147: 'CleanFaxData',\r\n                0x0157: 'ClipPath',\r\n                0x0148: 'ConsecutiveBadFaxLines',\r\n                0x01B1: 'Decode',\r\n                0x01B2: 'DefaultImageColor',\r\n                0x010D: 'DocumentName',\r\n                0x0150: 'DotRange',\r\n                0x0141: 'HalftoneHints',\r\n                0x015A: 'Indexed',\r\n                0x015B: 'JPEGTables',\r\n                0x011D: 'PageName',\r\n                0x0129: 'PageNumber',\r\n                0x013D: 'Predictor',\r\n                0x013F: 'PrimaryChromaticities',\r\n                0x0214: 'ReferenceBlackWhite',\r\n                0x0153: 'SampleFormat',\r\n                0x0154: 'SMinSampleValue',\r\n                0x0155: 'SMaxSampleValue',\r\n                0x022F: 'StripRowCounts',\r\n                0x014A: 'SubIFDs',\r\n                0x0124: 'T4Options',\r\n                0x0125: 'T6Options',\r\n                0x0145: 'TileByteCounts',\r\n                0x0143: 'TileLength',\r\n                0x0144: 'TileOffsets',\r\n                0x0142: 'TileWidth',\r\n                0x012D: 'TransferFunction',\r\n                0x013E: 'WhitePoint',\r\n                0x0158: 'XClipPathUnits',\r\n                0x011E: 'XPosition',\r\n                0x0211: 'YCbCrCoefficients',\r\n                0x0213: 'YCbCrPositioning',\r\n                0x0212: 'YCbCrSubSampling',\r\n                0x0159: 'YClipPathUnits',\r\n                0x011F: 'YPosition',\r\n\r\n                // EXIF\r\n                0x9202: 'ApertureValue',\r\n                0xA001: 'ColorSpace',\r\n                0x9004: 'DateTimeDigitized',\r\n                0x9003: 'DateTimeOriginal',\r\n                0x8769: 'Exif IFD',\r\n                0x9000: 'ExifVersion',\r\n                0x829A: 'ExposureTime',\r\n                0xA300: 'FileSource',\r\n                0x9209: 'Flash',\r\n                0xA000: 'FlashpixVersion',\r\n                0x829D: 'FNumber',\r\n                0xA420: 'ImageUniqueID',\r\n                0x9208: 'LightSource',\r\n                0x927C: 'MakerNote',\r\n                0x9201: 'ShutterSpeedValue',\r\n                0x9286: 'UserComment',\r\n\r\n                // IPTC\r\n                0x83BB: 'IPTC',\r\n\r\n                // ICC\r\n                0x8773: 'ICC Profile',\r\n\r\n                // XMP\r\n                0x02BC: 'XMP',\r\n\r\n                // GDAL\r\n                0xA480: 'GDAL_METADATA',\r\n                0xA481: 'GDAL_NODATA',\r\n\r\n                // Photoshop\r\n                0x8649: 'Photoshop',\r\n\r\n                // GeoTiff\r\n                0x830E: 'ModelPixelScale',\r\n                0x8482: 'ModelTiepoint',\r\n                0x85D8: 'ModelTransformation',\r\n                0x87AF: 'GeoKeyDirectory',\r\n                0x87B0: 'GeoDoubleParams',\r\n                0x87B1: 'GeoAsciiParams'\r\n\r\n            };\r\n\r\n            var fieldTagName;\r\n\r\n            if (fieldTag in fieldTagNames) {\r\n                fieldTagName = fieldTagNames[fieldTag];\r\n            } else {\r\n                console.log(\"Unknown Field Tag:\", fieldTag);\r\n                fieldTagName = \"Tag\" + fieldTag;\r\n            }\r\n            return fieldTagName;\r\n        },\r\n\r\n        /* Translate the photometric code to a name  */\r\n        getPhotometricName: function (key) {\r\n            var photometricNames = {\r\n                0: 'PHOTOMETRIC_MINISWHITE',\r\n                1: 'PHOTOMETRIC_MINISBLACK',\r\n                2: 'PHOTOMETRIC_RGB',\r\n                3: 'PHOTOMETRIC_PALETTE',\r\n                4: 'PHOTOMETRIC_MASK',\r\n                5: 'PHOTOMETRIC_SEPARATED',\r\n                6: 'PHOTOMETRIC_YCBCR',\r\n                8: 'PHOTOMETRIC_CIELAB',\r\n                9: 'PHOTOMETRIC_ICCLAB',\r\n                10: 'PHOTOMETRIC_ITULAB',\r\n                32844: 'PHOTOMETRIC_LOGL',\r\n                32845: 'PHOTOMETRIC_LOGLUV'\r\n            };\r\n            var photometricName;\r\n\r\n            if (key in photometricNames) {\r\n                photometricName = photometricNames[key];\r\n            } else {\r\n                photometricName = \"UNKNOWN\";\r\n            }\r\n            return photometricName;\r\n        },\r\n\r\n        /* Translate GeoKey to string  */\r\n        getCompressionTypeName: function (key) {\r\n            var compressionNames = {\r\n\r\n                1: 'COMPRESSION_NONE',\r\n                2: 'COMPRESSION_CCITTRLE',\r\n                3: 'COMPRESSION_CCITTFAX3',\r\n                4: 'COMPRESSION_CCITTFAX4',\r\n                5: 'COMPRESSION_LZW',\r\n                6: 'COMPRESSION_OJPEG',\r\n                7: 'COMPRESSION_JPEG',\r\n                32766: 'COMPRESSION_NEXT',\r\n                32771: 'COMPRESSION_CCITTRLEW',\r\n                32773: 'COMPRESSION_PACKBITS',\r\n                32809: 'COMPRESSION_THUNDERSCAN',\r\n                32895: 'COMPRESSION_IT8CTPAD',\r\n                32896: 'COMPRESSION_IT8LW',\r\n                32897: 'COMPRESSION_IT8MP',\r\n                32898: 'COMPRESSION_IT8BL',\r\n                32908: 'COMPRESSION_PIXARFILM',\r\n                32909: 'COMPRESSION_PIXARLOG',\r\n                32946: 'COMPRESSION_DEFLATE',\r\n                8: 'COMPRESSION_ADOBE_DEFLATE',\r\n                32947: 'COMPRESSION_DCS',\r\n                34661: 'COMPRESSION_JBIG',\r\n                34676: 'COMPRESSION_SGILOG',\r\n                34677: 'COMPRESSION_SGILOG24',\r\n                34712: 'COMPRESSION_JP2000'\r\n            };\r\n            var compressionName;\r\n\r\n            if (key in compressionNames) {\r\n                compressionName = compressionNames[key];\r\n            } else {\r\n                compressionName = \"UNKNOWN\";\r\n            }\r\n            return compressionName;\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        getFieldTypeName: function (fieldType) {\r\n            var fieldTypeNames = {\r\n                0x0001: 'BYTE',\r\n                0x0002: 'ASCII',\r\n                0x0003: 'SHORT',\r\n                0x0004: 'LONG',\r\n                0x0005: 'RATIONAL',\r\n                0x0006: 'SBYTE',\r\n                0x0007: 'UNDEFINED',\r\n                0x0008: 'SSHORT',\r\n                0x0009: 'SLONG',\r\n                0x000A: 'SRATIONAL',\r\n                0x000B: 'FLOAT',\r\n                0x000C: 'DOUBLE'\r\n            };\r\n\r\n            var fieldTypeName;\r\n\r\n            if (fieldType in fieldTypeNames) {\r\n                fieldTypeName = fieldTypeNames[fieldType];\r\n            }\r\n            return fieldTypeName;\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        getFieldTypeLength: function (fieldTypeName) {\r\n            var fieldTypeLength;\r\n\r\n            if (['BYTE', 'ASCII', 'SBYTE', 'UNDEFINED'].indexOf(fieldTypeName) !== -1) {\r\n                fieldTypeLength = 1;\r\n            } else if (['SHORT', 'SSHORT'].indexOf(fieldTypeName) !== -1) {\r\n                fieldTypeLength = 2;\r\n            } else if (['LONG', 'SLONG', 'FLOAT'].indexOf(fieldTypeName) !== -1) {\r\n                fieldTypeLength = 4;\r\n            } else if (['RATIONAL', 'SRATIONAL', 'DOUBLE'].indexOf(fieldTypeName) !== -1) {\r\n                fieldTypeLength = 8;\r\n            }\r\n\r\n            return fieldTypeLength;\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        getBits: function (numBits, byteOffset, bitOffset) {\r\n            bitOffset = bitOffset || 0;\r\n            var extraBytes = Math.floor(bitOffset / 8);\r\n            var newByteOffset = byteOffset + extraBytes;\r\n            var totalBits = bitOffset + numBits;\r\n            var shiftRight = 32 - numBits;\r\n\r\n            let rawBits;\r\n            let shiftLeft;\r\n            if (totalBits <= 0) {\r\n                console.log(numBits, byteOffset, bitOffset);\r\n                throw RangeError(\"No bits requested\");\r\n            } else if (totalBits <= 8) {\r\n                shiftLeft = 24 + bitOffset;\r\n                rawBits = this.tiffDataView.getUint8(newByteOffset, this.littleEndian);\r\n            } else if (totalBits <= 16) {\r\n                shiftLeft = 16 + bitOffset;\r\n                rawBits = this.tiffDataView.getUint16(newByteOffset, this.littleEndian);\r\n            } else if (totalBits <= 32) {\r\n                shiftLeft = bitOffset;\r\n                rawBits = this.tiffDataView.getUint32(newByteOffset, this.littleEndian);\r\n            } else {\r\n                console.log(numBits, byteOffset, bitOffset);\r\n                throw RangeError(\"Too many bits requested\");\r\n            }\r\n\r\n            var chunkInfo = {\r\n                'bits': ((rawBits << shiftLeft) >>> shiftRight),\r\n                'byteOffset': newByteOffset + Math.floor(totalBits / 8),\r\n                'bitOffset': totalBits % 8\r\n            };\r\n            return chunkInfo;\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        getBytes: function (numBytes, offset) {\r\n            if (numBytes <= 0) {\r\n                console.log(numBytes, offset);\r\n                throw RangeError(\"No bytes requested\");\r\n            } else if (numBytes <= 1) {\r\n                return this.tiffDataView.getUint8(offset, this.littleEndian);\r\n            } else if (numBytes <= 2) {\r\n                return this.tiffDataView.getUint16(offset, this.littleEndian);\r\n            } else if (numBytes <= 3) {\r\n                return this.tiffDataView.getUint32(offset, this.littleEndian) >>> 8;\r\n            } else if (numBytes <= 4) {\r\n                return this.tiffDataView.getUint32(offset, this.littleEndian);\r\n            } else if (numBytes <= 8) {\r\n                return this.tiffDataView.getFloat64(offset, this.littleEndian);\r\n            } else {\r\n                throw RangeError(\"Too many bytes requested\");\r\n            }\r\n        },\r\n\r\n        /* getSampleBytes : use Sampleformat  */\r\n        getSampleBytes: function (sampleFormat, numBytes, offset) {\r\n\r\n            // Decompress strip.\r\n            switch (sampleFormat) {\r\n                // Uncompressed\r\n                case 1:\r\n                case 2: // twos complement signed integer data\r\n                    return this.getBytes(numBytes, offset);\r\n                case 3: // floating point data\r\n                    {\r\n                        if (numBytes == 3) {\r\n                            return this.tiffDataView.getFloat32(offset, this.littleEndian) >>> 8;\r\n                        } else if (numBytes == 4) {\r\n                            return this.tiffDataView.getFloat32(offset, this.littleEndian);\r\n                        }\r\n                        // No break : if numBytes != 3 && 4 --> throw error\r\n                    }\r\n                case 5: // Complex Int\r\n                case 6: // Complex IEEE floating point \r\n                case 4: // void or undefined  \r\n                default:\r\n                    throw Error(\"Do not attempt to parse the data  not handled  : \" + sampleFormat);\r\n                    break;\r\n            }\r\n\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        getFieldValues: function (fieldTagName, fieldTypeName, typeCount, valueOffset) {\r\n            var fieldValues = [];\r\n            var fieldTypeLength = this.getFieldTypeLength(fieldTypeName);\r\n            var fieldValueSize = fieldTypeLength * typeCount;\r\n\r\n            if (fieldValueSize <= 4) {\r\n                // The value is stored at the big end of the valueOffset.\r\n                let value;\r\n                if (this.littleEndian === false) {\r\n                    value = valueOffset >>> ((4 - fieldTypeLength) * 8);\r\n                } else {\r\n                    value = valueOffset;\r\n                }\r\n\r\n                fieldValues.push(value);\r\n            } else {\r\n                for (var i = 0; i < typeCount; i++) {\r\n                    var indexOffset = fieldTypeLength * i;\r\n\r\n                    if (fieldTypeLength >= 8) {\r\n                        if (['RATIONAL', 'SRATIONAL'].indexOf(fieldTypeName) !== -1) {\r\n                            // Numerator\r\n                            fieldValues.push(this.getBytes(4, valueOffset + indexOffset));\r\n                            // Denominator\r\n                            fieldValues.push(this.getBytes(4, valueOffset + indexOffset + 4));\r\n                        } else if (['DOUBLE'].indexOf(fieldTypeName) !== -1) {\r\n                            fieldValues.push(this.getBytes(8, valueOffset + indexOffset));\r\n                            //console.log(this.getBytes(8, valueOffset + indexOffset) );\r\n                        } else {\r\n                            console.log(\" fff\" + fieldTypeName, typeCount, fieldValueSize);\r\n                            //throw TypeError(\"Can't handle this field type or size\");\r\n                        }\r\n                    } else {\r\n                        fieldValues.push(this.getBytes(fieldTypeLength, valueOffset + indexOffset));\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (fieldTypeName === 'ASCII') {\r\n                fieldValues.forEach(function (e, i, a) {\r\n                    a[i] = String.fromCharCode(e);\r\n                });\r\n            }\r\n            return fieldValues;\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        clampColorSample: function (colorSample, bitsPerSample) {\r\n            var multiplier = Math.pow(2, 8 - bitsPerSample);\r\n            return Math.floor((colorSample * multiplier) + (1 - multiplier));\r\n        },\r\n\r\n        clampAffineColorSample: function (colorSample, bitsPerSample, vmin, vmax) {\r\n            var multiplier = Math.pow(2, 8) / vmax;\r\n            return Math.floor((colorSample - vmin) * multiplier);\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        makeRGBAFillValue: function (r, g, b, a) {\r\n            if (typeof a === 'undefined') {\r\n                a = 1.0;\r\n            }\r\n            return \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        parseFileDirectory: function (byteOffset) {\r\n            var numDirEntries = this.getBytes(2, byteOffset);\r\n            var tiffFields = [];\r\n\r\n            for (var i = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, entryCount++) {\r\n                var fieldTag = this.getBytes(2, i);\r\n                var fieldType = this.getBytes(2, i + 2);\r\n                var typeCount = this.getBytes(4, i + 4);\r\n                var valueOffset = this.getBytes(4, i + 8);\r\n\r\n                var fieldTagName = this.getFieldTagName(fieldTag);\r\n                var fieldTypeName = this.getFieldTypeName(fieldType);\r\n                var fieldValues = this.getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);\r\n\r\n                tiffFields[fieldTagName] = { 'type': fieldTypeName, 'values': fieldValues };\r\n            }\r\n\r\n            this.fileDirectories.push(tiffFields);\r\n\r\n            var nextIFDByteOffset = this.getBytes(4, i);\r\n\r\n            if (nextIFDByteOffset === 0x00000000) {\r\n                return this.fileDirectories;\r\n            }\r\n            else {\r\n                return this.parseFileDirectory(nextIFDByteOffset);\r\n            }\r\n        },\r\n\r\n        /* check if the Tif is a GeoTiff  */\r\n        isGeotiff: function () {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (typeof (fileDirectory.GeoKeyDirectory) == 'undefined' || fileDirectory.GeoKeyDirectory == null ||\r\n                typeof (fileDirectory.GeoKeyDirectory.values) == 'undefined' || fileDirectory.GeoKeyDirectory.values == null)\r\n                return false;\r\n            var geoKeysDir = fileDirectory.GeoKeyDirectory.values;\r\n            if (geoKeysDir.length < 4)\r\n                return false;\r\n            return true;\r\n        },\r\n\r\n\r\n        /* check  getPlanarConfiguration */\r\n        getPlanarConfiguration: function () {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (fileDirectory.hasOwnProperty('PlanarConfiguration') == false ||\r\n                fileDirectory.PlanarConfiguration.hasOwnProperty('values') == false ||\r\n                fileDirectory.PlanarConfiguration.values == null)\r\n                return 1;\r\n\r\n            return fileDirectory.PlanarConfiguration.values[0];\r\n        },\r\n\r\n\r\n        /* return the type  of the pixel or -1 */\r\n        getSampleFormat: function () {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (fileDirectory.hasOwnProperty('SampleFormat') == false ||\r\n                fileDirectory.SampleFormat.hasOwnProperty('values') == false ||\r\n                fileDirectory.SampleFormat.values == null)\r\n                return 1;\r\n\r\n            return fileDirectory.SampleFormat.values[0];\r\n        },\r\n\r\n        /* return min and max values if resent or -1 */\r\n        getSampleMinMax: function () {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (fileDirectory.hasOwnProperty('SMaxSampleValue') == false ||\r\n                fileDirectory.SMaxSampleValue.hasOwnProperty('values') == false ||\r\n                fileDirectory.SMaxSampleValue.values == null)\r\n                return -1;\r\n\r\n            if (fileDirectory.hasOwnProperty('SMinSampleValue') == false ||\r\n                fileDirectory.SMinSampleValue.hasOwnProperty('values') == false ||\r\n                fileDirectory.SMinSampleValue.values == null)\r\n                return -1;\r\n\r\n            return [fileDirectory.SMinSampleValue.values, fileDirectory.SMaxSampleValue.values];\r\n\r\n        },\r\n\r\n        /* isBlockLoaded : this function check if the block with blockOffset value has been loaded  */\r\n        isBlockLoaded: function (blockOffset) {\r\n            var blocks = this.blocks;\r\n            for (var i = 0; i < blocks.length; i++)\r\n                if (this.blocks[i] != null && this.blocks[i].offset == blockOffset)\r\n                    return i;\r\n            return -1;\r\n        },\r\n\r\n        /* getBlock : this function get the block with blockOffset value has been loaded  */\r\n        getBlock: function (blockOffset) {\r\n            var blocks = this.blocks;\r\n            for (var i = 0; i < blocks.length; i++)\r\n                if (this.blocks[i] != null && this.blocks[i].offset == blockOffset)\r\n                    return this.blocks[i];\r\n            return null;\r\n        },\r\n\r\n        /* add the new block to the list of the block \r\n         * ToDo : limit the number of block loaded in order to control the memory isage\r\n         * remove older block \r\n         */\r\n        addBlock: function (stripToLoad, block) {\r\n            this.blocks[stripToLoad] = block\r\n        },\r\n\r\n        /* check if StripOffset is set */\r\n        hasStripOffset: function () {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (typeof (fileDirectory.StripOffsets) == 'undefined' || fileDirectory.StripOffsets == null ||\r\n                typeof (fileDirectory.StripOffsets.values) == 'undefined' || fileDirectory.StripOffsets.values == null)\r\n                return false;\r\n            return true;\r\n        },\r\n\r\n        /* check if TileOffsets is set */\r\n        hasTileOffset: function () {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (fileDirectory.hasOwnProperty('TileOffsets') == false ||\r\n                fileDirectory.TileOffsets.hasOwnProperty('values') == false || fileDirectory.TileOffsets.values == null)\r\n                return false;\r\n            return true;\r\n        },\r\n\r\n        /*  parse de GeoKeyDirectory and fill geoKeys */\r\n        parseGeoKeyDirectory: function () {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (this.isGeotiff() == false)\r\n                return;\r\n\r\n            var hdr_num_keys = fileDirectory.GeoKeyDirectory.values[3];\r\n\r\n            var geoKeyFields = [];\r\n            for (var iKey = 0; iKey < hdr_num_keys; iKey++) {\r\n                /* GeoKey ID            */\r\n                var ent_key = fileDirectory.GeoKeyDirectory.values[4 + iKey * 4];\r\n                /* TIFF Tag ID or 0     */\r\n                var ent_location = fileDirectory.GeoKeyDirectory.values[5 + iKey * 4];\r\n                /* GeoKey value count   */\r\n                var ent_count = fileDirectory.GeoKeyDirectory.values[6 + iKey * 4];\r\n                /* value or tag offset  */\r\n                var ent_val_offset = fileDirectory.GeoKeyDirectory.values[7 + iKey * 4];\r\n\r\n                var value = 'undefined';\r\n                if (ent_location == 0) {\r\n                    /* store value into data value */\r\n                    value = ent_val_offset;\r\n                    //console.log(\"ent_val_offset =\" + value );\t\r\n                }\r\n                else if (this.getFieldTagName(ent_location) == \"GeoKeyDirectory\") {\r\n                    console.log(\"ent_key =\" + this.getGeoKeyName(ent_key));\r\n                    console.log(\"ent_count =\" + ent_count);\r\n                    console.log(\"ent_val_offset =\" + ent_val_offset);\r\n                    console.log(\"GeoKeyDirectory =\");\r\n\r\n                }\r\n                else if (this.getFieldTagName(ent_location) == \"GeoDoubleParams\") {\r\n                    /*\r\n                        console.log(\"ent_key =\" + this.getGeoKeyName(ent_key));\r\n                        console.log(\"ent_count =\" + ent_count );\t\t\r\n                        console.log(\"ent_val_offset =\" + ent_val_offset );\r\n                        console.log(\"GeoDoubleParams =\"  +GeoDoubleParams[ent_val_offset]);\r\n                        */\r\n                    var GeoDoubleParams = fileDirectory.GeoDoubleParams.values;\r\n                    value = GeoDoubleParams[ent_val_offset];\r\n\r\n                }\r\n                else if (this.getFieldTagName(ent_location) == \"GeoAsciiParams\") {\r\n                    var str = \"\";\r\n                    /*console.log(\"ent_key =\" + this.getGeoKeyName(ent_key));\r\n                    console.log(\"ent_count =\" + ent_count );\r\n                    console.log(\"ent_val_offset =\" + ent_val_offset );*/\r\n                    var GeoAsciiParams = fileDirectory.GeoAsciiParams.values;\r\n                    if (ent_val_offset != 'undefined' &&\r\n                        ent_count != 'undefined' &&\r\n                        ent_count > 0 &&\r\n                        ent_val_offset <= ent_count - 1) {\r\n                        for (var j = ent_val_offset; j < ent_count - 1; j++)\r\n                            str += GeoAsciiParams[j];\r\n                        if (GeoAsciiParams[ent_count - 1] != '|')\r\n                            str += GeoAsciiParams[ent_count - 1];\r\n\r\n                    }\r\n                    value = str;\r\n                }\r\n                geoKeyFields[this.getGeoKeyName(ent_key)] = { 'value': value };\r\n            }\r\n            this.geoKeys = geoKeyFields;\r\n\r\n            if (this.geoKeys.hasOwnProperty('GTRasterTypeGeoKey') == false)\r\n                this.isPixelArea = 0;\r\n            if (this.getRasterTypeName(this.geoKeys.GTRasterTypeGeoKey.value) == 'RasterPixelIsArea')\r\n                this.isPixelArea = 1;\r\n\r\n        },\r\n\r\n        /* Test */\r\n        consoleTiffProperty: function () {\r\n            console.log(\"--------------- Tiff property -------------------\");\r\n            // Show Image parameter\r\n            console.log(\"Image : w=\" + this.imageWidth + \" h=\" + this.imageLength);\r\n\r\n            // DataType  UChar8 or Int16\r\n            console.log(\"BitsPerPixel=\" + this.bitsPerPixel);\r\n\r\n            // Band count : 1 or 3 bands RGB\r\n            console.log(\"SamplesPerPixel=\" + this.samplesPerPixel);\r\n            console.log(\"PlanarConfiruration=\" + this.planarConfiguration);\r\n            console.log(\"Photometric =\" + this.getPhotometricName(this.photometricInterpretation));\r\n            console.log(\"Compression =\" + this.getCompressionTypeName(this.compression));\r\n            console.log(\"SampleFormat : \", this.getSampleFormat());\r\n            console.log(\"getSampleMinMax : \", this.getSampleMinMax());\r\n\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (this.hasStripOffset()) {\r\n                var numoffsetValues = fileDirectory.StripOffsets.values.length;\r\n                console.log(\"Has Strips nb offsetvalues count:\" + numoffsetValues);\r\n            }\r\n\r\n            if (this.hasTileOffset()) {\r\n                var numoffsetValues = fileDirectory.TileOffsets.values.length;\r\n                console.log(\"Has Tiles  offsetvalues count:\" + numoffsetValues);\r\n            }\r\n\r\n        },\r\n\r\n        /* Test */\r\n        consoleGeotiffProperty: function () {\r\n            console.log(\"--------------- GeoTiff property -------------------\");\r\n            var fileDirectory = this.fileDirectories[0];\r\n            var hdr_version = fileDirectory.GeoKeyDirectory.values[0];\r\n            var hdr_rev_major = fileDirectory.GeoKeyDirectory.values[1];\r\n            var hdr_rev_minor = fileDirectory.GeoKeyDirectory.values[2];\r\n            var hdr_num_keys = fileDirectory.GeoKeyDirectory.values[3];\r\n\r\n            console.log(\"hdr_version =\" + fileDirectory.GeoKeyDirectory + \" \" + hdr_version);\r\n            console.log(\"hdr_rev_major =\" + fileDirectory.GeoKeyDirectory + \" \" + hdr_rev_major);\r\n            console.log(\"hdr_rev_minor =\" + fileDirectory.GeoKeyDirectory + \" \" + hdr_rev_minor);\r\n            console.log(\"hdr_num_keys =\" + fileDirectory.GeoKeyDirectory + \" \" + hdr_num_keys);\r\n\r\n            this.consoleCRSProperty();\r\n            console.log(\"pixelSize =\" + this.getPixelSize());\r\n        },\r\n\r\n        /* Test */\r\n        consoleTestGeorefImage: function () {\r\n\r\n            var x = 2;\r\n            var y = 2;\r\n            var res = this.ImageToPCS(x, y);\r\n            if (res[0] == 1)\r\n                console.log(\" ImageToPCS \" + res[1] + \" \" + res[2]);\r\n            else\r\n                console.log(\" ImageToPCS failure\");\r\n\r\n            var res2 = this.PCSToImage(res[1], res[2]);\r\n            if (res2[0] == 1)\r\n                console.log(\" PCSToImage \" + res2[1] + \" \" + res2[2]);\r\n            else\r\n                console.log(\" PCSToImage failure\");\r\n        },\r\n\r\n        /*\r\n         * parse Header\r\n         * \r\n         */\r\n        parseHeader: function (tiffArrayBuffer) {\r\n\r\n            this.tiffDataView = new DataView(tiffArrayBuffer);\r\n            this.littleEndian = this.isLittleEndian(this.tiffDataView);\r\n\r\n            if (!this.hasTowel(this.tiffDataView, this.littleEndian)) {\r\n                return;\r\n            }\r\n\r\n            var firstIFDByteOffset = this.getBytes(4, 4);\r\n\r\n            this.fileDirectories = this.parseFileDirectory(firstIFDByteOffset);\r\n            var fileDirectory = this.fileDirectories[0];\r\n\r\n            this.imageWidth = fileDirectory.ImageWidth.values[0];\r\n            this.imageLength = fileDirectory.ImageLength.values[0];\r\n            this.photometricInterpretation = fileDirectory.PhotometricInterpretation.values[0];\r\n            this.samplesPerPixel = fileDirectory.SamplesPerPixel.values[0];\r\n\r\n            this.bitsPerPixel = 0;\r\n            fileDirectory.BitsPerSample.values.forEach(function (bitsPerSample, i, bitsPerSampleValues) {\r\n                this.sampleProperties[i] = {\r\n                    'bitsPerSample': bitsPerSample,\r\n                    'hasBytesPerSample': false,\r\n                    'bytesPerSample': undefined\r\n                };\r\n\r\n                if ((bitsPerSample % 8) === 0) {\r\n                    this.sampleProperties[i].hasBytesPerSample = true;\r\n                    this.sampleProperties[i].bytesPerSample = bitsPerSample / 8;\r\n                }\r\n\r\n                this.bitsPerPixel += bitsPerSample;\r\n            }, this);\r\n\r\n            this.compression = (fileDirectory.Compression) ? fileDirectory.Compression.values[0] : 1;\r\n\r\n            if (fileDirectory.ColorMap) {\r\n                this.colorMapValues = fileDirectory.ColorMap.values;\r\n                this.colorMapSampleSize = Math.pow(2, this.sampleProperties[0].bitsPerSample);\r\n            }\r\n\r\n            if (fileDirectory.ExtraSamples) {\r\n                this.extraSamplesValues = fileDirectory.ExtraSamples.values;\r\n                this.numExtraSamples = this.extraSamplesValues.length;\r\n            }\r\n\r\n\r\n            if (fileDirectory.hasOwnProperty('PlanarConfiguration') && true &&\r\n                fileDirectory.PlanarConfiguration.hasOwnProperty('values') == true)\r\n                this.planarConfiguration = fileDirectory.PlanarConfiguration.values[0];\r\n\r\n\r\n            this.parseGeoKeyDirectory();\r\n        },\r\n\r\n        /*\r\n        * SubFunction (should be private)\r\n        * Decode a Strip or a Tiles \r\n        */\r\n        decodeBlock: function (stripOffset, stripByteCount, moduleDecompression) {\r\n            var decodedBlock = [];\r\n            var jIncrement = 1, pixel = [];\r\n            var sampleformat = this.getSampleFormat();\r\n            // Decompress strip.\r\n            switch (this.compression) {\r\n                // Uncompressed\r\n                case 1:\r\n                    var bitOffset = 0;\r\n                    var hasBytesPerPixel = false;\r\n                    if ((this.bitsPerPixel % 8) === 0) {\r\n                        hasBytesPerPixel = true;\r\n                        var bytesPerPixel = this.bitsPerPixel / 8;\r\n                    }\r\n\r\n                    if (hasBytesPerPixel) {\r\n                        jIncrement = bytesPerPixel;\r\n                    } else {\r\n                        jIncrement = 0;\r\n                        throw RangeError(\"Cannot handle sub-byte bits per pixel\");\r\n                    }\r\n\r\n                    for (var byteOffset = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {\r\n\r\n                        // Loop through samples (sub-pixels).\r\n                        for (var m = 0, pixel = []; m < this.samplesPerPixel; m++) {\r\n                            if (this.sampleProperties[m].hasBytesPerSample) {\r\n                                var sampleOffset = this.sampleProperties[m].bytesPerSample * m;\r\n                                pixel.push(this.getSampleBytes(sampleformat, this.sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));\r\n                            } else {\r\n                                var sampleInfo = this.getBits(this.sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);\r\n\r\n                                pixel.push(sampleInfo.bits);\r\n\r\n                                byteOffset = sampleInfo.byteOffset - stripOffset;\r\n                                bitOffset = sampleInfo.bitOffset;\r\n\r\n                                throw RangeError(\"Cannot handle sub-byte bits per sample\");\r\n                            }\r\n                        }\r\n\r\n                        decodedBlock.push(pixel);\r\n                    }\r\n                    break;\r\n                case 5:\r\n                    var decompressed = LZString.decompressFromUint8Array(decodedBlock);\r\n\r\n                    break;\r\n                // Deflate \r\n                // Code not yes validate \r\n                case 32946:\r\n                    var inflator = new moduleDecompression.Inflate();\r\n                    var bitOffset = 0;\r\n                    var hasBytesPerPixel = false;\r\n                    if ((this.bitsPerPixel % 8) === 0) {\r\n                        hasBytesPerPixel = true;\r\n                        var bytesPerPixel = this.bitsPerPixel / 8;\r\n                    }\r\n\r\n                    if (hasBytesPerPixel) {\r\n                        jIncrement = bytesPerPixel;\r\n                    } else {\r\n                        jIncrement = 0;\r\n\r\n                        throw RangeError(\"Cannot handle sub-byte bits per pixel\");\r\n                    }\r\n\r\n                    var isLast = false;\r\n                    for (var byteOffset = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {\r\n\r\n                        // Loop through samples (sub-pixels).\r\n                        for (var m = 0, pixel = []; m < this.samplesPerPixel; m++) {\r\n                            if (this.sampleProperties[m].hasBytesPerSample) {\r\n                                // XXX: This is wrong!\r\n                                var sampleOffset = this.sampleProperties[m].bytesPerSample * m;\r\n\r\n                                pixel.push(this.getBytes(this.sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));\r\n                            } else {\r\n                                var sampleInfo = this.getBits(this.sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);\r\n\r\n                                pixel.push(sampleInfo.bits);\r\n\r\n                                byteOffset = sampleInfo.byteOffset - stripOffset;\r\n                                bitOffset = sampleInfo.bitOffset;\r\n\r\n                                throw RangeError(\"Cannot handle sub-byte bits per sample\");\r\n                            }\r\n                        }\r\n\r\n                        if (byteOffset + jIncrement >= stripByteCount)\r\n                            isLast = true;\r\n                        inflator.push(pixel, isLast);\r\n\r\n                    }\r\n                    if (inflator.err) {\r\n                        console.log(inflator.msg);\r\n                    }\r\n\r\n                    decodedBlock.push(inflator.result);\r\n                    break;\r\n\r\n                // PackBits\r\n                case 32773:\r\n                    var currentSample = 0;\r\n                    var sample = 0;\r\n                    var numBytes = 0;\r\n                    var getHeader = true;\r\n                    for (var byteOffset = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {\r\n\r\n                        // Are we ready for a new block?\r\n                        var blockLength;\r\n                        var iterations;\r\n                        if (getHeader) {\r\n                            getHeader = false;\r\n\r\n                            blockLength = 1;\r\n                            iterations = 1;\r\n\r\n                            // The header byte is signed.\r\n                            var header = this.tiffDataView.getInt8(stripOffset + byteOffset, this.littleEndian);\r\n\r\n                            if ((header >= 0) && (header <= 127)) { // Normal pixels.\r\n                                blockLength = header + 1;\r\n                            } else if ((header >= -127) && (header <= -1)) { // Collapsed pixels.\r\n                                iterations = -header + 1;\r\n                            } else /*if (header === -128)*/ { // Placeholder byte?\r\n                                getHeader = true;\r\n                            }\r\n                        } else {\r\n                            var currentByte = this.getBytes(1, stripOffset + byteOffset);\r\n\r\n                            // Duplicate bytes, if necessary.\r\n                            for (var m = 0; m < iterations; m++) {\r\n                                if (this.sampleProperties[sample].hasBytesPerSample) {\r\n                                    // We're reading one byte at a time, so we need to handle multi-byte samples.\r\n                                    currentSample = (currentSample << (8 * numBytes)) | currentByte;\r\n                                    numBytes++;\r\n\r\n                                    // Is our sample complete?\r\n                                    if (numBytes === this.sampleProperties[sample].bytesPerSample) {\r\n                                        pixel.push(currentSample);\r\n                                        currentSample = numBytes = 0;\r\n                                        sample++;\r\n                                    }\r\n                                } else {\r\n                                    throw RangeError(\"Cannot handle sub-byte bits per sample\");\r\n                                }\r\n\r\n                                // Is our pixel complete?\r\n                                if (sample === this.samplesPerPixel) {\r\n                                    decodedBlock.push(pixel);\r\n\r\n                                    pixel = [];\r\n                                    sample = 0;\r\n                                }\r\n                            }\r\n\r\n                            blockLength--;\r\n\r\n                            // Is our block complete?\r\n                            if (blockLength === 0) {\r\n                                getHeader = true;\r\n                            }\r\n                        }\r\n\r\n                        jIncrement = 1;\r\n                    }\r\n                    break;\r\n\r\n                // Unknown compression algorithm\r\n                default:\r\n                    throw Error(\"Do not attempt to parse the data Compression not handled  : \" + this.getCompressionTypeName(this.compression));\r\n                    // Do not attempt to parse the image data.\r\n                    break;\r\n            }\r\n\r\n            var blockInfo = {\r\n                'offset': stripOffset,\r\n                'value': decodedBlock\r\n            };\r\n            return blockInfo;\r\n        },\r\n\r\n\r\n        /* use requireJS to get the decompressionModule\r\n        *\r\n        */\r\n        getDecompressionModule: function (stripOffset, stripByteCount, moduleDecompression) {\r\n            var moduleDecompression = undefined;\r\n            // utiliser requirejs pour charger les modules de dcompression \r\n            if (this.compression == 32946) {\r\n                define(function (require) {\r\n                    moduleDecompression = require('pako_inflate');\r\n                });\r\n                //moduleDecompression= require('pako_inflate');\r\n            }\r\n            return moduleDecompression;\r\n        },\r\n\r\n        /**\r\n         * Load Pixels \r\n         */\r\n        loadPixels: function () {\r\n            var FullPixelValues = [];\r\n            var index = 0;\r\n            for (var j = 0; j < this.imageLength; j++)\r\n                for (var i = 0; i < this.imageWidth; i++) {\r\n                    var pixelValue = this.getPixelValueOnDemand(i, j);\r\n                    for (var k = 0; k < this.samplesPerPixel; k++) {\r\n                        FullPixelValues[index] = pixelValue[k];\r\n                        index++;\r\n                    }\r\n                }\r\n            return FullPixelValues;\r\n        },\r\n\r\n        /* getRGBAPixelValue\r\n        *  This function is the default one , you shoul use this function in order to draw the image into a canvas\r\n        *  If you have a multiband image , you should define how to combine bands in order to obtain a RGBA value\r\n        */\r\n        getRGBAPixelValue: function (pixelSamples) {\r\n            var red = 0;\r\n            var green = 0;\r\n            var blue = 0;\r\n            var opacity = 1.0;\r\n\r\n            // To Understand this portion of code from Tiff-JS\r\n            if (this.numExtraSamples > 0) {\r\n                for (var k = 0; k < this.numExtraSamples; k++) {\r\n                    if (this.extraSamplesValues[k] === 1 || this.extraSamplesValues[k] === 2) {\r\n                        // Clamp opacity to the range [0,1].\r\n                        opacity = pixelSamples[3 + k] / 256;\r\n\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //-------------------------------------------\r\n            var aRGBAPixelValue = [];\r\n            switch (this.photometricInterpretation) {\r\n                // Bilevel or Grayscale\r\n                // WhiteIsZero\r\n                case 0:\r\n                    if (this.sampleProperties[0].hasBytesPerSample) {\r\n                        var invertValue = Math.pow(0x10, this.sampleProperties[0].bytesPerSample * 2);\r\n                    }\r\n\r\n                    // Invert samples.\r\n                    pixelSamples.forEach(function (sample, index, samples) {\r\n                        samples[index] = invertValue - sample;\r\n                    });\r\n\r\n                // Bilevel or Grayscale\r\n                // BlackIsZero\r\n                case 1:\r\n                    red = green = blue = this.clampColorSample(pixelSamples[0], this.sampleProperties[0].bitsPerSample);\r\n                    break;\r\n\r\n                // RGB Full Color\r\n                case 2:\r\n                    if (this.samplesPerPixel == 1)\r\n                        red = green = blue = this.clampColorSample(pixelSamples[0], this.sampleProperties[0].bitsPerSample);\r\n                    else if (this.samplesPerPixel > 2) {\r\n                        red = this.clampColorSample(pixelSamples[0], this.sampleProperties[0].bitsPerSample);\r\n                        green = this.clampColorSample(pixelSamples[1], this.sampleProperties[1].bitsPerSample);\r\n                        blue = this.clampColorSample(pixelSamples[2], this.sampleProperties[2].bitsPerSample);\r\n                    }\r\n                    // Assuming 4 => RGBA \r\n                    if (this.samplesPerPixel == 4) {\r\n                        // Check this function A should be a value between 0->1 ? then devide pixelSamples[3]/this.sampleProperties[3].bitsPerSample\r\n                        var maxValue = Math.pow(2, this.sampleProperties[0].bitsPerSample);\r\n                        opacity = pixelSamples[3] / maxValue;\r\n                    }\r\n                    break;\r\n\r\n                // RGB Color Palette\r\n                case 3:\r\n                    if (this.colorMapValues === undefined) {\r\n                        throw Error(\"Palette image missing color map\");\r\n                    }\r\n\r\n                    var colorMapIndex = pixelSamples[0];\r\n\r\n                    red = this.clampColorSample(this.colorMapValues[colorMapIndex], 16);\r\n                    green = this.clampColorSample(this.colorMapValues[this.colorMapSampleSize + colorMapIndex], 16);\r\n                    blue = this.clampColorSample(this.colorMapValues[(2 * this.colorMapSampleSize) + colorMapIndex], 16);\r\n\r\n                    break;\r\n\r\n\r\n                // Unknown Photometric Interpretation\r\n                default:\r\n                    throw RangeError(' Photometric Interpretation Not Yet Implemented::', this.getPhotometricName(this.photometricInterpretation));\r\n                    break;\r\n            }\r\n            aRGBAPixelValue = [red, green, blue, opacity];\r\n            return aRGBAPixelValue;\r\n        },\r\n\r\n        /* getRGBAPixelValue\r\n        *  This function is the default one , you shoul use this function in order to draw the image into a canvas\r\n        *  If you have a multiband image , you should define how to combine bands in order to obtain a RGBA value\r\n        */\r\n        getMinMaxPixelValue: function (pixelSamples, vmin, vmax) {\r\n            var red = 0;\r\n            var green = 0;\r\n            var blue = 0;\r\n            var opacity = 1.0;\r\n\r\n            // To Understand this portion of code from Tiff-JS\r\n            if (this.numExtraSamples > 0) {\r\n                for (var k = 0; k < this.numExtraSamples; k++) {\r\n                    if (this.extraSamplesValues[k] === 1 || this.extraSamplesValues[k] === 2) {\r\n                        // Clamp opacity to the range [0,1].\r\n                        opacity = pixelSamples[3 + k] / 256;\r\n\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //-------------------------------------------\r\n            var aRGBAPixelValue = [];\r\n            switch (this.photometricInterpretation) {\r\n                // Bilevel or Grayscale\r\n                // WhiteIsZero\r\n                case 0:\r\n                    if (this.sampleProperties[0].hasBytesPerSample) {\r\n                        var invertValue = Math.pow(0x10, this.sampleProperties[0].bytesPerSample * 2);\r\n                    }\r\n\r\n                    // Invert samples.\r\n                    pixelSamples.forEach(function (sample, index, samples) {\r\n                        samples[index] = invertValue - sample;\r\n                    });\r\n\r\n                // Bilevel or Grayscale\r\n                // BlackIsZero\r\n                case 1:\r\n                    red = green = blue = this.clampAffineColorSample(pixelSamples[0], this.sampleProperties[0].bitsPerSample, vmin, vmax);\r\n                    break;\r\n\r\n                // RGB Full Color\r\n                case 2:\r\n                    if (this.samplesPerPixel == 1)\r\n                        red = green = blue = this.clampAffineColorSample(pixelSamples[0], this.sampleProperties[0].bitsPerSample, vmin, vmax);\r\n                    else if (this.samplesPerPixel > 2) {\r\n                        red = this.clampAffineColorSample(pixelSamples[0], this.sampleProperties[0].bitsPerSample, vmin, vmax);\r\n                        green = this.clampAffineColorSample(pixelSamples[1], this.sampleProperties[1].bitsPerSample, vmin, vmax);\r\n                        blue = this.clampAffineColorSample(pixelSamples[2], this.sampleProperties[2].bitsPerSample, vmin, vmax);\r\n                    }\r\n                    // Assuming 4 => RGBA \r\n                    if (this.samplesPerPixel == 4) {\r\n                        // Check this function A should be a value between 0->1 ? then devide pixelSamples[3]/this.sampleProperties[3].bitsPerSample\r\n                        var maxValue = Math.pow(2, this.sampleProperties[0].bitsPerSample);\r\n                        opacity = pixelSamples[3] / maxValue;\r\n                    }\r\n                    break;\r\n\r\n                // RGB Color Palette\r\n                case 3:\r\n                    if (this.colorMapValues === undefined) {\r\n                        throw Error(\"Palette image missing color map\");\r\n                    }\r\n\r\n                    var colorMapIndex = pixelSamples[0];\r\n\r\n                    red = this.clampAffineColorSample(this.colorMapValues[colorMapIndex], 16, vmin, vmax);\r\n                    green = this.clampAffineColorSample(this.colorMapValues[this.colorMapSampleSize + colorMapIndex], 16, vmin, vmax);\r\n                    blue = this.clampAffineColorSample(this.colorMapValues[(2 * this.colorMapSampleSize) + colorMapIndex], 16, vmin, vmax);\r\n\r\n                    break;\r\n\r\n\r\n                // Unknown Photometric Interpretation\r\n                default:\r\n                    throw RangeError(' Photometric Interpretation Not Yet Implemented::', this.getPhotometricName(this.photometricInterpretation));\r\n                    break;\r\n            }\r\n            aRGBAPixelValue = [red, green, blue, opacity];\r\n            return aRGBAPixelValue;\r\n        },\r\n\r\n        /* Test getPixelValueOnDemand\r\n       *  start implementation : \r\n       *  1 -  check if the block is loaded  if not load the block\r\n       *  2 - get the pixel value in the block\r\n       */\r\n        getClosestPixelValue: function (x, y) {\r\n            x = Math.floor(x);\r\n            y = Math.floor(y);\r\n\r\n            var fileDirectory = this.fileDirectories[0];\r\n            var blockToLoad = 0;\r\n            var offsetValues = [];\r\n            var numoffsetValues = 0;\r\n            var blockByteCountValues = [];\r\n            var rowsPerStrip = 0;\r\n            var decompressionModule = this.getDecompressionModule();\r\n            var xInBlock = x;\r\n            var yInBlock = y;\r\n            var blockWidth = 0;\r\n            var blockInfo = [];\r\n            if (this.hasStripOffset()) {\r\n                // If RowsPerStrip is missing, the whole image is in one strip.\r\n                if (fileDirectory.RowsPerStrip) {\r\n                    rowsPerStrip = fileDirectory.RowsPerStrip.values[0];\r\n                    blockToLoad = Math.floor(y / rowsPerStrip);\r\n                } else {\r\n                    rowsPerStrip = this.imageLength;\r\n                }\r\n                offsetValues = fileDirectory.StripOffsets.values;\r\n                blockWidth = this.imageWidth;\r\n\r\n                var idBlocks = this.isBlockLoaded(offsetValues[blockToLoad]);\r\n                if (idBlocks == -1) {\r\n                    // StripByteCounts is supposed to be required, but see if we can recover anyway.\r\n                    if (fileDirectory.StripByteCounts) {\r\n                        blockByteCountValues = fileDirectory.StripByteCounts.values;\r\n                    } else {\r\n                        console.log(\"Missing StripByteCounts!\");\r\n                        // Infer StripByteCounts, if possible.\r\n                        if (numoffsetValues === 1) {\r\n                            blockByteCountValues = [Math.ceil((this.imageWidth * this.imageLength * this.bitsPerPixel) / 8)];\r\n                        } else {\r\n                            throw Error(\"Cannot recover from missing StripByteCounts\");\r\n                        }\r\n                    }\r\n                    blockInfo = this.decodeBlock(offsetValues[blockToLoad], blockByteCountValues[blockToLoad], decompressionModule);\r\n                    this.addBlock(blockToLoad, blockInfo);\r\n                    //console.log(\"Load block \" , blockToLoad);\r\n                }\r\n                else {\r\n                    //console.log(\"Block is already load\" , blockToLoad, idBlocks );\r\n                    blockInfo = this.blocks[idBlocks];\r\n                }\r\n                yInBlock = y % rowsPerStrip;\r\n            }\r\n            else if (this.hasTileOffset()) {\r\n                offsetValues = fileDirectory.TileOffsets.values;\r\n                var tileLength = fileDirectory.TileLength.values[0];\r\n                var tileWidth = fileDirectory.TileWidth.values[0];\r\n                var iTile = Math.floor(x / tileWidth);\r\n                var jTile = Math.floor(y / tileLength);\r\n                var TilesAcross = Math.ceil(this.imageWidth / tileWidth);\r\n                blockToLoad = jTile * TilesAcross + iTile;\r\n                blockWidth = tileWidth;\r\n\r\n                var idBlocks = this.isBlockLoaded(offsetValues[blockToLoad]);\r\n                if (idBlocks == -1) {\r\n                    blockByteCountValues = fileDirectory.TileByteCounts.values;\r\n                    blockInfo = this.decodeBlock(offsetValues[blockToLoad], blockByteCountValues[blockToLoad], decompressionModule);\r\n                    this.addBlock(blockToLoad, blockInfo);\r\n                    //console.log(\"Load block \" , blockToLoad);\r\n                }\r\n                else {\r\n                    //console.log(\"Block is already load\" , blockToLoad, idBlocks );\r\n                    blockInfo = this.blocks[idBlocks];\r\n                }\r\n                xInBlock = x % tileWidth;\r\n                yInBlock = y % tileLength;\r\n            }\r\n            var indice = yInBlock * blockWidth + xInBlock;\r\n            return blockInfo.value[indice];\r\n        },\r\n\r\n        /* Test getPixelValueOnDemand\r\n        *  start implementation : \r\n        *  1 -  check if the block is loaded  if not load the block\r\n        *  2 - get the pixel value in the block\r\n        */\r\n        getPixelValueOnDemand: function (x, y) {\r\n            if (this.planarConfiguration != 1)\r\n                throw (\"Other Planar Configuration is not yet implemented\");\r\n\r\n\r\n            if (this.isPixelArea) {\r\n                return this.getClosestPixelValue(x, y);\r\n            }\r\n\r\n            /* Calcul de l'interpolation \r\n            var ix= Math.floor(x);\r\n            var iy= Math.floor(y);\r\n            var  a1 = this.getPixelValueOnDemand(ix, iy);\r\n            var  a2 = this.getPixelValueOnDemand(ix + 1, iy);\r\n            var  a3 = this.getPixelValueOnDemand(ix + 1, iy + 1);\r\n            var  a4 = this.getPixelValueOnDemand(ix, iy + 1);\r\n            // Avant d'inerpoler  : vrifier si on a les mme valeurs \r\n\r\n            // puis calculer l'interpolation en tre 4 val (formule ?) \r\n            */\r\n\r\n            // retourne la valeur du pixel le plus proche \r\n            var ix = Math.floor(x + 0.5);\r\n            var iy = Math.floor(y + 0.5);\r\n            return this.getClosestPixelValue(ix, iy);\r\n\r\n\r\n        },\r\n\r\n        /** get the CRS code */\r\n        getCRSCode: function () {\r\n            var CRSCode = 0;\r\n            if (this.geoKeys.hasOwnProperty('GTModelTypeGeoKey') == false)\r\n                return 0;\r\n            if (this.getModelTypeName(this.geoKeys.GTModelTypeGeoKey.value) == 'ModelTypeGeographic'\r\n                && this.geoKeys.hasOwnProperty('GeographicTypeGeoKey'))\r\n                CRSCode = this.geoKeys['GeographicTypeGeoKey'].value;\r\n\r\n            else if (this.getModelTypeName(this.geoKeys.GTModelTypeGeoKey.value) == 'ModelTypeProjected' &&\r\n                this.geoKeys.hasOwnProperty('ProjectedCSTypeGeoKey'))\r\n                CRSCode = this.geoKeys['ProjectedCSTypeGeoKey'].value;\r\n            else if (this.getModelTypeName(this.geoKeys.GTModelTypeGeoKey.value) == 'user-defined') {\r\n                if (this.geoKeys.hasOwnProperty('ProjectedCSTypeGeoKey'))\r\n                    CRSCode = this.geoKeys['ProjectedCSTypeGeoKey'].value;\r\n                else if (this.geoKeys.hasOwnProperty('GeographicTypeGeoKey'))\r\n                    CRSCode = this.geoKeys['GeographicTypeGeoKey'].value;\r\n                else\r\n                    // Littel Hack for 3857\r\n                    if (this.geoKeys.hasOwnProperty('GTCitationGeoKey') &&\r\n                        this.geoKeys['GTCitationGeoKey'].value.search(\"WGS_1984_Web_Mercator_Auxiliary_Sphere\") != -1)\r\n                        CRSCode = 3857;\r\n                    else\r\n                        this.consoleCRSProperty();\r\n\r\n            }\r\n            return CRSCode;\r\n        },\r\n\r\n        /** get the CRS code */\r\n        consoleCRSProperty: function () {\r\n            //GeoTIFF Configuration GeoKeys\r\n            var Configuration_GeoKeys = [1024, 1026];\r\n            // Geographic CS Parameter GeoKeys\r\n            var GeographicCS_GeoKeys = [2048, 2061];\r\n            // Projected CS Parameter GeoKeys\r\n            var ProjectedCS_GeoKeys = [3072, 3073];\r\n            //Projection Definition GeoKeys\r\n            var Projection_GeoKeys = [3074, 3094];\r\n            //Vertical CS Parameter Keys\r\n            var Vertical_GeoKeys = [4096, 4099];\r\n            this.test_consoleGeoKeys(\"GeoTIFF Configuration GeoKeys\", Configuration_GeoKeys);\r\n            this.test_consoleGeoKeys(\"Geographic CS Parameter GeoKeys\", GeographicCS_GeoKeys);\r\n            this.test_consoleGeoKeys(\"Projected CS Parameter GeoKeys\", ProjectedCS_GeoKeys);\r\n            this.test_consoleGeoKeys(\"Projection Definition GeoKeys\", Projection_GeoKeys);\r\n            this.test_consoleGeoKeys(\"Vertical CS Parameter Keys\", Vertical_GeoKeys);\r\n        },\r\n\r\n        /** show consoleGeokey  */\r\n        test_consoleGeoKeys: function (Label, GeoKeyTab) {\r\n            console.log(Label);\r\n            for (var i = GeoKeyTab[0]; i <= GeoKeyTab[1]; i++) {\r\n                var geoKeyName = this.getGeoKeyName(i);\r\n                if (this.geoKeys.hasOwnProperty(geoKeyName))\r\n                    console.log(geoKeyName + \" \" + this.geoKeys[geoKeyName].value);\r\n            }\r\n        },\r\n\r\n        /** isPixelArea */\r\n        isPixelArea: function () {\r\n            if (this.geoKeys.hasOwnProperty('GTRasterTypeGeoKey') == false)\r\n                return true; // default \r\n            if (this.getRasterTypeName(this.geoKeys.GTRasterTypeGeoKey.value) == 'RasterPixelIsArea')\r\n                return true;\r\n\r\n            return false;\r\n        },\r\n\r\n        /**\r\n         * Get the pixel value \r\n         * Ex : var pixels = parse.parseTIFF(response);\r\n         *      var pixel = parse.getPixelValue(pixels,i,j);\r\n         */\r\n        getPixelValue: function (buffer, x, y) {\r\n            if (this.getPlanarConfiguration() != 1) {\r\n                throw (\"Other Planar Configuration is not yet implemented\");\r\n            }\r\n\r\n            var value = [];\r\n            if (x < 0 || x >= this.imageWidth || y < 0 || y >= this.imageLength) {\r\n                return value;\r\n            }\r\n\r\n            var indice = this.samplesPerPixel * (y * this.imageWidth + x);\r\n            for (var i = 0; i < this.samplesPerPixel; i++) {\r\n                //console.log(x,y,this.samplesPerPixel,i,buffer[indice+i] ) ;\r\n                value[i] = buffer[indice + i]; // don't use array.push in big loops\r\n            }\r\n            return value;\r\n        },\r\n\r\n        getLowResPixelValue: function (buffer, x, y) {\r\n            if (this.getPlanarConfiguration() != 1) {\r\n                throw (\"Other Planar Configuration is not yet implemented\");\r\n            }\r\n\r\n            var value = [];\r\n            if (x < 0 || x >= this.imageWidth || y < 0 || y >= this.imageLength) {\r\n                return value;\r\n            }\r\n\r\n            var indice1 = this.samplesPerPixel * (y * this.imageWidth + x);\r\n            var offsetX = (x < this.imageWidth ? x + 1 : x);\r\n            var indice2 = this.samplesPerPixel * (y * this.imageWidth + offsetX);\r\n            var indice3 = this.samplesPerPixel * (y * this.imageWidth + x);\r\n            var indice4 = this.samplesPerPixel * ((y < this.imageLength ? y + 1 : y) * this.imageWidth + offsetX);\r\n            for (var i = 0; i < this.samplesPerPixel; i++) {\r\n                var averageValue = (buffer[indice1 + i] + buffer[indice2 + i] + buffer[indice3 + i] + buffer[indice4 + i]) / 4;\r\n                value[i] = Math.round(averageValue);\r\n            }\r\n            return value;\r\n        },\r\n\r\n        /**\r\n         * This function display the tiff into a canvas \r\n         */\r\n\r\n        toCanvas: function (canvas, xmin, ymin, xmax, ymax, vmin, vmax) {\r\n            var mycanvas = canvas || document.createElement('canvas');\r\n\r\n            if (mycanvas.getContext == null) {\r\n                throw RangeError(\"No Context for canvas\");\r\n            }\r\n\r\n            var ctx = mycanvas.getContext(\"2d\");\r\n            mycanvas.width = xmax - xmin;\r\n            mycanvas.height = ymax - xmin;\r\n            var pixrgba = [];\r\n            // Set a default fill style.\t\r\n            ctx.fillStyle = this.makeRGBAFillValue(255, 255, 255, 0);\r\n            for (var y = ymin; y < ymax; y++) {\r\n                for (var x = xmin; x < xmax; x++) {\r\n                    var pixSample = this.getPixelValueOnDemand(x, y);\r\n                    if (pixSample != 'undefined') {\r\n                        if (vmin != 'undefined' && vmax != 'undefined')\r\n                            pixrgba = this.getMinMaxPixelValue(pixSample, vmin, vmax);\r\n                        else\r\n                            pixrgba = this.getRGBAPixelValue(pixSample);\r\n                    }\r\n                    else\r\n                        pixrgba = [255, 0, 0, 1];\r\n                    ctx.fillStyle = this.makeRGBAFillValue(pixrgba[0], pixrgba[1], pixrgba[2], pixrgba[3]);\r\n                    //ctx.fillStyle = this.makeRGBAFillValue(0, 0,248,1);\r\n                    ctx.fillRect(x - xmin, y - ymin, 1, 1);\r\n                }\r\n            }\r\n            return mycanvas;\r\n        },\r\n\r\n        /** Compute or retreive a PixelScale / Resolution or CellSize */\r\n        getPixelSize: function () {\r\n            var pixel_scale = ['undefined', 'undefined'];\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (typeof (fileDirectory.ModelPixelScale) != 'undefined' && fileDirectory.ModelPixelScale != null &&\r\n                typeof (fileDirectory.ModelPixelScale.values) != 'undefined' && fileDirectory.ModelPixelScale.values != null)\r\n                return fileDirectory.ModelPixelScale.values;\r\n\r\n            var p0 = this.ImageToPCS(0, 0);\r\n            var p1 = this.ImageToPCS(1, 0);\r\n            var p2 = this.ImageToPCS(0, 1);\r\n            if (p0[0] == 0 || p1[0] == 0 || p2[0] == 0)\r\n                return pixel_scale;\r\n\r\n            var c_pixel_scale = [p1[1] - p0[1], p2[2] - p0[2]];\r\n            return c_pixel_scale;\r\n        },\r\n\r\n        /**\r\n         * See GeoTiff geo_trans.c\r\n         */\r\n        GTIFTiepointTranslate: function (gcp_count, x, y, directTransfo) {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            var modelTiepoint = fileDirectory.ModelTiepoint.values;\r\n            /* I would appreciate a _brief_ block of code for doing second order\r\n               polynomial regression here! */\r\n            return [0, x, y];\r\n        },\r\n\r\n        /**\r\n        * return a BBox of the Image\r\n        */\r\n        GetBBox: function () {\r\n            var pCRS = this.getCRSCode();\r\n\r\n            var ul = this.ImageToPCS(0, 0);\r\n            var ur = this.ImageToPCS(this.imageWidth, 0);\r\n            var ll = this.ImageToPCS(0, this.imageLength);\r\n            var lr = this.ImageToPCS(this.imageWidth, this.imageLength);\r\n            if (ul[0] != 1 || ur[0] != 1 || ll[0] != 1 || lr[0] != 1) {\r\n                throw TypeError(\"BBox error\");\r\n            }\r\n\r\n            // Create the BBox structure\r\n            // Coord a counterclockWise\r\n            var lcoordinates = [];\r\n            lcoordinates.push(ul.splice(1, 2));\r\n            lcoordinates.push(ll.splice(1, 2));\r\n            lcoordinates.push(lr.splice(1, 2));\r\n            lcoordinates.push(ur.splice(1, 2));\r\n\r\n            var projstring = 'EPSG:' + pCRS.toString();\r\n            var bbox = {\r\n                'WKID': pCRS.toString(),\r\n                'EPSG': projstring,\r\n                'coord': lcoordinates,\r\n                'ulidx': 0,\r\n                'llidx': 1,\r\n                'lridx': 2,\r\n                'uridx': 3\r\n            };\r\n            return bbox;\r\n        },\r\n\r\n        /**\r\n         * Translate a pixel/line coordinates to projection coordinate .\r\n         * See GeoTiff geo_trans.c\r\n         */\r\n        ImageToPCS: function (x, y) {\r\n\r\n            var res = [0, x, y];\r\n            var tiepoint_count, count, transform_count;\r\n\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (typeof (fileDirectory.ModelTiepoint) == 'undefined' || fileDirectory.ModelTiepoint == null ||\r\n                typeof (fileDirectory.ModelTiepoint.values) == 'undefined' || fileDirectory.ModelTiepoint.values == null)\r\n                tiepoint_count = 0;\r\n            else {\r\n\r\n                var modelTiepoint = fileDirectory.ModelTiepoint.values;\r\n                tiepoint_count = modelTiepoint.length;\r\n            }\r\n\r\n            if (typeof (fileDirectory.ModelPixelScale) == 'undefined' || fileDirectory.ModelPixelScale == null ||\r\n                typeof (fileDirectory.ModelPixelScale.values) == 'undefined' || fileDirectory.ModelPixelScale.values == null)\r\n                count = 0;\r\n            else {\r\n                var modelPixelScale = fileDirectory.ModelPixelScale.values;\r\n                count = modelPixelScale.length;\r\n            }\r\n\r\n            if (typeof (fileDirectory.ModelTransformation) == 'undefined' || fileDirectory.ModelTransformation == null ||\r\n                typeof (fileDirectory.ModelTransformation.values) == 'undefined' || fileDirectory.ModelTransformation.values == null)\r\n                transform_count = 0;\r\n            else {\r\n                var modelTransformation = fileDirectory.ModelTransformation.values;\r\n                transform_count = modelTransformation.length;\r\n            }\r\n\r\n            //--------------------------------------------------------------------\r\n            //If the pixelscale count is zero, but we have tiepoints use      \r\n            //the tiepoint based approach.                                    \r\n            //--------------------------------------------------------------------\r\n            if (tiepoint_count > 6 && count == 0) {\r\n                console.log(\" tiepoint_count \", tiepoint_count);\r\n\r\n                res = this.GTIFTiepointTranslate(tiepoint_count / 6, x, y, true);\r\n            }\r\n\r\n            //--------------------------------------------------------------------\r\n            //If we have a transformation matrix, use it. \t\t\t\r\n            //--------------------------------------------------------------------\r\n            else if (transform_count == 16) {\r\n                var transform = fileDirectory.ModelTransformation.values;\r\n\r\n                var x_in = x;\r\n                var y_in = y;\r\n\r\n                x = x_in * transform[0] + y_in * transform[1] + transform[3];\r\n                y = x_in * transform[4] + y_in * transform[5] + transform[7];\r\n\r\n                res = [1, x, y];\r\n            }\r\n\r\n            //--------------------------------------------------------------------\r\n            //For now we require one tie point, and a valid pixel scale.      \r\n            //-------------------------------------------------------------------- \r\n            else if (count < 3 || tiepoint_count < 6) {\r\n                res = [0, x, y];\r\n            }\r\n\r\n            else {\r\n                var pixel_scale = fileDirectory.ModelPixelScale.values;\r\n                var tiepoints = fileDirectory.ModelTiepoint.values;\r\n                x = (x - tiepoints[0]) * pixel_scale[0] + tiepoints[3];\r\n                y = (y - tiepoints[1]) * (-1 * pixel_scale[1]) + tiepoints[4];\r\n\r\n                res = [1, x, y];\r\n            }\r\n            return res;\r\n        },\r\n\r\n        /**\r\n        * Inverse GeoTransfom\r\n        * See GeoTiff geo_trans.c\r\n        */\r\n        inv_geotransform: function (gt_in) {\r\n            var gt_out = [0, 0, 0, 0, 0, 0];\r\n            var det, inv_det;\r\n\r\n            /* we assume a 3rd row that is [0 0 1] */\r\n\r\n            /* Compute determinate */\r\n\r\n            det = gt_in[0] * gt_in[4] - gt_in[1] * gt_in[3];\r\n\r\n            if (Math.abs(det) < 0.000000000000001)\r\n                return [0, gt_out];\r\n\r\n            inv_det = 1.0 / det;\r\n\r\n            /* compute adjoint, and devide by determinate */\r\n\r\n            gt_out[0] = gt_in[4] * inv_det;\r\n            gt_out[3] = -gt_in[3] * inv_det;\r\n\r\n            gt_out[1] = -gt_in[1] * inv_det;\r\n            gt_out[4] = gt_in[0] * inv_det;\r\n\r\n            gt_out[2] = (gt_in[1] * gt_in[5] - gt_in[2] * gt_in[4]) * inv_det;\r\n            gt_out[5] = (-gt_in[0] * gt_in[5] + gt_in[2] * gt_in[3]) * inv_det;\r\n\r\n            return [1, gt_out];\r\n        },\r\n\r\n        /**\r\n         * Translate a projection coordinate to pixel/line coordinates.\r\n         * See GeoTiff geo_trans.c\r\n         */\r\n\r\n        PCSToImage: function (x, y) {\r\n            var res = [0, x, y];\r\n            var tiepoint_count, count, transform_count = 0;\r\n\r\n            // -------------------------------------------------------------------- \r\n            //      Fetch tiepoints and pixel scale.                                \r\n            // -------------------------------------------------------------------- \r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (typeof (fileDirectory.ModelTiepoint) == 'undefined' || fileDirectory.ModelTiepoint == null ||\r\n                typeof (fileDirectory.ModelTiepoint.values) == 'undefined' || fileDirectory.ModelTiepoint.values == null)\r\n                tiepoint_count = 0;\r\n            else {\r\n\r\n                var modelTiepoint = fileDirectory.ModelTiepoint.values;\r\n                tiepoint_count = modelTiepoint.length;\r\n            }\r\n\r\n            if (typeof (fileDirectory.ModelPixelScale) == 'undefined' || fileDirectory.ModelPixelScale == null ||\r\n                typeof (fileDirectory.ModelPixelScale.values) == 'undefined' || fileDirectory.ModelPixelScale.values == null)\r\n                count = 0;\r\n            else {\r\n                var modelPixelScale = fileDirectory.ModelPixelScale.values;\r\n                count = modelPixelScale.length;\r\n            }\r\n\r\n            if (typeof (fileDirectory.ModelTransformation) == 'undefined' || fileDirectory.ModelTransformation == null ||\r\n                typeof (fileDirectory.ModelTransformation.values) == 'undefined' || fileDirectory.ModelTransformation.values == null)\r\n                transform_count = 0;\r\n            else {\r\n                var modelTransformation = fileDirectory.ModelTransformation.values;\r\n                transform_count = modelTransformation.length;\r\n            }\r\n            // -------------------------------------------------------------------- \r\n            //      If the pixelscale count is zero, but we have tiepoints use      \r\n            //      the tiepoint based approach.                                    \r\n            // -------------------------------------------------------------------- \r\n            if (tiepoint_count > 6 && count == 0) {\r\n                res = this.GTIFTiepointTranslate(tiepoint_count / 6, x, y, false);\r\n            }\r\n\r\n            // -------------------------------------------------------------------- \r\n            //      Handle matrix - convert to \"geotransform\" format, invert and    \r\n            //      apply.                                                          \r\n            // -------------------------------------------------------------------- \r\n            else if (transform_count == 16) {\r\n                var transform = fileDirectory.ModelTransformation.values;\r\n\r\n                var x_in = x;\r\n                var y_in = y;\r\n\r\n                var gt_in = [0, 0, 0, 0, 0, 0];\r\n\r\n                gt_in[0] = transform[0];\r\n                gt_in[1] = transform[1];\r\n                gt_in[2] = transform[3];\r\n                gt_in[3] = transform[4];\r\n                gt_in[4] = transform[5];\r\n                gt_in[5] = transform[7];\r\n\r\n                var result = this.inv_geotransform(gt_in);\r\n\r\n                if (!result[0])\r\n                    res = [0, x, y];\r\n                else {\r\n                    var gt_out = result[1];\r\n                    x = x_in * gt_out[0] + y_in * gt_out[1] + gt_out[2];\r\n                    y = x_in * gt_out[3] + y_in * gt_out[4] + gt_out[5];\r\n\r\n                    res = [1, x, y];\r\n                }\r\n            }\r\n\r\n            // -------------------------------------------------------------------- \r\n            //      For now we require one tie point, and a valid pixel scale.      \r\n            // -------------------------------------------------------------------- \r\n            else if (count >= 3 && tiepoint_count >= 6) {\r\n                var pixel_scale = fileDirectory.ModelPixelScale.values;\r\n                var tiepoints = fileDirectory.ModelTiepoint.values;\r\n                x = (x - tiepoints[3]) / pixel_scale[0] + tiepoints[0];\r\n                y = (y - tiepoints[4]) / (-1 * pixel_scale[1]) + tiepoints[1];\r\n\r\n                res = [1, x, y];\r\n            }\r\n\r\n            return res;\r\n        }\r\n    };\r\n\r\n    function convertToFloat(tab) {\r\n        for (var j = 0; j < tab.length; j++) {\r\n            var b = parseFloat(tab[j]);\r\n            if (!isNaN(b))\r\n                tab[j] = b;\r\n        }\r\n        return tab;\r\n    }\r\n\r\n    function invertTab(tab) {\r\n        var b = tab[1];\r\n        tab[1] = tab[0];\r\n        tab[0] = b;\r\n        return tab;\r\n    }\r\n\r\n})();\r\nexport default MergeTerrainProvider;","export default function(polygon, point) {\n  var n = polygon.length,\n      p = polygon[n - 1],\n      x = point[0], y = point[1],\n      x0 = p[0], y0 = p[1],\n      x1, y1,\n      inside = false;\n\n  for (var i = 0; i < n; ++i) {\n    p = polygon[i], x1 = p[0], y1 = p[1];\n    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;\n    x0 = x1, y0 = y1;\n  }\n\n  return inside;\n}\n"],"names":["MergeTerrainProvider","options","view","fallbackOptions","this","noDataValue","commutingProvidersReady","commutingProvidersPromises","cesium","when","defer","surfaceHasTilesToRender","surfaceTilesToRender","fallback","fallbackProvider","map","index","type","url","indexOf","WMTSTerrainProvider","WCSTerrainProvider","defaultFallbackProvider","EllipsoidTerrainProvider","attributions","trigger","SITNA","Consts","event","TERRAINPROVIDERADD","terrainProvider","Resource","trim","CesiumTerrainProvider","call","boundaries","Array","isArray","all","_readyPromise","readyPromise","resolve","bind","prototype","Object","create","value","enumerable","configurable","writable","allReady","get","allReadyPromise","constructor","isPointInDefaultBoundaries","cartographic","self","length","isPointInBoundaries","isInDefaultBoundaries","x","y","level","isInBoundaries","some","bound","polygon","point","x1","y1","n","p","x0","y0","inside","i","D3","Math","toDegrees","longitude","latitude","toCheck","rectangle","tilingScheme","tileXYToRectangle","push","Cartographic","west","south","north","east","getTileDataAvailable","_availability","_maximumLevel","getAttribution","requestTileGeometry","promise","manageAttributions","provider","otherwise","filter","fbp","ready","find","arr","apply","then","terrainData","args","_minimumHeight","arguments","sampleTerrainMostDetailed","positions","Rectangle","fromCartographicArray","center","northeast","northwest","southeast","southwest","async","position","OGCTerrainProvider","description","deferred","_ready","defined","DeveloperError","layerName","errorEvent","Event","_eventHelper","EventHelper","credit","Credit","tileCacheService","TileCacheService","createDB","lastTile","undefined","DefaultProvider","defineProperties","hasVertexNormals","_heightmapWidth","urlofServer","lastIndexOf","substring","TerrainParser","getCapabilities","OGCHelper","CRS","name","ellipsoid","Ellipsoid","WGS84","firstAxeIsLatitude","GeographicTilingScheme","SupportedCRS","WebMercatorTilingScheme","FormatImage","format","extension","f","toLowerCase","TiledError","console","log","ImageToHeightmapTerrainData","arrayBuffer","size","tilingSc","GeotiffToHeightmapTerrainData","imageToBuffer","offset","lowest","highest","width","height","parser","GeotiffParser","parseHeader","imageWidth","imageLength","heightBuffer","Float32Array","rect","tileXYToNativeRectangle","xSpacing","ySpacing","j","lon","lat","res","PCSToImage","pixelValue","getPixelValueOnDemand","HeightmapTerrainData","childrenMask","optionsHeihtmapTerrainData","buffer","childTileMask","parse","resultat","defaultValue","EMPTY_OBJECT","urlDescribeCoverage","proxy","getURL","fetchXML","xml","getDescribeCoverage","coverage","minLevel","maxLevel","heightMapWidth","heightMapHeight","corner","querySelector","textContent","split","elm","lowerCorner","convertToFloat","slice","upperCorner","projstring","toString","getCRS","elt","pixelSize","levelZeroMaximumGeometricError","TerrainProvider","getEstimatedLevelZeroGeometricErrorForAHeightmap","_ellipsoid","min","getNumberOfXTilesAtLevel","waterMask","bbox","isInTile","urlGetTerrain","isTileInside","coord","ulidx","lridx","uridx","llidx","templateToURL","replace","urlGetCapabilities","labelNode","linkNode","site","getAttribute","_parse","styleName","template","listTileMatrixSetLinkNode","urlKVP","urlRESTful","formatImage","generate","from","querySelectorAll","node","forEach","item","nodeIdentifiers","layerNode","parentNode","defaultStyle","selectedStyle","style","nodeFormats","l","nodeMatrixSetIds","a","matrixSetLinkNode","tileMatrixSetLinkName","tileMatrixSetNode","CRSSelected","supportedCRS","includes","tileSets","noeud","id","maxWidth","parseInt","maxHeight","tileWidth","tileHeight","scaleDenominator","parseFloat","complete","sort","b","listTileMatrixLimits","nodeLink","minTileRow","maxTileRow","minTileCol","maxTileCol","tile","resourceURL","retour","imageSize","widht","urlGetTile","_super","promises","maximumLevel","hasStyledImage","image","limitations","dataPixels","getImagePixels","msb","getHeightmapTerrainData","isNaN","urlGetTileOrCoverage","hasChildren","getTileData","tileData","myHeightmapTerrainData","data","evt","fetchDataImage","fetchArrayBuffer","fetchImage","myHeightmapBuffer","addTile","getLevelMaximumGeometricError","adviced","toast","TC","Util","getLocaleString","locale","msgType","INFO","reject","hasWaterMask","toRadians","scalingX","scalingY","abs","doSampling","tileRequests","tileRequestSet","xy","positionToTileXY","key","hasOwnProperty","tilePromises","tileRequest","requestPromise","tilePromise","createInterpolateFunction","createMarkFailedFunction","tilePositions","interpolateHeight","objectStoreName","database","tiffDataView","littleEndian","bitsPerPixel","samplesPerPixel","photometricInterpretation","compression","fileDirectories","sampleProperties","geoKeys","blocks","colorMapValues","colorMapSampleSize","isPixelArea","planarConfiguration","extraSamplesValues","numExtraSamples","tab","doSamplingWhenReady","updatedPositions","setTimeout","window","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","IDBTransaction","webkitIDBTransaction","msIDBTransaction","IDBKeyRange","webkitIDBKeyRange","msIDBKeyRange","alert","request","open","that","onsuccess","target","result","onerror","onupgradeneeded","thisDB","objectStoreNames","contains","createObjectStore","keyPath","createIndex","unique","info","webkitStorageInfo","queryUsageAndQuota","TEMPORARY","used","remaining","e","isReady","column","row","requestGet","transaction","objectStore","guid","c","r","random","add","ex","isLittleEndian","BOM","getBytes","TypeError","hasTowel","RangeError","getLinearUnitsName","linearUnitsCode","LinearUnitsName","getAngularUnitsName","angularUnitsCode","AngularUnitsName","getModelTypeName","modelTypeCode","modelTypeName","getRasterTypeName","rasterTypeCode","rasterTypeName","getGeoKeyName","geoKey","geoKeyName","geoKeyTagNames","getFieldTagName","fieldTag","fieldTagName","fieldTagNames","getPhotometricName","photometricNames","getCompressionTypeName","compressionNames","getFieldTypeName","fieldType","fieldTypeName","fieldTypeNames","getFieldTypeLength","fieldTypeLength","getBits","numBits","byteOffset","bitOffset","newByteOffset","floor","totalBits","shiftRight","rawBits","shiftLeft","getUint8","getUint16","getUint32","numBytes","getFloat64","getSampleBytes","sampleFormat","getFloat32","Error","getFieldValues","typeCount","valueOffset","fieldValues","fieldValueSize","indexOffset","String","fromCharCode","clampColorSample","colorSample","bitsPerSample","multiplier","pow","clampAffineColorSample","vmin","vmax","makeRGBAFillValue","g","parseFileDirectory","numDirEntries","tiffFields","entryCount","nextIFDByteOffset","isGeotiff","fileDirectory","GeoKeyDirectory","values","getPlanarConfiguration","PlanarConfiguration","getSampleFormat","SampleFormat","getSampleMinMax","SMaxSampleValue","SMinSampleValue","isBlockLoaded","blockOffset","getBlock","addBlock","stripToLoad","block","hasStripOffset","StripOffsets","hasTileOffset","TileOffsets","parseGeoKeyDirectory","hdr_num_keys","geoKeyFields","iKey","ent_key","ent_location","ent_count","ent_val_offset","GeoDoubleParams","str","GeoAsciiParams","GTRasterTypeGeoKey","consoleTiffProperty","numoffsetValues","consoleGeotiffProperty","hdr_version","hdr_rev_major","hdr_rev_minor","consoleCRSProperty","getPixelSize","consoleTestGeorefImage","ImageToPCS","res2","tiffArrayBuffer","DataView","firstIFDByteOffset","ImageWidth","ImageLength","PhotometricInterpretation","SamplesPerPixel","BitsPerSample","bitsPerSampleValues","hasBytesPerSample","bytesPerSample","Compression","ColorMap","ExtraSamples","decodeBlock","stripOffset","stripByteCount","moduleDecompression","decodedBlock","jIncrement","pixel","sampleformat","hasBytesPerPixel","bytesPerPixel","m","sampleInfo","bits","sampleOffset","LZString","decompressFromUint8Array","inflator","Inflate","isLast","err","msg","currentSample","sample","getHeader","blockLength","iterations","header","getInt8","currentByte","getDecompressionModule","define","require","loadPixels","FullPixelValues","k","getRGBAPixelValue","pixelSamples","red","green","blue","opacity","invertValue","samples","maxValue","colorMapIndex","getMinMaxPixelValue","getClosestPixelValue","blockToLoad","offsetValues","blockByteCountValues","rowsPerStrip","decompressionModule","xInBlock","yInBlock","blockWidth","blockInfo","RowsPerStrip","idBlocks","StripByteCounts","tileLength","TileLength","TileWidth","iTile","ceil","TileByteCounts","indice","ix","iy","getCRSCode","CRSCode","GTModelTypeGeoKey","search","test_consoleGeoKeys","Label","GeoKeyTab","getPixelValue","getLowResPixelValue","indice1","offsetX","indice2","indice3","indice4","averageValue","round","toCanvas","canvas","xmin","ymin","xmax","ymax","mycanvas","document","createElement","getContext","ctx","pixrgba","fillStyle","pixSample","fillRect","ModelPixelScale","p0","p1","p2","GTIFTiepointTranslate","gcp_count","directTransfo","ModelTiepoint","GetBBox","pCRS","ul","ur","ll","lr","lcoordinates","splice","tiepoint_count","count","transform_count","ModelTransformation","transform","x_in","y_in","pixel_scale","tiepoints","inv_geotransform","gt_in","det","inv_det","gt_out"],"sourceRoot":""}