{"version":3,"file":"chunks/3688.sitna.js","mappings":"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","sources":["webpack://SITNA/./TC/tool/ElevationService.js","webpack://SITNA/./TC/tool/ElevationServiceIGNEs.js"],"sourcesContent":["import TC from '../../TC';\r\nimport Util from '../Util'\r\n/**\r\n  * Opciones de servicio de obtención de elevaciones de puntos.\r\n  * @typedef ElevationServiceOptions\r\n  * @memberof SITNA\r\n  * @see SITNA.ElevationOptions\r\n  * @property {string[]} [allowedGeometryTypes] - Si se establece, indica para qué geometrías se van a hacer consultas \r\n  * de elevación al servicio. Esto es conveniente por ejemplo si el servicio solo permite obtener elevaciones de un punto simple,\r\n  * invalidándolo para la consulta si la geometría es un polígono o una línea. Los elementos del array tienen que ser cadenas \r\n  * cuyos valores deben ser los definidos por [SITNA.Consts.geom]{@link SITNA.Consts}.\r\n  * @property {string} [googleMapsKey] - Valor de una clave válida de la API de Google Maps. Solamente es necesaria cuando \r\n  * el valor de la propiedad `name` es [SITNA.Consts.elevationService.GOOGLE]{@link SITNA.Consts}.\r\n  *\r\n  * Puede obtener más información en el [sitio para desarrolladores de Google](https://developers.google.com/maps/documentation/javascript/get-api-key).\r\n  * @property {string} name - Nombre del servicio que queremos utilizar. Debe tener un valor de [SITNA.Consts.elevationService]{@link SITNA.Consts}.\r\n  * @property {string} [url] - URL del servicio. Cada servicio de elevaciones de puntos tiene asignada una URL por defecto, \r\n  * así que rara vez será necesario establecer esta propiedad.\r\n  */\r\n\r\nclass ElevationService { \r\n    constructor(options) {\r\n        const self = this;\r\n        self.options = options || {};\r\n        self.url = self.options.url;\r\n        self.process = self.options.process;\r\n        self.minimumElevation = self.options.minimumElevation;\r\n        if (Util.isFunction(self.options.request)) {\r\n            self.request = self.options.request;\r\n        }\r\n        if (Util.isFunction(self.options.parseResponse)) {\r\n            self.parseResponse = self.options.parseResponse;\r\n        }\r\n    }\r\n\r\n    async getElevation(options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (options.resolution === undefined) {\r\n            options.resolution = self.options.resolution;\r\n        }\r\n        if (options.sampleNumber === undefined) {\r\n            options.sampleNumber = self.options.sampleNumber;\r\n        }\r\n        const response = await self.request(options);\r\n        return (options.responseCallback || self.parseResponse).call(self, response, options);\r\n    }\r\n\r\n    async request(options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (options.dataInputs || options.body) {\r\n            const WPS = await import('../format/WPS');\r\n            const data = {\r\n                process: options.process || self.process,\r\n                dataInputs: options.dataInputs,\r\n                responseType: SITNA.Consts.mimeType.JSON,\r\n                version: options.serviceVersion || self.serviceVersion || '1.0.0',\r\n                output: options.output\r\n            };\r\n            const contentType = typeof options.contentType === 'boolean' ? options.contentType : options.contentType || SITNA.Consts.mimeType.XML;\r\n            const response = await TC.ajax({\r\n                url: self.url,\r\n                method: 'POST',\r\n                contentType: contentType,\r\n                responseType: SITNA.Consts.mimeType.JSON,\r\n                data: options.body || WPS.buildExecuteQuery(data)\r\n            });\r\n            return response.data;\r\n        }\r\n        else {\r\n            throw Error('Request is not valid for elevation service');\r\n        }\r\n    }\r\n\r\n    parseResponse(response, _options) {\r\n        var self = this;\r\n        if (response.coordinates) {\r\n            const coords = response.coordinates;\r\n            coords.forEach(function (coord) {\r\n                if (coord[2] < self.minimumElevation) {\r\n                    coord[2] = null;\r\n                }\r\n            });\r\n        }\r\n        return response.coordinates || [];\r\n    }\r\n\r\n    cancelRequest(_id) {\r\n\r\n    }\r\n}\r\n\r\nexport default ElevationService;","import TC from '../../TC';\r\nimport ElevationService from './ElevationService';\r\nimport Util from '../Util';\r\n\r\nlet proxificationTool;\r\n\r\nclass ElevationServiceIGNEs extends ElevationService {\r\n    constructor() {\r\n        super(...arguments);\r\n        const self = this;\r\n        self.url = self.options.url || '//servicios.idee.es/wcs-inspire/mdt';\r\n        self.minimumElevation = self.options.minimumElevation || -9998;\r\n        self.nativeCRS = 'EPSG:25830';\r\n    }\r\n\r\n    async request(options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (options.coordinates.length === 1) {\r\n            let point = options.coordinates[0];\r\n\r\n            if (options.crs && options.crs !== self.nativeCRS) {\r\n                point = Util.reproject(point, options.crs, self.nativeCRS);\r\n            }\r\n\r\n            let coverageName = 'Elevacion25830_5';\r\n            let coverageResolution = 3;\r\n            const halfRes1 = coverageResolution / 2;\r\n            const halfRes2 = coverageResolution - halfRes1;\r\n\r\n            const bbox = [\r\n                point[0] - halfRes1,\r\n                point[1] - halfRes1,\r\n                point[0] + halfRes2,\r\n                point[1] + halfRes2\r\n            ];\r\n            const requestUrl = self.url + '?SERVICE=WCS&REQUEST=GetCoverage&VERSION=2.0.1' +\r\n                '&SUBSET=' + encodeURIComponent('x,' + self.nativeCRS + '(' + bbox[0] + ',' + bbox[2] + ')') +\r\n                '&SUBSET=' + encodeURIComponent('y,' + self.nativeCRS + '(' + bbox[1] + ',' + bbox[3] + ')') +\r\n                '&COVERAGEID=' + encodeURIComponent(coverageName) +\r\n                '&RESOLUTION=x(1)' +\r\n                '&RESOLUTION=y(1)' +\r\n                '&FORMAT=' + encodeURIComponent('application/asc') +\r\n                '&EXCEPTIONS=XML';\r\n\r\n            if (!proxificationTool) {\r\n                const Proxification = (await import('./Proxification')).default;\r\n                proxificationTool = new Proxification(TC.proxify);\r\n            }\r\n            const response = await proxificationTool.fetch(requestUrl);\r\n            return response.responseText;\r\n        }\r\n\r\n        throw new Error('ign.es elevation service supports only points');\r\n    }\r\n\r\n    parseResponse(response, options) {\r\n        const self = this;\r\n        const lines = response.split('\\n');\r\n        const nColsLine = lines.find(line => line.indexOf('ncols') === 0);\r\n        const nCols = parseInt(nColsLine && nColsLine.substr(nColsLine.lastIndexOf(' ')));\r\n        const nRowsLine = lines.find(line => line.indexOf('nrows') === 0);\r\n        const nRows = parseInt(nColsLine && nRowsLine.substr(nRowsLine.lastIndexOf(' ')));\r\n        if (nCols && nRows) {\r\n            const xllCornerLine = lines.find(line => line.indexOf('xllcorner') === 0);\r\n            const x = parseFloat(xllCornerLine && xllCornerLine.substr(xllCornerLine.lastIndexOf(' ')));\r\n            const yllCornerLine = lines.find(line => line.indexOf('yllcorner') === 0);\r\n            const y = parseFloat(yllCornerLine && yllCornerLine.substr(yllCornerLine.lastIndexOf(' ')));\r\n            if (!isNaN(x) && !isNaN(y)) {\r\n                const cellSizeIndex = lines.findIndex(line => line.indexOf('cellsize') === 0);\r\n                let elevation = parseFloat(lines[cellSizeIndex + Math.round(nRows / 2)].trim().split(' ')[Math.round(nCols / 2) - 1]);\r\n                if (isNaN(elevation)) {\r\n                    elevation = null;\r\n                }\r\n                let point = options.coordinates[0].slice();\r\n                point[2] = elevation;\r\n                if (options.crs && options.crs !== self.nativeCRS) {\r\n                    point = Util.reproject(point, self.nativeCRS, options.crs);\r\n                }\r\n                return super.parseResponse.call(self, { coordinates: [point] }, options);\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default ElevationServiceIGNEs;"],"names":["constructor","options","self","this","url","process","minimumElevation","Util","request","parseResponse","async","undefined","resolution","sampleNumber","response","responseCallback","call","dataInputs","body","WPS","data","responseType","SITNA","Consts","mimeType","JSON","version","serviceVersion","output","contentType","XML","TC","method","buildExecuteQuery","Error","_options","coordinates","forEach","coord","cancelRequest","_id","proxificationTool","ElevationServiceIGNEs","ElevationService","super","arguments","nativeCRS","length","point","crs","coverageName","coverageResolution","halfRes1","halfRes2","bbox","requestUrl","encodeURIComponent","Proxification","default","fetch","responseText","lines","split","nColsLine","find","line","indexOf","nCols","parseInt","substr","lastIndexOf","nRowsLine","nRows","xllCornerLine","x","parseFloat","yllCornerLine","y","isNaN","cellSizeIndex","findIndex","elevation","Math","round","trim","slice"],"sourceRoot":""}