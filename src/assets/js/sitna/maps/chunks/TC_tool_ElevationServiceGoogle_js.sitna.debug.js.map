{"version":3,"file":"chunks/TC_tool_ElevationServiceGoogle_js.sitna.debug.js","mappings":";;;;;;;;;;;;;;;AAA0B;AACA;AAC1B;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA,kEAAkE,mBAAmB;AACrF,eAAe,QAAQ;AACvB,8EAA8E,mBAAmB;AACjG;AACA;AACA,eAAe,QAAQ,yGAAyG,mBAAmB;AACnJ,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAe;AAC3B;AACA;AACA,YAAY,wDAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8JAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gDAAO;AAC1C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,gBAAgB;;;;;;;;;;;;;;;;;;AC7FL;AACwB;AACvB;AACI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yDAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,uBAAuB,0DAAiB;AACxC;AACA;AACA,uBAAuB,6DAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA;AACA,2CAA2C,oDAAW,GAAG,aAAa,mCAAmC;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,6BAA6B,uDAAc;AAC3C;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAsB,GAAG,+DAAsB;AAC/D,gBAAgB,oEAA2B;AAC3C;AACA,YAAY,kDAAS;AACrB;AACA;AACA;AACA;AACA,8DAA8D,sBAAsB;AACpF;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAc;AAC7C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,sBAAsB","sources":["webpack://SITNA/./TC/tool/ElevationService.js","webpack://SITNA/./TC/tool/ElevationServiceGoogle.js"],"sourcesContent":["import TC from '../../TC';\r\nimport Util from '../Util'\r\n/**\r\n  * Opciones de servicio de obtención de elevaciones de puntos.\r\n  * @typedef ElevationServiceOptions\r\n  * @memberof SITNA\r\n  * @see SITNA.ElevationOptions\r\n  * @property {string[]} [allowedGeometryTypes] - Si se establece, indica para qué geometrías se van a hacer consultas \r\n  * de elevación al servicio. Esto es conveniente por ejemplo si el servicio solo permite obtener elevaciones de un punto simple,\r\n  * invalidándolo para la consulta si la geometría es un polígono o una línea. Los elementos del array tienen que ser cadenas \r\n  * cuyos valores deben ser los definidos por [SITNA.Consts.geom]{@link SITNA.Consts}.\r\n  * @property {string} [googleMapsKey] - Valor de una clave válida de la API de Google Maps. Solamente es necesaria cuando \r\n  * el valor de la propiedad `name` es [SITNA.Consts.elevationService.GOOGLE]{@link SITNA.Consts}.\r\n  *\r\n  * Puede obtener más información en el [sitio para desarrolladores de Google](https://developers.google.com/maps/documentation/javascript/get-api-key).\r\n  * @property {string} name - Nombre del servicio que queremos utilizar. Debe tener un valor de [SITNA.Consts.elevationService]{@link SITNA.Consts}.\r\n  * @property {string} [url] - URL del servicio. Cada servicio de elevaciones de puntos tiene asignada una URL por defecto, \r\n  * así que rara vez será necesario establecer esta propiedad.\r\n  */\r\n\r\nclass ElevationService { \r\n    constructor(options) {\r\n        const self = this;\r\n        self.options = options || {};\r\n        self.url = self.options.url;\r\n        self.process = self.options.process;\r\n        self.minimumElevation = self.options.minimumElevation;\r\n        if (Util.isFunction(self.options.request)) {\r\n            self.request = self.options.request;\r\n        }\r\n        if (Util.isFunction(self.options.parseResponse)) {\r\n            self.parseResponse = self.options.parseResponse;\r\n        }\r\n    }\r\n\r\n    async getElevation(options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (options.resolution === undefined) {\r\n            options.resolution = self.options.resolution;\r\n        }\r\n        if (options.sampleNumber === undefined) {\r\n            options.sampleNumber = self.options.sampleNumber;\r\n        }\r\n        const response = await self.request(options);\r\n        return (options.responseCallback || self.parseResponse).call(self, response, options);\r\n    }\r\n\r\n    async request(options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (options.dataInputs || options.body) {\r\n            const WPS = await import('../format/WPS');\r\n            const data = {\r\n                process: options.process || self.process,\r\n                dataInputs: options.dataInputs,\r\n                responseType: SITNA.Consts.mimeType.JSON,\r\n                version: options.serviceVersion || self.serviceVersion || '1.0.0',\r\n                output: options.output\r\n            };\r\n            const contentType = typeof options.contentType === 'boolean' ? options.contentType : options.contentType || SITNA.Consts.mimeType.XML;\r\n            const response = await TC.ajax({\r\n                url: self.url,\r\n                method: 'POST',\r\n                contentType: contentType,\r\n                responseType: SITNA.Consts.mimeType.JSON,\r\n                data: options.body || WPS.buildExecuteQuery(data)\r\n            });\r\n            return response.data;\r\n        }\r\n        else {\r\n            throw Error('Request is not valid for elevation service');\r\n        }\r\n    }\r\n\r\n    parseResponse(response, _options) {\r\n        var self = this;\r\n        if (response.coordinates) {\r\n            const coords = response.coordinates;\r\n            coords.forEach(function (coord) {\r\n                if (coord[2] < self.minimumElevation) {\r\n                    coord[2] = null;\r\n                }\r\n            });\r\n        }\r\n        return response.coordinates || [];\r\n    }\r\n\r\n    cancelRequest(_id) {\r\n\r\n    }\r\n}\r\n\r\nexport default ElevationService;","import TC from '../../TC';\r\nimport ElevationService from './ElevationService';\r\nimport Util from '../Util';\r\nimport Consts from '../Consts';\r\n\r\n// https://developers.google.com/maps/documentation/javascript/elevation?hl=es\r\n\r\nlet googleElevator;\r\nconst currentRequestIds = new Map();\r\n\r\nconst upRequestId = function (id, count) {\r\n    let currentCount = currentRequestIds.get(id) || 0;\r\n    currentCount += count;\r\n    currentRequestIds.set(id, currentCount);\r\n};\r\n\r\nconst downRequestId = function (id) {\r\n    let currentCount = currentRequestIds.get(id);\r\n    if (currentCount) {\r\n        currentCount -= 1;\r\n        if (currentCount <= 0) {\r\n            currentRequestIds.delete(id);\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nclass ElevationServiceGoogle extends ElevationService {\r\n    constructor() {\r\n        super(...arguments);\r\n        const self = this;\r\n        self.url = self.options.url || '//maps.googleapis.com/maps/api/js?v=3';\r\n        const intIdx = self.url.lastIndexOf('?');\r\n        if (intIdx < 0) {\r\n            self.url += '?';\r\n        }\r\n        else if (intIdx < self.url.length - 1) {\r\n            self.url += '&';\r\n        }\r\n\r\n        //ahora google pide en la url de google maps una función función global que se llamará una vez que la API de Maps JavaScript se cargue por completo.\r\n        let fnCallBackSV = \"SV_\" + (Math.random() + 1).toString(36).substring(7);\r\n\r\n        window[fnCallBackSV] = function () {\r\n            delete window[fnCallBackSV];\r\n        }\r\n\r\n        self.url += 'key=' + self.options.googleMapsKey + \"&callback=\" + fnCallBackSV;\r\n        self.minimumElevation = self.options.minimumElevation || -9998;\r\n        self.nativeCRS = 'EPSG:4326';\r\n        self.maxCoordinateCountPerRequest = 512;\r\n        self.minRetryInterval = 5100;\r\n        self.maxRetries = Number.isInteger(self.options.maxRetries) ? self.options.maxRetries : 0;\r\n    }\r\n\r\n    request(options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (!self.options.googleMapsKey) {\r\n            return Promise.reject(Error('Missing Google Maps key'));\r\n        }\r\n        const requestId = options.id;\r\n\r\n        const cancelledResponse = { status: 'CANCELLED' };\r\n        let geomType;\r\n        let coordinateList = options.coordinates;\r\n        if (coordinateList.length === 1) {\r\n            geomType = Consts.geom.POINT;\r\n        }\r\n        else {\r\n            geomType = Consts.geom.POLYLINE;\r\n        }\r\n\r\n        if (self.options.allowedGeometryTypes && !self.options.allowedGeometryTypes.includes(geomType)) {\r\n            return Promise.reject(Error(geomType + ' geometry type not allowed by configuration'));\r\n        }\r\n\r\n        if (coordinateList.length > self.maxCoordinateCountPerRequest) {\r\n            // Google no soporta tantos puntos por petición, dividimos la petición en varias\r\n            return new Promise(function (resolve, _reject) {\r\n                const chunks = [];\r\n                for (var i = 0, ii = coordinateList.length; i < ii; i += self.maxCoordinateCountPerRequest) {\r\n                    chunks.push(coordinateList.slice(i, i + self.maxCoordinateCountPerRequest));\r\n                }\r\n                upRequestId(requestId, chunks.length);\r\n                let retries = 0;\r\n                const subrequests = chunks.map(function subrequest(chunk) {\r\n                    const requestOptions = Util.extend({}, options, { coordinates: chunk, id: requestId });\r\n                    return new Promise(function (res, rej) {\r\n                        if (!currentRequestIds.has(requestId)) {\r\n                            res(cancelledResponse);\r\n                        }\r\n                        else {\r\n                            self.request(requestOptions)\r\n                                .then(function (result) {\r\n                                    if (result.status === 'OVER_QUERY_LIMIT') {\r\n                                        console.log(\"OVER_QUERY_LIMIT status reached for request \" + requestId);\r\n                                        if (!currentRequestIds.has(requestId)) {\r\n                                            res(cancelledResponse);\r\n                                        }\r\n                                        else {\r\n                                            // Peticiones demasiado seguidas: esperamos y volvemos a pedir\r\n                                            if (!self.maxRetries || retries < self.maxRetries) {\r\n                                                retries = retries + 1;\r\n                                                setTimeout(function () {\r\n                                                    subrequest(chunk)\r\n                                                        .then(r => res(r))\r\n                                                        .catch(e => rej(e));\r\n                                                }, self.minRetryInterval);\r\n                                            }\r\n                                            else {\r\n                                                res(result);\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        res(result);\r\n                                    }\r\n                                })\r\n                                .catch(e => rej(e));\r\n                        }\r\n                    });\r\n                });\r\n                Promise.all(subrequests).then(function mergeResponses(responses) {\r\n                    const results = Array.prototype.concat.apply([], responses\r\n                        .filter(r => r.status === 'OK')\r\n                        .map(r => r.elevations));\r\n                    downRequestId(requestId);\r\n                    resolve({\r\n                        status: 'OK',\r\n                        elevations: results\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        if (options.crs && options.crs !== self.nativeCRS) {\r\n            coordinateList = Util.reproject(coordinateList, options.crs, self.nativeCRS);\r\n        }\r\n\r\n        return new Promise(function (resolve, _reject) {\r\n            const googleMapsIsLoaded = window.google && window.google.maps;\r\n            if (!googleMapsIsLoaded) {\r\n                TC.Cfg.proxyExceptions = TC.Cfg.proxyExceptions || [];\r\n                TC.Cfg.proxyExceptions.push(self.url);\r\n            }\r\n            TC.loadJS(\r\n                !googleMapsIsLoaded,\r\n                self.url,\r\n                function () {\r\n                    googleElevator = googleElevator || new google.maps.ElevationService();\r\n                    const coords = coordinateList.map(p => ({ lat: p[1], lng: p[0] }));\r\n                    googleElevator.getElevationForLocations({\r\n                        locations: coords\r\n                    }, function (elevations, status) {\r\n                        downRequestId(requestId);\r\n                        resolve({\r\n                            elevations: elevations,\r\n                            status: status\r\n                        });\r\n                    });\r\n                },\r\n                false,\r\n                true\r\n            );\r\n        });\r\n    }\r\n\r\n    parseResponse(response, options) {\r\n        const self = this;\r\n        switch (response.status) {\r\n            case 'OK':\r\n                return response.elevations.map(function (r) {\r\n                    if (options.crs && options.crs !== self.nativeCRS) {\r\n                        return Util.reproject([r.location.lng(), r.location.lat()], self.nativeCRS, options.crs).concat(r.elevation);\r\n                    }\r\n                    else {\r\n                        return [r.location.lng(), r.location.lat(), r.elevation];\r\n                    }\r\n                });\r\n            //case 'OVER_DAILY_LIMIT':\r\n            //case 'OVER_QUERY_LIMIT':\r\n            //case 'REQUEST_DENIED':\r\n            //    self.serviceIsDisabled = true;\r\n            default:\r\n                return [];\r\n        }\r\n    }\r\n\r\n    cancelRequest(id) {\r\n        currentRequestIds.delete(id);\r\n    }\r\n}\r\n\r\nexport default ElevationServiceGoogle;"],"names":[],"sourceRoot":""}