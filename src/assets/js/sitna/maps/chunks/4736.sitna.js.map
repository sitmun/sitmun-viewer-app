{"version":3,"file":"chunks/4736.sitna.js","mappings":"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","sources":["webpack://SITNA/./TC/tool/ElevationService.js","webpack://SITNA/./TC/tool/ElevationServiceGoogle.js"],"sourcesContent":["import TC from '../../TC';\r\nimport Util from '../Util'\r\n/**\r\n  * Opciones de servicio de obtención de elevaciones de puntos.\r\n  * @typedef ElevationServiceOptions\r\n  * @memberof SITNA\r\n  * @see SITNA.ElevationOptions\r\n  * @property {string[]} [allowedGeometryTypes] - Si se establece, indica para qué geometrías se van a hacer consultas \r\n  * de elevación al servicio. Esto es conveniente por ejemplo si el servicio solo permite obtener elevaciones de un punto simple,\r\n  * invalidándolo para la consulta si la geometría es un polígono o una línea. Los elementos del array tienen que ser cadenas \r\n  * cuyos valores deben ser los definidos por [SITNA.Consts.geom]{@link SITNA.Consts}.\r\n  * @property {string} [googleMapsKey] - Valor de una clave válida de la API de Google Maps. Solamente es necesaria cuando \r\n  * el valor de la propiedad `name` es [SITNA.Consts.elevationService.GOOGLE]{@link SITNA.Consts}.\r\n  *\r\n  * Puede obtener más información en el [sitio para desarrolladores de Google](https://developers.google.com/maps/documentation/javascript/get-api-key).\r\n  * @property {string} name - Nombre del servicio que queremos utilizar. Debe tener un valor de [SITNA.Consts.elevationService]{@link SITNA.Consts}.\r\n  * @property {string} [url] - URL del servicio. Cada servicio de elevaciones de puntos tiene asignada una URL por defecto, \r\n  * así que rara vez será necesario establecer esta propiedad.\r\n  */\r\n\r\nclass ElevationService { \r\n    constructor(options) {\r\n        const self = this;\r\n        self.options = options || {};\r\n        self.url = self.options.url;\r\n        self.process = self.options.process;\r\n        self.minimumElevation = self.options.minimumElevation;\r\n        if (Util.isFunction(self.options.request)) {\r\n            self.request = self.options.request;\r\n        }\r\n        if (Util.isFunction(self.options.parseResponse)) {\r\n            self.parseResponse = self.options.parseResponse;\r\n        }\r\n    }\r\n\r\n    async getElevation(options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (options.resolution === undefined) {\r\n            options.resolution = self.options.resolution;\r\n        }\r\n        if (options.sampleNumber === undefined) {\r\n            options.sampleNumber = self.options.sampleNumber;\r\n        }\r\n        const response = await self.request(options);\r\n        return (options.responseCallback || self.parseResponse).call(self, response, options);\r\n    }\r\n\r\n    async request(options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (options.dataInputs || options.body) {\r\n            const WPS = await import('../format/WPS');\r\n            const data = {\r\n                process: options.process || self.process,\r\n                dataInputs: options.dataInputs,\r\n                responseType: SITNA.Consts.mimeType.JSON,\r\n                version: options.serviceVersion || self.serviceVersion || '1.0.0',\r\n                output: options.output\r\n            };\r\n            const contentType = typeof options.contentType === 'boolean' ? options.contentType : options.contentType || SITNA.Consts.mimeType.XML;\r\n            const response = await TC.ajax({\r\n                url: self.url,\r\n                method: 'POST',\r\n                contentType: contentType,\r\n                responseType: SITNA.Consts.mimeType.JSON,\r\n                data: options.body || WPS.buildExecuteQuery(data)\r\n            });\r\n            return response.data;\r\n        }\r\n        else {\r\n            throw Error('Request is not valid for elevation service');\r\n        }\r\n    }\r\n\r\n    parseResponse(response, _options) {\r\n        var self = this;\r\n        if (response.coordinates) {\r\n            const coords = response.coordinates;\r\n            coords.forEach(function (coord) {\r\n                if (coord[2] < self.minimumElevation) {\r\n                    coord[2] = null;\r\n                }\r\n            });\r\n        }\r\n        return response.coordinates || [];\r\n    }\r\n\r\n    cancelRequest(_id) {\r\n\r\n    }\r\n}\r\n\r\nexport default ElevationService;","import TC from '../../TC';\r\nimport ElevationService from './ElevationService';\r\nimport Util from '../Util';\r\nimport Consts from '../Consts';\r\n\r\n// https://developers.google.com/maps/documentation/javascript/elevation?hl=es\r\n\r\nlet googleElevator;\r\nconst currentRequestIds = new Map();\r\n\r\nconst upRequestId = function (id, count) {\r\n    let currentCount = currentRequestIds.get(id) || 0;\r\n    currentCount += count;\r\n    currentRequestIds.set(id, currentCount);\r\n};\r\n\r\nconst downRequestId = function (id) {\r\n    let currentCount = currentRequestIds.get(id);\r\n    if (currentCount) {\r\n        currentCount -= 1;\r\n        if (currentCount <= 0) {\r\n            currentRequestIds.delete(id);\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nclass ElevationServiceGoogle extends ElevationService {\r\n    constructor() {\r\n        super(...arguments);\r\n        const self = this;\r\n        self.url = self.options.url || '//maps.googleapis.com/maps/api/js?v=3';\r\n        const intIdx = self.url.lastIndexOf('?');\r\n        if (intIdx < 0) {\r\n            self.url += '?';\r\n        }\r\n        else if (intIdx < self.url.length - 1) {\r\n            self.url += '&';\r\n        }\r\n\r\n        //ahora google pide en la url de google maps una función función global que se llamará una vez que la API de Maps JavaScript se cargue por completo.\r\n        let fnCallBackSV = \"SV_\" + (Math.random() + 1).toString(36).substring(7);\r\n\r\n        window[fnCallBackSV] = function () {\r\n            delete window[fnCallBackSV];\r\n        }\r\n\r\n        self.url += 'key=' + self.options.googleMapsKey + \"&callback=\" + fnCallBackSV;\r\n        self.minimumElevation = self.options.minimumElevation || -9998;\r\n        self.nativeCRS = 'EPSG:4326';\r\n        self.maxCoordinateCountPerRequest = 512;\r\n        self.minRetryInterval = 5100;\r\n        self.maxRetries = Number.isInteger(self.options.maxRetries) ? self.options.maxRetries : 0;\r\n    }\r\n\r\n    request(options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (!self.options.googleMapsKey) {\r\n            return Promise.reject(Error('Missing Google Maps key'));\r\n        }\r\n        const requestId = options.id;\r\n\r\n        const cancelledResponse = { status: 'CANCELLED' };\r\n        let geomType;\r\n        let coordinateList = options.coordinates;\r\n        if (coordinateList.length === 1) {\r\n            geomType = Consts.geom.POINT;\r\n        }\r\n        else {\r\n            geomType = Consts.geom.POLYLINE;\r\n        }\r\n\r\n        if (self.options.allowedGeometryTypes && !self.options.allowedGeometryTypes.includes(geomType)) {\r\n            return Promise.reject(Error(geomType + ' geometry type not allowed by configuration'));\r\n        }\r\n\r\n        if (coordinateList.length > self.maxCoordinateCountPerRequest) {\r\n            // Google no soporta tantos puntos por petición, dividimos la petición en varias\r\n            return new Promise(function (resolve, _reject) {\r\n                const chunks = [];\r\n                for (var i = 0, ii = coordinateList.length; i < ii; i += self.maxCoordinateCountPerRequest) {\r\n                    chunks.push(coordinateList.slice(i, i + self.maxCoordinateCountPerRequest));\r\n                }\r\n                upRequestId(requestId, chunks.length);\r\n                let retries = 0;\r\n                const subrequests = chunks.map(function subrequest(chunk) {\r\n                    const requestOptions = Util.extend({}, options, { coordinates: chunk, id: requestId });\r\n                    return new Promise(function (res, rej) {\r\n                        if (!currentRequestIds.has(requestId)) {\r\n                            res(cancelledResponse);\r\n                        }\r\n                        else {\r\n                            self.request(requestOptions)\r\n                                .then(function (result) {\r\n                                    if (result.status === 'OVER_QUERY_LIMIT') {\r\n                                        console.log(\"OVER_QUERY_LIMIT status reached for request \" + requestId);\r\n                                        if (!currentRequestIds.has(requestId)) {\r\n                                            res(cancelledResponse);\r\n                                        }\r\n                                        else {\r\n                                            // Peticiones demasiado seguidas: esperamos y volvemos a pedir\r\n                                            if (!self.maxRetries || retries < self.maxRetries) {\r\n                                                retries = retries + 1;\r\n                                                setTimeout(function () {\r\n                                                    subrequest(chunk)\r\n                                                        .then(r => res(r))\r\n                                                        .catch(e => rej(e));\r\n                                                }, self.minRetryInterval);\r\n                                            }\r\n                                            else {\r\n                                                res(result);\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        res(result);\r\n                                    }\r\n                                })\r\n                                .catch(e => rej(e));\r\n                        }\r\n                    });\r\n                });\r\n                Promise.all(subrequests).then(function mergeResponses(responses) {\r\n                    const results = Array.prototype.concat.apply([], responses\r\n                        .filter(r => r.status === 'OK')\r\n                        .map(r => r.elevations));\r\n                    downRequestId(requestId);\r\n                    resolve({\r\n                        status: 'OK',\r\n                        elevations: results\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        if (options.crs && options.crs !== self.nativeCRS) {\r\n            coordinateList = Util.reproject(coordinateList, options.crs, self.nativeCRS);\r\n        }\r\n\r\n        return new Promise(function (resolve, _reject) {\r\n            const googleMapsIsLoaded = window.google && window.google.maps;\r\n            if (!googleMapsIsLoaded) {\r\n                TC.Cfg.proxyExceptions = TC.Cfg.proxyExceptions || [];\r\n                TC.Cfg.proxyExceptions.push(self.url);\r\n            }\r\n            TC.loadJS(\r\n                !googleMapsIsLoaded,\r\n                self.url,\r\n                function () {\r\n                    googleElevator = googleElevator || new google.maps.ElevationService();\r\n                    const coords = coordinateList.map(p => ({ lat: p[1], lng: p[0] }));\r\n                    googleElevator.getElevationForLocations({\r\n                        locations: coords\r\n                    }, function (elevations, status) {\r\n                        downRequestId(requestId);\r\n                        resolve({\r\n                            elevations: elevations,\r\n                            status: status\r\n                        });\r\n                    });\r\n                },\r\n                false,\r\n                true\r\n            );\r\n        });\r\n    }\r\n\r\n    parseResponse(response, options) {\r\n        const self = this;\r\n        switch (response.status) {\r\n            case 'OK':\r\n                return response.elevations.map(function (r) {\r\n                    if (options.crs && options.crs !== self.nativeCRS) {\r\n                        return Util.reproject([r.location.lng(), r.location.lat()], self.nativeCRS, options.crs).concat(r.elevation);\r\n                    }\r\n                    else {\r\n                        return [r.location.lng(), r.location.lat(), r.elevation];\r\n                    }\r\n                });\r\n            //case 'OVER_DAILY_LIMIT':\r\n            //case 'OVER_QUERY_LIMIT':\r\n            //case 'REQUEST_DENIED':\r\n            //    self.serviceIsDisabled = true;\r\n            default:\r\n                return [];\r\n        }\r\n    }\r\n\r\n    cancelRequest(id) {\r\n        currentRequestIds.delete(id);\r\n    }\r\n}\r\n\r\nexport default ElevationServiceGoogle;"],"names":["constructor","options","self","this","url","process","minimumElevation","Util","request","parseResponse","async","undefined","resolution","sampleNumber","response","responseCallback","call","dataInputs","body","WPS","data","responseType","SITNA","Consts","mimeType","JSON","version","serviceVersion","output","contentType","XML","TC","method","buildExecuteQuery","Error","_options","coordinates","forEach","coord","cancelRequest","_id","googleElevator","currentRequestIds","Map","downRequestId","id","currentCount","get","delete","ElevationServiceGoogle","ElevationService","super","arguments","intIdx","lastIndexOf","length","fnCallBackSV","Math","random","toString","substring","window","googleMapsKey","nativeCRS","maxCoordinateCountPerRequest","minRetryInterval","maxRetries","Number","isInteger","Promise","reject","requestId","cancelledResponse","status","geomType","coordinateList","allowedGeometryTypes","includes","resolve","_reject","chunks","i","ii","push","slice","count","set","upRequestId","retries","subrequests","map","subrequest","chunk","requestOptions","res","rej","has","then","result","console","log","setTimeout","r","catch","e","all","responses","results","Array","prototype","concat","apply","filter","elevations","crs","googleMapsIsLoaded","google","maps","coords","p","lat","lng","getElevationForLocations","locations","location","elevation"],"sourceRoot":""}