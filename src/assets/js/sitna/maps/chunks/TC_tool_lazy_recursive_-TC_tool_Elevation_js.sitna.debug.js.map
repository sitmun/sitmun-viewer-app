{"version":3,"file":"chunks/TC_tool_lazy_recursive_-TC_tool_Elevation_js.sitna.debug.js","mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5E0B;AACK;AACJ;AACQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;AACA,gEAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0CAA0C,gDAAgD,mBAAmB,yCAAyC,mBAAmB,yCAAyC,mBAAmB;AACnP,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA,gDAAO,GAAG,gDAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAA6B;AACrC,QAAQ,uEAA8B;AACtC,QAAQ,uEAA8B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,YAAY,2DAAO,IAAI,WAAW,CAAC;AACnC;AACA,gBAAgB,gDAAO;AACvB;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAe;AAC3B;AACA;AACA;AACA;AACA,2BAA2B,6DAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,oBAAoB,yDAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,oBAAoB,yDAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8DAAqB;AAChC;AACA;AACA,0DAAiB;AACjB,iEAAe,SAAS,EAAC","sources":["webpack://SITNA/./TC/tool/ lazy ^\\.\\/.*$ namespace object","webpack://SITNA/./TC/tool/Elevation.js"],"sourcesContent":["var map = {\n\t\"./Elevation\": [\n\t\t\"./TC/tool/Elevation.js\"\n\t],\n\t\"./Elevation.js\": [\n\t\t\"./TC/tool/Elevation.js\"\n\t],\n\t\"./ElevationService\": [\n\t\t\"./TC/tool/ElevationService.js\",\n\t\t\"TC_tool_ElevationService_js\"\n\t],\n\t\"./ElevationService.js\": [\n\t\t\"./TC/tool/ElevationService.js\",\n\t\t\"TC_tool_ElevationService_js\"\n\t],\n\t\"./ElevationServiceGoogle\": [\n\t\t\"./TC/tool/ElevationServiceGoogle.js\",\n\t\t\"TC_tool_ElevationServiceGoogle_js\"\n\t],\n\t\"./ElevationServiceGoogle.js\": [\n\t\t\"./TC/tool/ElevationServiceGoogle.js\",\n\t\t\"TC_tool_ElevationServiceGoogle_js\"\n\t],\n\t\"./ElevationServiceIDENA\": [\n\t\t\"./TC/tool/ElevationServiceIDENA.js\",\n\t\t\"TC_tool_ElevationServiceIDENA_js\"\n\t],\n\t\"./ElevationServiceIDENA.js\": [\n\t\t\"./TC/tool/ElevationServiceIDENA.js\",\n\t\t\"TC_tool_ElevationServiceIDENA_js\"\n\t],\n\t\"./ElevationServiceIGNEs\": [\n\t\t\"./TC/tool/ElevationServiceIGNEs.js\",\n\t\t\"TC_tool_ElevationServiceIGNEs_js\"\n\t],\n\t\"./ElevationServiceIGNEs.js\": [\n\t\t\"./TC/tool/ElevationServiceIGNEs.js\",\n\t\t\"TC_tool_ElevationServiceIGNEs_js\"\n\t],\n\t\"./ElevationServiceIGNFr\": [\n\t\t\"./TC/tool/ElevationServiceIGNFr.js\",\n\t\t\"TC_tool_ElevationServiceIGNFr_js\"\n\t],\n\t\"./ElevationServiceIGNFr.js\": [\n\t\t\"./TC/tool/ElevationServiceIGNFr.js\",\n\t\t\"TC_tool_ElevationServiceIGNFr_js\"\n\t],\n\t\"./ExcelExport\": [\n\t\t\"./TC/tool/ExcelExport.js\"\n\t],\n\t\"./ExcelExport.js\": [\n\t\t\"./TC/tool/ExcelExport.js\"\n\t],\n\t\"./Proxification\": [\n\t\t\"./TC/tool/Proxification.js\"\n\t],\n\t\"./Proxification.js\": [\n\t\t\"./TC/tool/Proxification.js\"\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn Promise.all(ids.slice(1).map(__webpack_require__.e)).then(() => {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = \"./TC/tool lazy recursive ^\\\\.\\\\/.*$\";\nmodule.exports = webpackAsyncContext;","import TC from '../../TC';\r\nimport Consts from '../Consts';\r\nimport Util from '../Util';\r\nimport Geometry from '../Geometry';\r\n\r\n/**\r\n * Colección de identificadores de servicios para obtener elevaciones de puntos.\r\n * @member elevationService\r\n * @memberof SITNA.Consts\r\n * @readonly\r\n * @property {string} GOOGLE - Identificador del servicio de elevación de la API de Google Maps.\r\n * @property {string} IDENA - Identificador del servicio de elevación de IDENA.\r\n * @property {string} IGN_ES - Identificador del servicio de elevación del Instituto Geográfico Nacional de España.\r\n * @property {string} IGN_FR - Identificador del servicio de elevación del Instituto Geográfico Nacional Francés.\r\n * @see SITNA.ElevationOptions\r\n */\r\nConsts.elevationService = {\r\n    GOOGLE: 'elevationServiceGoogle',\r\n    IDENA: 'elevationServiceIDENA',\r\n    IGN_ES: 'elevationServiceIGNEs',\r\n    IGN_FR: 'elevationServiceIGNFr'\r\n};\r\n\r\n/**\r\n * Opciones de la herramienta de elevación.\r\n * @typedef ElevationOptions\r\n * @memberof SITNA\r\n * @see SITNA.control.DrawMeasureModifyOptions\r\n * @property {number} [resolution] - Distancia máxima en metros entre puntos con elevaciones. \r\n * Si la distancia entre vértices de la geometría de la que queremos obtener los valores de elevación es mayor \r\n * que este valor, se añaden puntos intermedios hasta que esa distancia sea menor o igual a este valor.\r\n * @property {number} [sampleNumber] - Número total de puntos de la geometría con elevación.\r\n * \r\n * Si la geometría tiene más puntos que el valor de esta propiedad, se elminarán de manera repartida los \r\n * puntos sobrantes.\r\n * \r\n * Si la geometría tiene menos puntos que este valor, se insertarán puntos de manera repartida a lo largo de la geometría.\r\n * \r\n * Si esta propiedad entra en conflicto con la propiedad `resolution`, prevalece `resolution`.\r\n * @property {string[]|SITNA.ElevationServiceOptions[]} [services=[SITNA.Consts.elevationService.IDENA]{@link SITNA.Consts}, [SITNA.Consts.elevationService.IGN_FR]{@link SITNA.Consts}, [SITNA.Consts.elevationService.IGN_ES]{@link SITNA.Consts}] - Lista priorizada con identificadores de servicio de elevación\r\n * (miembros de [SITNA.Consts.elevationService]{@link SITNA.Consts}) u objetos de configuración de servicio a los que se consulta para obtener el dato de elevación.\r\n * Si varios servicios devuelven un valor válido para un punto, se toma el valor del servicio que esté representado antes en esta lista.\r\n */\r\n\r\nTC.tool = TC.tool || {};\r\n\r\nconst Elevation = function (options) {\r\n    const self = this;\r\n    self.options = options || {};\r\n    self._servicePromises = [];\r\n    const serviceOptions = self.options.services || [\r\n        Consts.elevationService.IDENA,\r\n        Consts.elevationService.IGN_FR,\r\n        Consts.elevationService.IGN_ES/*,\r\n        Consts.elevationService.GOOGLE*/\r\n    ];      \r\n\r\n    serviceOptions.forEach(function (srv, idx) {\r\n        self._servicePromises[idx] = new Promise(function (resolve, _reject) {\r\n            const serviceName = typeof srv === 'string' ? srv : srv.name;\r\n            const ctorName = serviceName.substr(0, 1).toUpperCase() + serviceName.substr(1);\r\n            \r\n            const srvOptions = typeof srv === 'string' ? {} : srv;\r\n            import('./' + ctorName).then(function (elevationModule) {\r\n                const ElevationService = elevationModule.default;\r\n                TC.tool[ctorName] = ElevationService;\r\n                resolve(new ElevationService(srvOptions));\r\n            });\r\n        });\r\n    });\r\n};\r\n\r\n(function () {\r\n    const toolProto = Elevation.prototype;\r\n\r\n    let requestUID = 1;\r\n    const getRequestUID = function () {\r\n        const result = requestUID.toString();\r\n        requestUID++;\r\n        return result;\r\n    };\r\n\r\n    toolProto.getService = function (idx) {\r\n        return this._servicePromises[idx];\r\n    };\r\n\r\n    toolProto.getServices = function () {\r\n        return Promise.all(this._servicePromises);\r\n    };\r\n\r\n    toolProto.getElevation = async function (options) {\r\n        const self = this;\r\n        const opts = Object.assign({}, options);\r\n        opts.id = getRequestUID();\r\n        if (opts.resolution === undefined) {\r\n            opts.resolution = self.options.resolution;\r\n        }\r\n        if (opts.sampleNumber === undefined) {\r\n            opts.sampleNumber = self.options.sampleNumber;\r\n        }\r\n        let done = false;\r\n        let partialResult;\r\n        let partialCallback;\r\n        if (Util.isFunction(opts.partialCallback)) {\r\n            partialCallback = opts.partialCallback;\r\n        }\r\n\r\n        const isSinglePoint = opts.coordinates.length === 1;\r\n        opts.coordinates = Geometry.interpolate(opts.coordinates, opts);\r\n        opts.resolution = 0;\r\n        opts.sampleNumber = 0;\r\n\r\n        partialResult = opts.coordinates.map(p => [p[0], p[1], null]);\r\n\r\n        if (!Object.prototype.hasOwnProperty.call(opts, 'includeHeights')) {\r\n            opts.includeHeights = isSinglePoint;\r\n        }\r\n        const services = await self.getServices();\r\n        const responses = new Array(services.length);\r\n        responses.fill(false);\r\n        for (var i = 0, ii = services.length; i < ii; i++) {\r\n            const idx = i;\r\n            const srv = services[i];\r\n\r\n            // Creamos una promesa que se resuelve falle o no la petición\r\n            const request = async function () {\r\n                if (navigator.onLine) {\r\n                    try {\r\n                        const response = await srv.request(opts);\r\n                        if (done) {\r\n                            return null; // Ya no escuchamos a esta respuesta porque hemos terminado el proceso antes\r\n                        }\r\n                        else {\r\n                            return srv.parseResponse(response, opts);\r\n                        }\r\n                    }\r\n                    catch (_e) {\r\n                        return null;\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n            let response;\r\n            try {\r\n                response = await request();\r\n            }\r\n            catch (error) {\r\n                console.error(error);\r\n            }\r\n\r\n            if (!done) {\r\n                responses[idx] = response;\r\n                if (response === null) {\r\n                    // Respuesta fallida. Comprobamos si han fallado todas para terminar.\r\n                    if (responses.every(r => r === null)) {\r\n                        throw Error('No services available');\r\n                    }\r\n                }\r\n                else {\r\n                    if (self._updatePartialResult(partialResult, responses)) {\r\n                        done = true;\r\n                    }\r\n                    if (partialCallback) {\r\n                        partialCallback(partialResult);\r\n                    }\r\n                }\r\n                if (done) {\r\n                    responses.forEach((r, ri) => r === false && services[ri].cancelRequest(options.id));\r\n                    return partialResult.some(p => p[2] !== null) ? partialResult : [];\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    toolProto.setGeometry = async function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        const features = options.features || [];\r\n\r\n        if (features.length) {\r\n\r\n            const conditionToPromises = function (promises, resolve, reject) {\r\n                Promise.all(promises).then(\r\n                    function (results) {\r\n                        resolve(results);\r\n                    },\r\n                    function (error) {\r\n                        reject(error);\r\n                    }\r\n                );\r\n            };\r\n\r\n            if (options.maxCoordQuantity) {\r\n                if (options.resolution) {\r\n                    // Validador de número de coordenadas máximo\r\n                    const numPoints = features.reduce(function (acc, feat) {\r\n                        if (feat) {\r\n                            acc = acc + feat.getCoords({ pointArray: true }).length;\r\n                            switch (true) {\r\n                                case SITNA.feature.Polyline && feat instanceof SITNA.feature.Polyline:\r\n                                case SITNA.feature.Polygon && feat instanceof SITNA.feature.Polygon:\r\n                                case SITNA.feature.MultiPolyline && feat instanceof SITNA.feature.MultiPolyline:\r\n                                case SITNA.feature.MultiPolygon && feat instanceof SITNA.feature.MultiPolygon:\r\n                                    acc = acc + Math.floor(feat.getLength() / options.resolution);\r\n                                    break;\r\n                                default:\r\n                                    break;\r\n                            }\r\n                        }\r\n                        return acc;\r\n                    }, 0);\r\n                    if (numPoints > options.maxCoordQuantity) {\r\n                        throw Error(Elevation.errors.MAX_COORD_QUANTITY_EXCEEDED);\r\n                    }\r\n                }\r\n            }\r\n            const resolution = options.resolution || 0;\r\n            const getElevOptions = function (coords) {\r\n                return {\r\n                    crs: options.crs,\r\n                    coordinates: coords,\r\n                    resolution: resolution,\r\n                    sampleNumber: 0\r\n                };\r\n            };\r\n            const getRingElevPromises = function (ring) {\r\n                return self.getElevation(getElevOptions(ring));\r\n            };\r\n            const coordPromises = features.map(function (feature) {\r\n                return new Promise(function (res, rej) {\r\n\r\n                    switch (true) {\r\n                        case !feature:\r\n                            res(null);\r\n                            break;\r\n                        case SITNA.feature && SITNA.feature.MultiPolygon && feature instanceof SITNA.feature.MultiPolygon: {\r\n                            const polPromises = feature\r\n                                .getCoords()\r\n                                .map(function (polygon) {\r\n                                    return new Promise(function (rs, rj) {\r\n                                        conditionToPromises(polygon.map(getRingElevPromises), rs, rj);\r\n                                    });\r\n                                });\r\n                            conditionToPromises(polPromises, res, rej);\r\n                            break;\r\n                        }\r\n                        case SITNA.feature && SITNA.feature.Polygon && feature instanceof SITNA.feature.Polygon:\r\n                        case SITNA.feature && SITNA.feature.MultiPolyline && feature instanceof SITNA.feature.MultiPolyline: {\r\n                            const ringPromises = feature\r\n                                .getCoords()\r\n                                .map(getRingElevPromises);\r\n                            conditionToPromises(ringPromises, res, rej);\r\n                            break;\r\n                        }\r\n                        case SITNA.feature && SITNA.feature.Polyline && feature instanceof SITNA.feature.Polyline:\r\n                            self.getElevation(getElevOptions(feature.getCoords())).then(\r\n                                function (coords) {\r\n                                    res(coords);\r\n                                },\r\n                                function (error) {\r\n                                    rej(Error(error));\r\n                                }\r\n                            );\r\n                            break;\r\n                        case SITNA.feature && SITNA.feature.Point && feature instanceof SITNA.feature.Point:\r\n                            self.getElevation(getElevOptions([feature.getCoords()])).then(\r\n                                function (coords) {\r\n                                    res(coords[0]);\r\n                                },\r\n                                function (error) {\r\n                                    rej(Error(error));\r\n                                }\r\n                            );\r\n                            break;\r\n                        default:\r\n                            rej(Error(\"Geometry not supported\"));\r\n                            break;\r\n                    }\r\n                });\r\n            });\r\n\r\n            const coordsArray = await Promise.all(coordPromises);\r\n            const copyElevation = function (source, target) {\r\n                if (Geometry.isPoint(source)) {\r\n                    target[2] = source[2];\r\n                    if (source.length > 3) {\r\n                        target[3] = source[3];\r\n                    }\r\n                }\r\n                else if (Array.isArray(source)) {\r\n                    source.forEach(function (node, idx) {\r\n                        copyElevation(node, target[idx]);\r\n                    });\r\n                }\r\n            };\r\n            const getNumVertices = function (coords) {\r\n                if (Geometry.isPoint(coords)) {\r\n                    return 1;\r\n                }\r\n                if (Array.isArray(coords)) {\r\n                    return coords.reduce((prev, cur) => prev + getNumVertices(cur), 0);\r\n                }\r\n                return 0;\r\n            };\r\n            coordsArray.forEach(function (coords, idx) {\r\n                const feat = features[idx];\r\n                if (feat) {\r\n                    if (TC.isDebug) {\r\n                        console.log(\"Estableciendo elevaciones a entidad:\", feat);\r\n                    }\r\n                    const featCoords = feat.getCoords();\r\n                    if (getNumVertices(featCoords) === getNumVertices(coords)) {\r\n                        copyElevation(coords, featCoords);\r\n                        feat.setCoordinates(featCoords);\r\n                    }\r\n                    else if (coords) {\r\n                        feat.setCoordinates(coords);\r\n                    }\r\n                }\r\n            });\r\n            return features;\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    };\r\n\r\n    toolProto._updatePartialResult = function (coordinates, responses) {\r\n        let done = false;\r\n        let pending = false;\r\n        for (var i = 0, ii = coordinates.length; i < ii; i++) {\r\n            const point = coordinates[i];\r\n            let elevation = null;\r\n            let height = null;\r\n            const validResponses = responses.filter(r => r !== null);\r\n            for (var j = 0, jj = validResponses.length; j < jj; j++) {\r\n                const r = validResponses[j];\r\n                if (r === false) {\r\n                    pending = true;\r\n                }\r\n                if (Array.isArray(r)) {\r\n                    const rPoint = r[i];\r\n                    if (elevation === null && rPoint) {\r\n                        elevation = rPoint[2];\r\n                        if (rPoint.length > 3 && height === null) {\r\n                            height = rPoint[3];\r\n                        }\r\n                    }\r\n                }\r\n                if (elevation !== null) {\r\n                    point[2] = elevation;\r\n                    if (height !== null) {\r\n                        point[3] = height;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // Condiciones para acabar:\r\n        // 1: Tengo todas las elevaciones y no hay peticiones más prioritarias pendientes\r\n        // 2: Han contestado todos los servicios\r\n        done = !pending && coordinates.every(p => p[2] !== null) || responses.every(r => r !== false);\r\n        return done;\r\n    };\r\n\r\n})();\r\n\r\nElevation.errors = {\r\n    MAX_COORD_QUANTITY_EXCEEDED: 'max_coord_quantity_exceeded',\r\n    UNDEFINED: 'undefined'\r\n};\r\n\r\nElevation.getElevationGain = function (options) {\r\n    return Util.getElevationGain(options);\r\n};\r\n\r\nTC.tool.Elevation = Elevation;\r\nexport default Elevation;\r\n"],"names":[],"sourceRoot":""}