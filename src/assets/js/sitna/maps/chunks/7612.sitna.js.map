{"version":3,"file":"chunks/7612.sitna.js","mappings":"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","sources":["webpack://SITNA/./TC/tool/ElevationService.js","webpack://SITNA/./TC/tool/ElevationServiceIDENA.js"],"sourcesContent":["import TC from '../../TC';\r\nimport Util from '../Util'\r\n/**\r\n  * Opciones de servicio de obtención de elevaciones de puntos.\r\n  * @typedef ElevationServiceOptions\r\n  * @memberof SITNA\r\n  * @see SITNA.ElevationOptions\r\n  * @property {string[]} [allowedGeometryTypes] - Si se establece, indica para qué geometrías se van a hacer consultas \r\n  * de elevación al servicio. Esto es conveniente por ejemplo si el servicio solo permite obtener elevaciones de un punto simple,\r\n  * invalidándolo para la consulta si la geometría es un polígono o una línea. Los elementos del array tienen que ser cadenas \r\n  * cuyos valores deben ser los definidos por [SITNA.Consts.geom]{@link SITNA.Consts}.\r\n  * @property {string} [googleMapsKey] - Valor de una clave válida de la API de Google Maps. Solamente es necesaria cuando \r\n  * el valor de la propiedad `name` es [SITNA.Consts.elevationService.GOOGLE]{@link SITNA.Consts}.\r\n  *\r\n  * Puede obtener más información en el [sitio para desarrolladores de Google](https://developers.google.com/maps/documentation/javascript/get-api-key).\r\n  * @property {string} name - Nombre del servicio que queremos utilizar. Debe tener un valor de [SITNA.Consts.elevationService]{@link SITNA.Consts}.\r\n  * @property {string} [url] - URL del servicio. Cada servicio de elevaciones de puntos tiene asignada una URL por defecto, \r\n  * así que rara vez será necesario establecer esta propiedad.\r\n  */\r\n\r\nclass ElevationService { \r\n    constructor(options) {\r\n        const self = this;\r\n        self.options = options || {};\r\n        self.url = self.options.url;\r\n        self.process = self.options.process;\r\n        self.minimumElevation = self.options.minimumElevation;\r\n        if (Util.isFunction(self.options.request)) {\r\n            self.request = self.options.request;\r\n        }\r\n        if (Util.isFunction(self.options.parseResponse)) {\r\n            self.parseResponse = self.options.parseResponse;\r\n        }\r\n    }\r\n\r\n    async getElevation(options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (options.resolution === undefined) {\r\n            options.resolution = self.options.resolution;\r\n        }\r\n        if (options.sampleNumber === undefined) {\r\n            options.sampleNumber = self.options.sampleNumber;\r\n        }\r\n        const response = await self.request(options);\r\n        return (options.responseCallback || self.parseResponse).call(self, response, options);\r\n    }\r\n\r\n    async request(options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (options.dataInputs || options.body) {\r\n            const WPS = await import('../format/WPS');\r\n            const data = {\r\n                process: options.process || self.process,\r\n                dataInputs: options.dataInputs,\r\n                responseType: SITNA.Consts.mimeType.JSON,\r\n                version: options.serviceVersion || self.serviceVersion || '1.0.0',\r\n                output: options.output\r\n            };\r\n            const contentType = typeof options.contentType === 'boolean' ? options.contentType : options.contentType || SITNA.Consts.mimeType.XML;\r\n            const response = await TC.ajax({\r\n                url: self.url,\r\n                method: 'POST',\r\n                contentType: contentType,\r\n                responseType: SITNA.Consts.mimeType.JSON,\r\n                data: options.body || WPS.buildExecuteQuery(data)\r\n            });\r\n            return response.data;\r\n        }\r\n        else {\r\n            throw Error('Request is not valid for elevation service');\r\n        }\r\n    }\r\n\r\n    parseResponse(response, _options) {\r\n        var self = this;\r\n        if (response.coordinates) {\r\n            const coords = response.coordinates;\r\n            coords.forEach(function (coord) {\r\n                if (coord[2] < self.minimumElevation) {\r\n                    coord[2] = null;\r\n                }\r\n            });\r\n        }\r\n        return response.coordinates || [];\r\n    }\r\n\r\n    cancelRequest(_id) {\r\n\r\n    }\r\n}\r\n\r\nexport default ElevationService;","import TC from '../../TC';\r\nimport ElevationService from './ElevationService';\r\nimport Consts from '../Consts';\r\n\r\nclass ElevationServiceIDENA extends ElevationService {\r\n    constructor() {\r\n        super(...arguments);\r\n        const self = this;\r\n        self.url = self.options.url || '//idena.navarra.es/ogc/wps';\r\n        self.process = self.options.process || 'gs:ExtractRasterPoints';\r\n        self.coverageClass = self.options.coverageClass || 'MDT_maxima_actualidad,Alturas_maxima_actualidad';\r\n        self.minimumElevation = self.options.minimumElevation || -9998;\r\n    }\r\n\r\n    request(options) {\r\n        const self = this;\r\n        options = options || {};\r\n        const geometryOptions = {\r\n            coordinates: options.coordinates,\r\n            type: Consts.geom.POLYLINE\r\n        };\r\n        if (options.coordinates.length === 1) {\r\n            geometryOptions.coordinates = options.coordinates[0];\r\n            geometryOptions.type = Consts.geom.POINT;\r\n        }\r\n        let coverageClass = options.coverageClass || self.coverageClass;\r\n        const sepIdx = coverageClass.indexOf(',');\r\n        if (coverageClass && sepIdx >= 0 && !options.includeHeights) {\r\n            coverageClass = coverageClass.substr(0, sepIdx);\r\n        }\r\n        const dataInputs = {\r\n            coverageClass: coverageClass,\r\n            geometry: {\r\n                mimeType: Consts.mimeType.JSON,\r\n                value: TC.wrap.Geometry.toGeoJSON(geometryOptions)\r\n            }\r\n        };\r\n        if (options.crs) {\r\n            var idx = options.crs.lastIndexOf(':');\r\n            if (idx < 0) {\r\n                idx = options.crs.lastIndexOf('#');\r\n            }\r\n            dataInputs.srid = options.crs.substr(idx + 1);\r\n        }\r\n        return super.request.call(self, { dataInputs: dataInputs }, options);\r\n    }\r\n\r\n    parseResponse(response, options) {\r\n        const self = this;\r\n        const coverageClass = options.coverageClass || self.coverageClass;\r\n        const coverageClassCount = options.includeHeights && coverageClass ? coverageClass.split(',').length : 1;\r\n        if (coverageClassCount <= 1) {\r\n            return super.parseResponse.call(self, response, options);\r\n        }\r\n        if (response.coordinates) {\r\n            const coords = response.coordinates;\r\n            const coordinateCount = coords.length / coverageClassCount;\r\n            const result = coords.slice(0, coordinateCount);\r\n            var i;\r\n            for (i = 0; i < coordinateCount; i++) {\r\n                const point = result[i];\r\n                if (point[2] < self.minimumElevation) {\r\n                    point[2] = null;\r\n                }\r\n            }\r\n            for (i = 1; i < coverageClassCount; i++) {\r\n                const offset = i * coordinateCount;\r\n                for (var j = 0; j < coordinateCount; j++) {\r\n                    const elevation = coords[j + offset][2];\r\n                    result[j].push(elevation < self.minimumElevation ? null : elevation);\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default ElevationServiceIDENA;"],"names":["constructor","options","self","this","url","process","minimumElevation","Util","request","parseResponse","async","undefined","resolution","sampleNumber","response","responseCallback","call","dataInputs","body","WPS","data","responseType","SITNA","Consts","mimeType","JSON","version","serviceVersion","output","contentType","XML","TC","method","buildExecuteQuery","Error","_options","coordinates","forEach","coord","cancelRequest","_id","ElevationServiceIDENA","ElevationService","super","arguments","coverageClass","geometryOptions","type","length","sepIdx","indexOf","includeHeights","substr","geometry","value","crs","idx","lastIndexOf","srid","coverageClassCount","split","coords","coordinateCount","result","slice","i","point","offset","j","elevation","push"],"sourceRoot":""}