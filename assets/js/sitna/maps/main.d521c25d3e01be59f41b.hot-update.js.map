{"version":3,"file":"main.d521c25d3e01be59f41b.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAkC;AACT;AACE;AACM;AACsB;AAChB;AACK;AACR;AACS;AACT;AACE;AACK;AACc;AACe;AACzB;AACG;AACC;AACL;AAC8D;AAC3E;AACgB;AACmE;AACxD;AACZ;AACI;AACM;AACA;AACH;AAChB;AACW;AACwD;AACxD;AACR;AACA;AAC1C,WAAW,mGAAmG;AAC1C;AAClC;AACA;AACE;AACwF;AAC7D;AACuB;AAC1C;AACJ;AACxC;AACmC;AAC4F;AAC1C;AACnD;AACO;AACe;AACV;AACuC;AACrF;AACoD;AACI;AACC;AACE;AACP;AACyC;AACtC;AACV;AAmB7B;AAYO;AACM;AAC7B;AAC0B;AACA;AACC;AACA;AACI;AACI;AACI;AACA;AACI;AACA;AACM;AACA;AACI;AACA;AAClB;AACnC;AACA,gDAAO,GAAG,6CAAI;AACd,gDAAO,GAAG,6CAAI;AACd,kDAAS,GAAG,gDAAM;AAClB,mDAAU,GAAG,iDAAS;AACtB,mDAAU,GAAG,mDAAU;AACvB,yDAAgB,GAAG,uDAAO;AAC1B,0DAAiB,GAAG,wDAAM;AAC1B,4DAAmB,GAAG,0DAAQ;AAC9B,2DAAkB,GAAG,yDAAS;AAC9B,8DAAqB,GAAG,4DAAY;AACpC,+DAAsB,GAAG,6DAAW;AACpC,iEAAwB,GAAG,+DAAa;AACxC,gEAAuB,GAAG,8DAAc;AACxC,oDAAW,GAAG,kDAAQ;AACtB;AACA;AACA,aAAa,6CAAO;AACpB,SAAS,+CAAG;AACZ,UAAU,gDAAI;AACd,aAAa,mDAAO;AACpB,wBAAwB,8DAAkB;AAC1C,uEAA2B,GAAG,4DAAmB;AACjD,aAAa,mDAAO;AACpB,gBAAgB,sDAAU;AAC1B,kBAAkB,wDAAY;AAC9B,yBAAyB,+DAAmB;AAC5C,WAAW,iDAAK;AAChB;AACA;AACA,YAAY,6CAAM;AAClB,cAAc,+CAAQ;AACtB;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA,aAAa,8CAAO;AACpB,cAAc,+CAAQ;AACtB;AACA;AACA;AACA,eAAe,+CAAS;AACxB;AACA;AACA;AACA,eAAe,iDAAS;AACxB;AACA;AACA;AACA,iBAAiB,mDAAW;AAC5B,eAAe,mDAAS;AACxB,UAAU,mDAAI;AACd,gBAAgB,8DAAU;AAC1B,kBAAkB,mDAAY;AAC9B;AACA;AACA;AACA,eAAe,4DAAW;AAC1B,YAAY,8CAAM;AAClB,mBAAmB,qDAAa;AAChC;AACA,sBAAsB,8DAAY;AAClC;AACA;AACA;AACA;AACA,cAAc,gDAAQ;AACtB,eAAe,iDAAS;AACxB,wBAAwB,0DAAkB;AAC1C,oBAAoB,sDAAc;AAClC,YAAY,8CAAM;AAClB,oBAAoB,sDAAc;AAClC;AACA;AACA;AACA,WAAW,gDAAK;AAChB,gBAAgB,gDAAU;AAC1B,gBAAgB,gDAAU;AAC1B,qBAAqB,gDAAe;AACpC,aAAa,gDAAO;AACpB,kBAAkB,gDAAY;AAC9B,wBAAwB,mEAAkB;AAC1C,YAAY,gDAAQ;AACpB,kBAAkB,6DAAY;AAC9B,oBAAoB,+DAAc;AAClC;AACA,4BAA4B,qEAAkB;AAC9C,4BAA4B,qEAAkB;AAC9C,0BAA0B,kEAAgB;AAC1C;AACA;AACA;AACA;AACA,SAAS,kDAAG;AACZ;AACA;AACA;AACA,aAAa,mDAAO;AACpB,aAAa,8DAAO;AACpB,SAAS,kDAAG;AACZ,UAAU,uDAAI;AACd,UAAU,uDAAI;AACd,WAAW,wDAAK;AAChB,SAAS,0DAAG;AACZ,SAAS,0DAAG;AACZ,SAAS,kDAAG;AACZ,SAAS,kDAAG;AACZ,aAAa,8DAAO;AACpB,qBAAqB,kDAAe;AACpC,uBAAuB,kDAAiB;AACxC,sBAAsB,kDAAgB;AACtC,cAAc,kDAAQ;AACtB;AACA,qBAAqB,uDAAW;AAChC,qBAAqB,uDAAW;AAChC,oBAAoB,sDAAU;AAC9B,6BAA6B,+DAAmB;AAChD,sBAAsB,wDAAY;AAClC,6BAA6B,+DAAmB;AAChD,2BAA2B,6DAAiB;AAC5C,8BAA8B,gEAAoB;AAClD,8BAA8B,gEAAoB;AAClD,yCAAyC,2EAA+B;AACxE;AACA;AACA,iDAAiD,+EAA4B;AAC7E;AACA;AACA,cAAc,qDAAQ;AACtB,UAAU,uDAAI;AACd,aAAa,uDAAO;AACpB,eAAe,uDAAS;AACxB,UAAU,uDAAI;AACd,YAAY,uDAAM;AAClB,YAAY,uDAAM;AAClB,iBAAiB,uEAAW;AAC5B,qBAAqB,uDAAe;AACpC;AACA;AACA;AACA,WAAW,iDAAK;AAChB,UAAU,iDAAI;AACd,WAAW,iDAAO;AAClB,YAAY,iDAAQ;AACpB,aAAa,iDAAO;AACpB;AACA;AACA;AACA,aAAa,mDAAO;AACpB;AACA;AACA,YAAY,kDAAU;AACtB;AACA;AACA,qBAAqB,oDAAe;AACpC,gBAAgB,+CAAU;AAC1B,8BAA8B,6DAAwB;AACtD,SAAS,wCAAG;AACZ,eAAe,8CAAS;AACxB,qBAAqB,oDAAe;AACpC,kBAAkB,iDAAY;AAC9B,WAAW,sDAAK;AAChB;AACA,kBAAkB,oDAAQ;AAC1B,KAAK;AACL;AACA,yBAAyB,8DAAiB;AAC1C,qBAAqB,0DAAW;AAChC;AACA;AACA;AACA;AACA,sBAAsB,wDAAgB;AACtC,eAAe,iDAAS;AACxB,eAAe,4DAAW;AAC1B;AACA;AACA;AACA,YAAY,kDAAQ;AACpB,aAAa,kDAAO;AACpB,cAAc,kDAAQ;AACtB,UAAU,kDAAI;AACd,mBAAmB,gEAAa;AAChC,qBAAqB,kEAAe;AACpC,iBAAiB,kDAAW;AAC5B;AACA;AACA,kCAAkC,sEAAwB;AAC1D,KAAK;AACL,mBAAmB,gEAAa;AAChC;AACA,yCAAyC,+DAAuB;AAChE;AACA;AACA,cAAc,8DAAQ;AACtB;AACA;AACA;AACA,WAAW,kDAAK;AAChB,kBAAkB,kDAAY;AAC9B,YAAY,kDAAQ;AACpB,UAAU,kDAAI;AACd,UAAU,kDAAI;AACd,YAAY,kDAAM;AAClB,UAAU,kDAAI;AACd,qBAAqB,kEAAe;AACpC,gBAAgB,6DAAU;AAC1B;AACA;AACA;AACA,WAAW,2CAAK;AAChB,eAAe,+CAAS;AACxB,qBAAqB,qDAAe;AACpC,qBAAqB,qDAAe;AACpC,yBAAyB,yDAAmB;AAC5C,qBAAqB,qDAAe;AACpC,uBAAuB,uDAAiB;AACxC,uBAAuB,uDAAiB;AACxC,kBAAkB,kDAAY;AAC9B,kBAAkB,kDAAY;AAC9B,qBAAqB,qDAAe;AACpC,uBAAuB,uDAAiB;AACxC,yBAAyB,yDAAmB;AAC5C,8BAA8B,8DAAwB;AACtD,2BAA2B,2DAAqB;AAChD,kCAAkC,kEAA4B;AAC9D,6BAA6B,6DAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAqD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kCAAkC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mDAAU;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mDAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6CAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAc,GAAG,iCAAiC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2EAA+B;AACtD,uBAAuB,2EAA+B;AACtD,uBAAuB,wEAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,2BAA2B,4EAAgC;AAC3D,2BAA2B,4EAAgC;AAC3D,2BAA2B,yEAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAA8B;AACrD,uBAAuB,4EAAgC;AACvD,uBAAuB,2EAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,2BAA2B,0EAA8B;AACzD,2BAA2B,4EAAgC;AAC3D,2BAA2B,2EAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6DAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mEAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qEAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6CAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,oBAAoB,gEAAuB;AAC3C;AACA;AACA;AACA,iCAAiC,gEAAuB;AACxD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oCAAoC,mCAAmC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qEAA4B,IAAI,+BAA+B;AACvG;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,wBAAwB,6BAA6B;AACrD;AACA,oCAAoC,uEAA8B,IAAI,kCAAkC;AACxG;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAoB;AACpD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gEAAuB;AAC3D;AACA,6CAA6C,UAAU;AACvD;AACA,kFAAkF;AAClF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mEAA0B;AACtD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8EAAqC;AACxD;AACA,0GAA0G,mEAA0B;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wEAA+B;AAC3D;AACA,aAAa;AACb;AACA,KAAK;AACL,mBAAmB,gEAAuB;AAC1C;AACA,KAAK;AACL;AACA;AACA;AACA,mCAAmC,kEAAyB;AAC5D;AACA;AACA;AACA;AACA,qCAAqC,gEAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oEAA2B;AACnE;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa,IAAI,4BAA4B;AAC7C;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D,4DAA4D,YAAY;AACxE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yEAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAA0B;AACzC;AACA;AACA;AACA;AACA,+EAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mDAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gEAAuB;AAC9C,4CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,0EAAiC;AACjC;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gEAAuB;AAC3E;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+DAAsB;AACtD;AACA;AACA,oCAAoC,0EAAiC,IAAI,oBAAoB;AAC7F;AACA;AACA;AACA,kCAAkC,+DAAsB;AACxD;AACA;AACA,wBAAwB,uEAA8B;AACtD;AACA,wBAAwB,iEAAwB,SAAS,sEAA6B;AACtF;AACA;AACA;AACA,oCAAoC,4DAAmB;AACvD,oCAAoC,oEAA2B,IAAI,oBAAoB;AACvF;AACA,SAAS;AACT;AACA;AACA;AACA,0EAAiC;AACjC;AACA;AACA;AACA,4EAAmC;AACnC;AACA;AACA;AACA,iFAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,4EAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,4EAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,yDAAyD;AACzD;AACA;AACA,qBAAqB;AACrB;AACA;AACA,kDAAkD,iEAAwB;AAC1E,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B,0EAAiC,EAAE;AAChG;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wEAA+B;AAC/B;AACA,QAAQ,2DAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,0EAAiC;AAC3E;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wEAA+B;AAC/B;AACA;AACA;AACA,wEAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,0EAAiC;AAC3E,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wEAA+B;AAC/B;AACA;AACA;AACA,4EAAmC;AACnC;AACA;AACA;AACA,4EAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,0EAAiC;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA,0EAAiC;AACjC;AACA;AACA;AACA,6EAAoC;AACpC;AACA;AACA;AACA,qFAA4C;AAC5C;AACA;AACA;AACA,qFAA4C;AAC5C;AACA;AACA;AACA,0EAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,wEAA+B;AAC/B;AACA;AACA;AACA;AACA,uEAA8B;AAC9B;AACA;AACA;AACA,oEAA2B;AAC3B;AACA;AACA;AACA;AACA,uEAA8B;AAC9B;AACA;AACA;AACA,QAAQ,kDAAS;AACjB;AACA,aAAa,uDAAc,GAAG,kEAAyB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,oEAA2B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,IAAI,eAAe;AAChD;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA,yEAAyE;AACzE;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wEAA+B;AAC/B;AACA;AACA;AACA,2CAA2C,kEAAyB;AACpE;AACA;AACA;AACA,yEAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,6DAAoB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gEAAuB;AACpC,aAAa,+DAAsB;AACnC,aAAa,6DAAoB;AACjC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa,gEAAuB;AACpC,aAAa,+DAAsB;AACnC;AACA,aAAa,oEAA2B;AACxC,aAAa,mEAA0B;AACvC,aAAa,gEAAuB;AACpC,aAAa,8DAAqB;AAClC;AACA,aAAa,8DAAqB;AAClC;AACA,aAAa,8DAAqB;AAClC;AACA,aAAa,+DAAsB;AACnC;AACA,aAAa,+DAAsB;AACnC,aAAa,6DAAoB;AACjC;AACA,aAAa,kEAAyB;AACtC;AACA,aAAa,6DAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,6EAAoC;AACpC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAc;AAC/C,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qDAAqD,+DAAsB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qCAAqC,+DAAsB;AAC3D;AACA;AACA;AACA;AACA,gFAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,2BAA2B,uDAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAS;AACnC;AACA,mBAAmB,sEAA6B;AAChD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uEAA8B;AAClE;AACA,wCAAwC,2EAAkC;AAC1E;AACA,qBAAqB;AACrB;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4EAAmC;AACvE;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qPAAwD;AACxE;AACA;AACA;AACA,4BAA4B,iDAAQ,MAAM,uEAA8B;AACxE;AACA,0DAA0D,UAAU,gBAAgB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,uEAA8B;AAClF,oDAAoD,qBAAqB;AACzE,4DAA4D,8EAAqC;AACjG;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,2CAA2C,uEAA8B;AACzE;AACA,4CAA4C,yBAAyB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,UAAU,mBAAmB;AACtG;AACA,kCAAkC;AAClC;AACA,iDAAiD,2BAA2B;AAC5E,oDAAoD,qCAAqC;AACzF,oCAAoC,iDAAQ,iDAAiD,uEAA8B;AAC3H;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qEAAqE,GAAG;AACxE;AACA,4DAA4D,GAAG,6DAA6D,GAAG;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4EAAmC;AACvF;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,4BAA4B,uNAA+B,eAAe,cAAc;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,4EAAmC;AAC/F;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,4EAAmC;AAC3F;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS,GAAG,MAAM;AACpE,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,yEAAyE,UAAU,sCAAsC;AACzH,iCAAiC;AACjC,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+DAAsB;AAC/D;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+DAAsB;AACvE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wEAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uEAA8B;AACtD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA,qEAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAAqC;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yEAAgC;AAChC;AACA;AACA;AACA,8EAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,sCAAsC,mEAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAA4B;AAC5B;AACA;AACA;AACA,YAAY,2DAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,uEAA8B;AAC9B;AACA;AACA,KAAK;AACL;AACA,YAAY,2DAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iFAAwC;AACxC;AACA,kFAAyC;AACzC;AACA,gFAAuC;AACvC;AACA;AACA;AACA,oCAAoC,wEAA+B;AACnE;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA,oFAA2C;AAC3C;AACA;AACA;AACA,aAAa,gEAAuB;AACpC;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iEAAwB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,8DAAqB;AACpG;AACA;AACA,wBAAwB,wCAAwC;AAChE;AACA;AACA,gCAAgC,oCAAoC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAA4C;AAC5C;AACA;AACA;AACA;AACA,wBAAwB,gDAAgD;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA,yBAAyB,wDAAe;AACxC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,KAAK;AACL;AACA;AACA;AACA,+EAAsC;AACtC;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,uCAAuC;AACvC;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0BAA0B;AAClE;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mGAAmG;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,wBAAwB,wCAAwC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA,iBAAiB,gEAAuB;AACxC;AACA;AACA,iBAAiB,iEAAwB;AACzC;AACA;AACA;AACA;AACA,uFAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAA+C;AAC/C;AACA;AACA,kCAAkC,gEAAuB;AACzD;AACA;AACA;AACA;AACA;AACA,+EAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAA4C;AAC5C;AACA;AACA;AACA,qFAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAA+C;AAC/C;AACA;AACA;AACA,iBAAiB,gEAAuB;AACxC;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iEAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAAiD;AACjD;AACA;AACA;AACA,6FAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAA2C;AAC3C;AACA;AACA;AACA;AACA,aAAa,gEAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iEAAwB;AACrC;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA,iCAAiC,8DAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,gEAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,EAAE;AACvC;AACA,iCAAiC;AACjC,yBAAyB;AACzB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA,aAAa,iEAAwB;AACrC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAAkD;AAClD;AACA;AACA;AACA;AACA,aAAa,gEAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iEAAwB;AACrC;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA,wBAAwB,8DAAqB;AAC7C;AACA;AACA,+DAA+D,QAAQ;AACvE;AACA,qEAAqE,QAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAAsD;AACtD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,iEAAwB;AAC1D;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA,yDAAyD,QAAQ;AACjE;AACA;AACA,gCAAgC,8DAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAiB;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2CAA2C,kBAAkB;AAC7D;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAwC;AACxC;AACA;AACA;AACA,oFAA2C;AAC3C;AACA,6BAA6B,iEAAwB;AACrD,sDAAsD,uDAAc,GAAG,yBAAyB,sBAAsB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yDAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA,uCAAuC;AACvC;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2DAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAc,SAAS,EAAE,sDAAa;AACzD;AACA,QAAQ,uDAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6EAAoC;AACxD;AACA,iBAAiB;AACjB;AACA;AACA,2BAA2B,+EAAsC;AACjE;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAc,SAAS,2GAA2G;AACnJ;AACA;AACA,iBAAiB,uDAAc,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yFAAyF,IAAI,6CAA6C;AAC1I,SAAS;AACT;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF,kDAAkD,oBAAoB;AACtE,eAAe;AACf,WAAW;AACX;AACA;AACA,uEAAuE,4BAA4B;AACnG;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,2DAAkB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAuC;AACvC;AACA;AACA;AACA,oFAA2C;AAC3C;AACA;AACA;AACA;AACA,iCAAiC,gEAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gEAAuB;AACxD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iFAAqC;AACrC;AACA,eAAe,uDAAc;AAC7B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,gCAAgC,+DAAsB;AACtD;AACA,wCAAwC,0EAAiC;AACzE;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAU;AAC7B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,6CAA6C,gEAAuB;AACpE;AACA;AACA;AACA;AACA;AACA,8BAA8B,mEAA0B;AACxD;AACA;AACA;AACA;AACA,gCAAgC,+DAAsB;AACtD;AACA,wCAAwC,0EAAiC;AACzE;AACA,iBAAiB;AACjB;AACA,0CAA0C,8DAAqB,CAAC,mDAAU;AAC1E,2CAA2C,6BAA6B;AACxE;AACA;AACA,+DAA+D,+BAA+B;AAC9F;AACA;AACA;AACA,wCAAwC,4DAAmB;AAC3D,qFAAqF,IAAI;AACzF;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oEAA2B;AAC3E;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb,oCAAoC,4DAAmB;AACvD;AACA,4CAA4C,mEAA0B;AACtE;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+DAAsB;AAC1D;AACA,4CAA4C,0EAAiC;AAC7E;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,wCAAwC,4DAAmB;AAC3D;AACA,gDAAgD,oEAA2B;AAC3E;AACA,yBAAyB;AACzB;AACA;AACA;AACA,wCAAwC,4DAAmB;AAC3D;AACA,gDAAgD,mEAA0B;AAC1E;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAuB;AACrD;AACA;AACA;AACA,iBAAiB,8DAAqB;AACtC;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB,8DAAqB;AACtC,mDAAmD,iCAAiC;AACpF,2BAA2B,+DAAsB;AACjD;AACA,iBAAiB,+DAAsB;AACvC,mDAAmD,kCAAkC;AACrF,2BAA2B,+DAAsB;AACjD;AACA;AACA,mDAAmD,iCAAiC;AACpF,2BAA2B,+DAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+DAAsB;AAC9D,4CAA4C,0EAAiC;AAC7E;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mEAA0B,IAAI,uCAAuC;AACzH;AACA;AACA,oDAAoD,oEAA2B;AAC/E;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,oDAAoD,oEAA2B;AAC/E;AACA;AACA;AACA;AACA,+CAA+C,oEAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA,4CAA4C,4DAAmB;AAC/D;AACA;AACA;AACA,oDAAoD,mEAA0B,IAAI,4EAA4E;AAC9J;AACA;AACA,oDAAoD,mEAA0B,IAAI,mCAAmC;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;AACA,0FAA0F;AAC1F;AACA,0FAA0F;AAC1F;AACA,0FAA0F;AAC1F;AACA,0FAA0F;AAC1F;AACA,0FAA0F;AAC1F;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,iEAAwB,6DAA6D,iEAAwB;AACzM;AACA;AACA,iFAAiF,gEAAuB;AACxG;AACA;AACA,wDAAwD,yEAAgC,IAAI,6CAA6C;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,kEAAkE,uDAAc;AAChF;AACA,gDAAgD,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;AAClE,qCAAqC;AACrC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,4DAA4D,yEAAgC,IAAI,yDAAyD;AACzJ;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,2DAA2D,gEAAuB;AAClF;AACA;AACA,2DAA2D,+DAAsB;AACjF;AACA;AACA,kDAAkD,+DAAsB;AACxE;AACA,+BAA+B,gDAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,mEAA0B,IAAI,gFAAgF;AAC1K;AACA;AACA;AACA;AACA,gEAAgE,mEAA0B,IAAI,4BAA4B,6EAAoC,UAAU,sEAAsE;AAC9O;AACA;AACA;AACA;AACA;AACA,gGAAgG,+EAA+E;AAC/K,yCAAyC;AACzC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,mDAAU;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oEAA2B;AACnE;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qFAAqF,6DAAoB;AACzG;AACA,sBAAsB,uDAAc,GAAG;AACvC,oBAAoB,mEAA0B;AAC9C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,6EAAoC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qEAA4B,IAAI,gBAAgB;AAC9F;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT,YAAY,2DAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAgB,oBAAoB,yDAAgB;AACzE;AACA;AACA,qBAAqB,4DAAmB,oBAAoB,4DAAmB;AAC/E;AACA;AACA,qBAAqB,2DAAkB,oBAAoB,2DAAkB;AAC7E;AACA;AACA,qBAAqB,gEAAuB,oBAAoB,gEAAuB;AACvF;AACA;AACA,qBAAqB,iEAAwB,oBAAoB,iEAAwB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,gDAAgD,oEAA2B;AAC3E;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,2DAA2D;AAC3D,YAAY,sEAA6B;AACzC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,4EAAmC;AAC3E;AACA,iBAAiB;AACjB;AACA,wCAAwC,sEAA6B;AACrE;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oCAAoC,qEAA4B;AAChE;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA,oCAAoC,qEAA4B;AAChE;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA,oCAAoC,sEAA6B;AACjE;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAA2C;AAC3C;AACA;AACA;AACA;AACA,QAAQ,2DAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAc,GAAG;AACnC,qCAAqC,mDAAU;AAC/C;AACA,yBAAyB,uDAAc;AACvC;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,0CAA0C,iBAAiB,iCAAiC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAc,SAAS,oBAAoB;AAC1E;AACA,gDAAgD,uDAAc,eAAe,iBAAiB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE;AACA,KAAK;AACL;AACA;AACA,yFAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAc,GAAG;AAC3C,YAAY,2DAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA,sCAAsC,uDAAc,GAAG,6BAA6B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qEAA4B;AAChE;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,+EAAsC;AACtC;AACA;AACA;AACA,mFAA0C;AAC1C;AACA;AACA;AACA,wFAA+C;AAC/C;AACA;AACA;AACA,uFAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC,+DAAsB;AACvD,kCAAkC,+DAAsB;AACxD;AACA;AACA,gBAAgB,gDAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,SAAS;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oFAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAkB;AAClC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,gBAAgB,2DAAkB;AAClC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAgB,2CAA2C,2DAAkB;AAC7F;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2FAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA,oFAA2C;AAC3C;AACA;AACA;AACA,aAAa,gEAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA,iBAAiB,gEAAuB;AACxC;AACA;AACA;AACA;AACA,iFAAwC;AACxC;AACA;AACA;AACA,yBAAyB,gEAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,oCAAoC,8DAAqB;AACzD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAwC;AACxC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mFAA0C;AAC1C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kFAAyC;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mFAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,kFAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,wEAA+B;AAC9C,KAAK;AACL;AACA;AACA,iFAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,8FAAqD;AACrD;AACA;AACA;AACA,uFAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,oCAAoC,gEAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,0FAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAmB;AAC/C,KAAK;AACL;AACA;AACA,6FAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO,yGAAyG;AAC9I;AACA;AACA,0FAAiD;AACjD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,0FAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6EAAoC;AAC5C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,+FAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,wCAAwC,0DAAiB;AACzD;AACA,2GAA2G,mEAA0B,GAAG,kEAAyB;AACjK,2GAA2G,mEAA0B,GAAG,kEAAyB;AACjK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yDAAgB;AACnD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,oEAA2B;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,gBAAgB;AAClI;AACA;AACA,qCAAqC;AACrC,iCAAiC,EAAE;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA,8FAA8F,sFAAsF;AACpL,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,uEAAuE,iEAAwB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,cAAc,OAAO;AACrB,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA;AACA,0FAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4DAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,YAAY,sEAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sEAA6B;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAyB;AAC3D,yBAAyB;AACzB,0EAA0E,iEAAwB;AAClG,yEAAyE,iEAAwB;AACjG;AACA,iBAAiB,2BAA2B;AAC5C;AACA,aAAa;AACb;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wDAAwD,iEAAwB;AAChF;AACA;AACA;AACA,+FAAsD;AACtD;AACA;AACA,SAAS,6DAAoB;AAC7B;AACA;AACA;AACA;AACA,iGAAwD;AACxD;AACA;AACA;AACA,aAAa,6DAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oFAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uFAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,wDAAwD,4DAAmB,gBAAgB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,0BAA0B;AACpH,0FAA0F,0BAA0B;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oEAA2B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAAsD;AACtD;AACA;AACA;AACA;AACA;AACA,+BAA+B,4DAAmB;AAClD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,+CAA+C,SAAS;AACxD,iCAAiC,sEAA6B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,mGAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAwD;AACxD;AACA;AACA,qBAAqB,4DAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,+DAA+D;AAC/D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wFAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sEAA6B;AACxD,iBAAiB;AACjB;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,iCAAiC;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sGAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA,+BAA+B,mDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,gDAAgD,kDAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,gDAAgD,kDAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,mCAAmC;AACvH;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,cAAc;AACvF;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAQ;AAChB;AACA;AACA;AACA,wFAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAQ;AAChB;AACA;AACA;AACA;AACA,+FAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAAmD;AACnD;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,iBAAiB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAS,cAAc,2DAAkB;AAC7D;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,mGAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uGAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wFAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mGAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0DAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAAoD;AACpD;AACA;AACA;AACA;AACA;AACA,+FAAsD;AACtD;AACA;AACA;AACA;AACA;AACA,uDAAc;AACd;AACA;AACA,sEAA6B;AAC7B;AACA;AACA;AACA;AACA,uBAAuB,mDAAU;AACjC;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,8EAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4DAAmB;AACtD;AACA;AACA,mCAAmC,2DAAkB;AACrD;AACA;AACA,mCAAmC,8DAAqB;AACxD;AACA;AACA,mCAAmC,iEAAwB;AAC3D;AACA;AACA,mCAAmC,gEAAuB;AAC1D;AACA;AACA;AACA,mCAAmC,yDAAgB;AACnD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uDAAc;AACd;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mDAAU,CAAC,2DAAkB,EAAE,uDAAc;AAC7C,mDAAU,CAAC,4DAAmB,EAAE,uDAAc;AAC9C;AACA,uFAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAS;AACjB;AACA,aAAa,uDAAc,GAAG,kEAAyB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,iEAAwB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uEAA8B;AACnE,sCAAsC,iEAAwB;AAC9D,mCAAmC,kEAAyB;AAC5D,aAAa;AACb,qCAAqC,iEAAwB;AAC7D,sCAAsC,kEAAyB;AAC/D,mCAAmC,iEAAwB;AAC3D,aAAa;AACb;AACA;AACA;AACA;AACA,gCAAgC,gEAAuB;AACvD,SAAS;AACT,KAAK;AACL;AACA;AACA,oFAA2C;AAC3C;AACA;AACA;AACA,+BAA+B,iEAAwB;AACvD,+CAA+C,mGAAmG;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0CAA0C,iEAAwB;AAClE;AACA,iBAAiB;AACjB;AACA;AACA;AACA,4CAA4C,gFAAuC,IAAI,mFAAmF;AAC1K;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,6CAA6C,uEAA8B;AAC3E,8CAA8C,iEAAwB;AACtE,2CAA2C,kEAAyB;AACpE,qBAAqB;AACrB,6CAA6C,iEAAwB;AACrE,8CAA8C,kEAAyB;AACvE,2CAA2C,iEAAwB;AACnE,qBAAqB;AACrB;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,6BAA6B;AAC7B,0BAA0B;AAC1B;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA,+FAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,2FAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yFAAgD;AAChD;AACA;AACA,IAAI,8EAAqC;AACzC;AACA;AACA,uFAA8C;AAC9C;AACA;AACA,QAAQ,sFAA6C;AACrD;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA,4BAA4B,sEAA6B,IAAI,sBAAsB;AACnF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA;AACA;AACA;AACA,oDAAoD,kDAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,6FAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,6DAA6D;AAClH;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uDAAc,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,uDAAc;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6BAA6B;AACrE;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,yDAAgB;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,iEAAiE,yDAAgB,0CAA0C;AACtN,mGAAmG,oEAAoE,SAAS;AAChL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uDAAc,GAAG;AACzD,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB,iBAAiB;AACjB,gBAAgB,gEAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,oCAAoC,iDAAQ,gEAAgE,6BAA6B;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,eAAe;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qBAAqB;AACrE;AACA;AACA,qEAAqE,kDAAS;AAC9E;AACA;AACA,wDAAwD,2BAA2B;AACnF;AACA;AACA;AACA;AACA,6GAA6G;AAC7G,yEAAyE,sEAA6B,YAAY,mBAAmB;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG;AACzG,qEAAqE,sEAA6B,YAAY,mBAAmB;AACjI;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kDAAS;AAC7D;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,4BAA4B,gEAAuB;AACnD,4BAA4B,gEAAuB;AACnD;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,iGAAiG;AACjG;AACA,sCAAsC,gEAAuB;AAC7D,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,6DAAoB;AACxH,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,uDAAuD,6DAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,kCAAkC,gEAAuB;AACzD,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,4CAA4C,wDAAe;AAC3D,iBAAiB;AACjB;AACA,8BAA8B,+DAAsB;AACpD,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAiC;AACxD;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,+FAAsD;AACtD;AACA;AACA,QAAQ,sFAA6C;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA,wGAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,gGAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gEAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAA6B;AACjD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,sEAA6B,kBAAkB,mBAAmB;AAClF;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA,yCAAyC,kDAAS;AAClD;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA,yCAAyC,sEAA6B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sEAA6B;AAClE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA,4GAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA,oDAAoD,YAAY,6DAAoB,kCAAkC,8DAAqB,EAAE;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA,4CAA4C,+BAA+B;AAC3E,0DAA0D,kEAAyB;AACnF;AACA;AACA,yCAAyC,6EAAoC;AAC7E;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,yCAAyC,4EAAmC;AAC5E;AACA;AACA,yCAAyC,wEAA+B;AACxE;AACA;AACA;AACA,yCAAyC,0EAAiC;AAC1E;AACA,wCAAwC,iDAAQ,SAAS,OAAO,kBAAkB,aAAa,eAAe,YAAY,WAAW,wGAAwG,GAAG,uEAA8B;AAC9Q,oDAAoD,gEAAuB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,iBAAiB;AACvE;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb,+CAA+C;AAC/C;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA,wEAA+B;AAC/B;AACA;AACA;AACA,0EAAiC;AACjC,wEAA+B;AAC/B,kFAAyC;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yLAAyL;AACzL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,0EAAiC;AACpG,mEAAmE,wEAA+B;AAClG;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mFAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+DAAsB;AACzD;AACA;AACA;AACA,mCAAmC,gEAAuB;AAC1D;AACA;AACA,mCAAmC,6DAAoB;AACvD;AACA;AACA;AACA,yBAAyB,wEAA+B,8BAA8B,4BAA4B;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAAqC;AACrC;AACA;AACA;AACA,QAAQ,gEAAuB;AAC/B,kDAAkD,UAAU,kBAAkB;AAC9E;AACA;AACA;AACA,mFAA0C;AAC1C;AACA;AACA;AACA,QAAQ,gEAAuB;AAC/B,kDAAkD,UAAU,kBAAkB;AAC9E;AACA;AACA;AACA,+EAAsC;AACtC;AACA;AACA,kBAAkB,gEAAuB;AACzC;AACA;AACA;AACA,YAAY,gEAAuB;AACnC,sDAAsD,UAAU,mBAAmB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAA2C;AAC3C;AACA;AACA,kBAAkB,gEAAuB;AACzC;AACA;AACA;AACA,YAAY,gEAAuB;AACnC,sDAAsD,UAAU,mBAAmB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAwC;AACxC;AACA;AACA;AACA,QAAQ,gEAAuB;AAC/B,kDAAkD,UAAU,iBAAiB;AAC7E;AACA;AACA;AACA,gFAAuC;AACvC;AACA;AACA;AACA,QAAQ,gEAAuB;AAC/B,kDAAkD,UAAU,oBAAoB;AAChF;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA,QAAQ,gEAAuB;AAC/B,kDAAkD,UAAU,iBAAiB;AAC7E;AACA;AACA;AACA,qFAA4C;AAC5C;AACA;AACA;AACA,QAAQ,gEAAuB;AAC/B,kDAAkD,UAAU,oBAAoB;AAChF;AACA;AACA;AACA,+EAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,sEAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAU;AACrC;AACA;AACA,2BAA2B,mDAAU;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+EAAsC;AACtC;AACA;AACA;AACA,2EAAkC;AAClC;AACA;AACA;AACA,QAAQ,2DAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,uDAAc;AAClB;AACA;AACA;AACA,8EAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gEAAuB,2BAA2B,gEAAuB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAAkB,2BAA2B,2DAAkB,IAAI,iEAAwB,2BAA2B,iEAAwB;AAC/J;AACA,iCAAiC,2DAAkB,2BAA2B,2DAAkB;AAChG;AACA;AACA;AACA;AACA,iBAAiB,4DAAmB,2BAA2B,4DAAmB,IAAI,8DAAqB,2BAA2B,8DAAqB;AAC3J;AACA,iCAAiC,4DAAmB,2BAA2B,4DAAmB;AAClG;AACA;AACA;AACA;AACA,iBAAiB,yDAAgB,2BAA2B,yDAAgB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAiB,2BAA2B,0DAAiB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAiB;AAC3C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAiB;AACvC;AACA;AACA;AACA;AACA;AACA,4EAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,0EAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA,iDAAiD,wEAA+B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,kCAAkC,gEAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,wEAA+B;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,wEAA+B;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,yBAAyB,gEAAuB;AAChD;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C,oBAAoB,6DAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,yBAAyB,iEAAwB;AACjD;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAAmC;AACnC;AACA;AACA,mDAAmD,mDAAU;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,wBAAwB;AAC/E;AACA,kFAAkF,4BAA4B;AAC9G;AACA;AACA,gBAAgB,8DAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,8DAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kEAAyB;AACrE,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,2EAAkC;AAClC;AACA;AACA;AACA,0EAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAAqC;AACrC;AACA;AACA;AACA,QAAQ,2DAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAAiC;AACjC;AACA;AACA;AACA,4EAAmC;AACnC;AACA;AACA;AACA;AACA,4EAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wFAA+C;AAC/C;AACA;AACA,4BAA4B,uEAA8B;AAC1D;AACA;AACA;AACA,wFAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAA2C;AAC3C;AACA,iCAAiC,gEAAuB;AACxD;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAqB;AACjD;AACA,SAAS;AACT;AACA;AACA;AACA,0FAAiD;AACjD;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA,sCAAsC,0DAAiB;AACvD;AACA;AACA;AACA;AACA,uCAAuC,0DAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+DAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+DAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAuC;AACvC;AACA;AACA;AACA;AACA,aAAa,+DAAsB;AACnC;AACA;AACA,aAAa,oEAA2B;AACxC;AACA;AACA,aAAa,6DAAoB;AACjC;AACA;AACA,aAAa,kEAAyB;AACtC;AACA;AACA,aAAa,qEAA4B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,yCAAyC;AACzC;AACA;AACA,6DAA6D,gEAAuB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iEAAwB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gEAAuB;AAC7E,yDAAyD,qEAA4B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kEAAyB,IAAI,0BAA0B;AACvG,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,oDAAoD,gEAAuB;AAC3E;AACA,4BAA4B,sEAA6B;AACzD;AACA,wDAAwD,gEAAuB,IAAI,eAAe;AAClG;AACA;AACA;AACA,yDAAyD,iEAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,iDAAQ;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,kFAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,8DAAqB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qFAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uEAA8B;AACtD;AACA;AACA;AACA;AACA,4EAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uEAA8B;AACtD;AACA;AACA;AACA;AACA,2EAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,gFAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,iBAAiB,iEAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB,+DAAsB;AACvC,iBAAiB,oEAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB,6DAAoB;AACrC,iBAAiB,kEAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB,qEAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,oGAA2D;AAC3D;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,UAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oGAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA,mCAAmC,uEAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW,UAAU,QAAQ,UAAU,QAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,QAAQ,2DAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uEAA8B,IAAI,6DAA6D;AACvI;AACA;AACA;AACA,4CAA4C,yEAAgC,IAAI,sEAAsE;AACtJ;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,wCAAwC,sEAA6B,IAAI,yDAAyD;AAClI,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oFAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6FAAoD;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6FAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gCAAgC,yEAAgC,IAAI,8BAA8B;AAClG;AACA;AACA;AACA;AACA,8EAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yEAAgC,IAAI,6CAA6C;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,sFAA6C;AAC7C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA,wCAAwC,yEAAgC,IAAI,iCAAiC;AAC7G;AACA;AACA,oCAAoC,sEAA6B,IAAI,iCAAiC;AACtG;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAA+B;AAC/B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kDAAS;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4EAAmC;AACnC;AACA;AACA;AACA;AACA,+DAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gEAAuB;AACpC;AACA;AACA,aAAa,+DAAsB;AACnC;AACA;AACA,aAAa,kEAAyB;AACtC;AACA;AACA,aAAa,qEAA4B;AACzC;AACA;AACA,aAAa,oEAA2B;AACxC;AACA;AACA,aAAa,6DAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAA0B;AAC1B,WAAW,+DAAsB;AACjC;AACA;AACA,iEAAe,6CAAI;;;;;;;;UCvvTnB","sources":["webpack://SITNA/./TC/ol/ol.js","webpack://SITNA/webpack/runtime/getFullHash"],"sourcesContent":["import { VERSION } from 'ol/util';\r\nimport Map from 'ol/Map';\r\nimport View from 'ol/View';\r\nimport Overlay from 'ol/Overlay';\r\nimport OverlayPositioning from 'ol/OverlayPositioning';\r\nimport Collection from 'ol/Collection';\r\nimport { extend, includes } from 'ol/array';\r\nimport { assert } from 'ol/asserts';\r\nimport { asArray, asString } from 'ol/color';\r\nimport { toRadians } from 'ol/math';\r\nimport { padNumber } from 'ol/string';\r\nimport MapEventType from 'ol/MapEventType';\r\nimport MapBrowserEventType from 'ol/MapBrowserEventType';\r\nimport { OverviewMap, ScaleLine, Zoom, ZoomToExtent } from 'ol/control';\r\nimport ZoomSlider from 'ol/control/ZoomSlider';\r\nimport { listen, unlistenByKey } from 'ol/events';\r\nimport { shiftKeyOnly } from 'ol/events/condition';\r\nimport e_EventType from 'ol/events/EventType';\r\nimport { getWidth, getHeight, containsCoordinate, containsExtent, buffer, boundingExtent } from 'ol/extent';\r\nimport Feature from 'ol/Feature';\r\nimport { createStyleFunction } from 'ol/Feature';\r\nimport { Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, Circle as g_Circle } from 'ol/geom';\r\nimport GeometryCollection from 'ol/geom/GeometryCollection';\r\nimport GeometryType from 'ol/geom/GeometryType';\r\nimport GeometryLayout from 'ol/geom/GeometryLayout';\r\nimport { deflateCoordinates } from 'ol/geom/flat/deflate';\r\nimport { inflateCoordinates } from 'ol/geom/flat/inflate';\r\nimport { linearRingLength } from 'ol/geom/flat/length';\r\nimport { xhr } from 'ol/featureloader';\r\nimport GMLBase from '../../lib/ol/format/GMLBase';\r\nimport { GML, WFS, WKT, WMSCapabilities, WMSGetFeatureInfo, WMTSCapabilities, TopoJSON } from 'ol/format';\r\nimport GeoJSON from '../../lib/ol/format/GeoJSON';\r\nimport GPX from '../../lib/ol/format/GPX';\r\nimport KML from '../../lib/ol/format/KML';\r\n//import { GeoJSON, GML, GPX, KML, WFS, WKT, WMSCapabilities, WMSGetFeatureInfo, WMTSCapabilities, TopoJSON } from 'ol/format';\r\nimport { transformGeometryWithOptions } from 'ol/format/Feature.js';\r\nimport GML2 from 'ol/format/GML2';\r\nimport GML3 from 'ol/format/GML3';\r\nimport GML32 from 'ol/format/GML32';\r\nimport { defaults, Draw, Pointer, Translate, Snap, Select, Modify, /*DragAndDrop, */DoubleClickZoom } from 'ol/interaction';\r\nimport DragAndDrop from '../../lib/ol/interaction/DragAndDrop';\r\nimport { Layer, Tile, Image as l_Image, Vector as l_Vector, Heatmap } from 'ol/layer';\r\nimport TileGrid from 'ol/tilegrid/TileGrid';\r\nimport { unByKey } from 'ol/Observable';\r\n\r\nimport BaseObject from 'ol/Object';\r\nimport { METERS_PER_UNIT, Projection, addEquivalentProjections, get, getTransform, transform, transformExtent } from 'ol/proj';\r\nimport { METERS_PER_UNIT as g_METERS_PER_UNIT, PROJECTIONS } from 'ol/proj/epsg4326';\r\nimport Units from 'ol/proj/Units';\r\nimport { register } from 'ol/proj/proj4';\r\nimport { getVectorContext, toContext } from 'ol/render';\r\nimport r_EventType from 'ol/render/EventType';\r\nimport { Vector as s_Vector, Cluster, ImageWMS, WMTS, ImageCanvas } from 'ol/source';\r\n//import OGCMapTile from 'ol/source/OGCMapTile';\r\nimport TileEventType from 'ol/source/TileEventType';\r\nimport VectorEventType from 'ol/source/VectorEventType';\r\nimport { optionsFromCapabilities } from 'ol/source/WMTS';\r\nimport { defaultImageLoadFunction } from 'ol/source/Image';\r\nimport WMSServerType from 'ol/source/WMSServerType';\r\nimport { Style, RegularShape, Circle as s_Circle, Fill, Icon, Stroke, Text } from 'ol/style';\r\nimport IconAnchorUnits from 'ol/style/IconAnchorUnits';\r\nimport IconOrigin from 'ol/style/IconOrigin';\r\nimport {\r\n    parse,\r\n    parseNode,\r\n    createElementNS,\r\n    pushParseAndPop,\r\n    pushSerializeAndPop,\r\n    makeStructureNS,\r\n    getAllTextContent,\r\n    makeChildAppender,\r\n    makeReplacer,\r\n    makeSequence,\r\n    makeArrayPusher,\r\n    makeArrayExtender,\r\n    makeArraySerializer,\r\n    makeObjectPropertySetter,\r\n    makeSimpleNodeFactory,\r\n    OBJECT_PROPERTY_NODE_FACTORY,\r\n    XML_SCHEMA_INSTANCE_URI\r\n} from 'ol/xml';\r\nimport {\r\n    readDecimal,\r\n    readBoolean,\r\n    readString,\r\n    readPositiveInteger,\r\n    readDateTime,\r\n    writeStringTextNode,\r\n    writeCDATASection,\r\n    writeDecimalTextNode,\r\n    writeBooleanTextNode,\r\n    writeNonNegativeIntegerTextNode\r\n} from 'ol/format/xsd';\r\nimport Image from 'ol/Image';\r\n\r\nimport proj4 from 'proj4';\r\nimport TC from '../../TC';\r\nimport wrap from '../wrap';\r\nimport Util from '../Util';\r\nimport Consts from '../Consts';\r\nimport Feature_s from '../Feature';\r\nimport Point_s from '../feature/Point';\r\nimport Marker from '../feature/Marker';\r\nimport Polyline from '../feature/Polyline';\r\nimport Polygon_s from '../feature/Polygon';\r\nimport MultiPoint_s from '../feature/MultiPoint';\r\nimport MultiMarker from '../feature/MultiMarker';\r\nimport MultiPolyline from '../feature/MultiPolyline';\r\nimport MultiPolygon_s from '../feature/MultiPolygon';\r\nimport Geometry from '../Geometry';\r\n\r\nTC.wrap = wrap;\r\nTC.Util = Util;\r\nTC.Consts = Consts;\r\nTC.Feature = Feature_s;\r\nTC.feature = TC.feature || {};\r\nTC.feature.Point = Point_s;\r\nTC.feature.Marker = Marker;\r\nTC.feature.Polyline = Polyline;\r\nTC.feature.Polygon = Polygon_s;\r\nTC.feature.MultiPoint = MultiPoint_s;\r\nTC.feature.MultiMarker = MultiMarker;\r\nTC.feature.MultiPolyline = MultiPolyline;\r\nTC.feature.MultiPolygon = MultiPolygon_s;\r\nTC.Geometry = Geometry;\r\n\r\nwindow.ol = {};\r\nol.VERSION = VERSION;\r\nol.Map = Map;\r\nol.View = View;\r\nol.Overlay = Overlay;\r\nol.OverlayPositioning = OverlayPositioning;\r\nFeature.createStyleFunction = createStyleFunction;\r\nol.Feature = Feature;\r\nol.Collection = Collection;\r\nol.MapEventType = MapEventType;\r\nol.MapBrowserEventType = MapBrowserEventType;\r\nol.Image = Image;\r\n\r\nol.array = {\r\n    extend: extend,\r\n    includes: includes\r\n};\r\n\r\nol.asserts = {\r\n    assert: assert\r\n};\r\n\r\nol.color = {\r\n    asArray: asArray,\r\n    asString: asString\r\n};\r\n\r\nol.math = {\r\n    toRadians: toRadians\r\n};\r\n\r\nol.string = {\r\n    padNumber: padNumber\r\n};\r\n\r\nol.control = {\r\n    OverviewMap: OverviewMap,\r\n    ScaleLine: ScaleLine,\r\n    Zoom: Zoom,\r\n    ZoomSlider: ZoomSlider,\r\n    ZoomToExtent: ZoomToExtent\r\n};\r\n\r\nol.events = {\r\n    EventType: e_EventType,\r\n    listen: listen,\r\n    unlistenByKey: unlistenByKey,\r\n    condition: {\r\n        shiftKeyOnly: shiftKeyOnly\r\n    }\r\n};\r\n\r\nol.extent = {\r\n    getWidth: getWidth,\r\n    getHeight: getHeight,\r\n    containsCoordinate: containsCoordinate,\r\n    containsExtent: containsExtent,\r\n    buffer: buffer,\r\n    boundingExtent: boundingExtent\r\n};\r\n\r\nol.geom = {\r\n    Point: Point,\r\n    MultiPoint: MultiPoint,\r\n    LineString: LineString,\r\n    MultiLineString: MultiLineString,\r\n    Polygon: Polygon,\r\n    MultiPolygon: MultiPolygon,\r\n    GeometryCollection: GeometryCollection,\r\n    Circle: g_Circle,\r\n    GeometryType: GeometryType,\r\n    GeometryLayout: GeometryLayout,\r\n    flat: {\r\n        deflateCoordinates: deflateCoordinates,\r\n        inflateCoordinates: inflateCoordinates,\r\n        linearRingLength: linearRingLength\r\n    }\r\n};\r\n\r\nol.featureloader = {\r\n    xhr: xhr\r\n};\r\n\r\nol.format = {\r\n    Feature: Feature,\r\n    GMLBase: GMLBase,\r\n    GML: GML,\r\n    GML2: GML2,\r\n    GML3: GML3,\r\n    GML32: GML32,\r\n    GPX: GPX,\r\n    KML: KML,\r\n    WFS: WFS,\r\n    WKT: WKT,\r\n    GeoJSON: GeoJSON,\r\n    WMSCapabilities: WMSCapabilities,\r\n    WMSGetFeatureInfo: WMSGetFeatureInfo,\r\n    WMTSCapabilities: WMTSCapabilities,\r\n    TopoJSON: TopoJSON,\r\n    xsd: {\r\n        readDecimal: readDecimal,\r\n        readBoolean: readBoolean,\r\n        readString: readString,\r\n        readPositiveInteger: readPositiveInteger,\r\n        readDateTime: readDateTime,\r\n        writeStringTextNode: writeStringTextNode,\r\n        writeCDATASection: writeCDATASection,\r\n        writeDecimalTextNode: writeDecimalTextNode,\r\n        writeBooleanTextNode: writeBooleanTextNode,\r\n        writeNonNegativeIntegerTextNode: writeNonNegativeIntegerTextNode\r\n    }\r\n};\r\nol.format.Feature.transformGeometryWithOptions = transformGeometryWithOptions;\r\n\r\nol.interaction = {\r\n    defaults: defaults,\r\n    Draw: Draw,\r\n    Pointer: Pointer,\r\n    Translate: Translate,\r\n    Snap: Snap,\r\n    Select: Select,\r\n    Modify: Modify,\r\n    DragAndDrop: DragAndDrop,\r\n    DoubleClickZoom: DoubleClickZoom\r\n};\r\n\r\nol.layer = {\r\n    Layer: Layer,\r\n    Tile: Tile,\r\n    Image: l_Image,\r\n    Vector: l_Vector,\r\n    Heatmap: Heatmap\r\n};\r\n\r\nol.Observable = {\r\n    unByKey: unByKey\r\n};\r\n\r\nol.Object = BaseObject;\r\n\r\nol.proj = {\r\n    METERS_PER_UNIT: METERS_PER_UNIT,\r\n    Projection: Projection,\r\n    addEquivalentProjections: addEquivalentProjections,\r\n    get: get,\r\n    transform: transform,\r\n    transformExtent: transformExtent,\r\n    getTransform: getTransform,\r\n    Units: Units,\r\n    proj4: {\r\n        register: register\r\n    },\r\n    EPSG4326: {\r\n        METERS_PER_UNIT: g_METERS_PER_UNIT,\r\n        PROJECTIONS: PROJECTIONS\r\n    }\r\n};\r\n\r\nol.render = {\r\n    getVectorContext: getVectorContext,\r\n    toContext: toContext,\r\n    EventType: r_EventType\r\n};\r\n\r\nol.source = {\r\n    Vector: s_Vector,\r\n    Cluster: Cluster,\r\n    ImageWMS: ImageWMS,\r\n    WMTS: WMTS,\r\n    TileEventType: TileEventType,\r\n    VectorEventType: VectorEventType,\r\n    ImageCanvas: ImageCanvas,\r\n    //OGCMapTile: OGCMapTile\r\n    Image: {\r\n        defaultImageLoadFunction: defaultImageLoadFunction\r\n    },\r\n    WMSServerType: WMSServerType\r\n};\r\nol.source.WMTS.optionsFromCapabilities = optionsFromCapabilities;\r\n\r\nol.tilegrid = {\r\n    TileGrid: TileGrid\r\n};\r\n\r\nol.style = {\r\n    Style: Style,\r\n    RegularShape: RegularShape,\r\n    Circle: s_Circle,\r\n    Fill: Fill,\r\n    Icon: Icon,\r\n    Stroke: Stroke,\r\n    Text: Text,\r\n    IconAnchorUnits: IconAnchorUnits,\r\n    IconOrigin: IconOrigin\r\n};\r\n\r\nol.xml = {\r\n    parse: parse,\r\n    parseNode: parseNode,\r\n    createElementNS: createElementNS,\r\n    pushParseAndPop: pushParseAndPop,\r\n    pushSerializeAndPop: pushSerializeAndPop,\r\n    makeStructureNS: makeStructureNS,\r\n    getAllTextContent: getAllTextContent,\r\n    makeChildAppender: makeChildAppender,\r\n    makeReplacer: makeReplacer,\r\n    makeSequence: makeSequence,\r\n    makeArrayPusher: makeArrayPusher,\r\n    makeArrayExtender: makeArrayExtender,\r\n    makeArraySerializer: makeArraySerializer,\r\n    makeObjectPropertySetter: makeObjectPropertySetter,\r\n    makeSimpleNodeFactory: makeSimpleNodeFactory,\r\n    OBJECT_PROPERTY_NODE_FACTORY: OBJECT_PROPERTY_NODE_FACTORY,\r\n    XML_SCHEMA_INSTANCE_URI: XML_SCHEMA_INSTANCE_URI\r\n};\r\n\r\nMath.hypot = Math.hypot || function () {\r\n    var y = 0;\r\n    var length = arguments.length;\r\n\r\n    for (var i = 0; i < length; i++) {\r\n        if (arguments[i] === Infinity || arguments[i] === -Infinity) {\r\n            return Infinity;\r\n        }\r\n        y += arguments[i] * arguments[i];\r\n    }\r\n    return Math.sqrt(y);\r\n};\r\n\r\n// requestAnimationFrame polyfill\r\nvar lastTime = 0;\r\nvar vendors = ['ms', 'moz', 'webkit', 'o'];\r\nfor (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\r\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']\r\n        || window[vendors[x] + 'CancelRequestAnimationFrame'];\r\n}\r\n\r\nif (!window.requestAnimationFrame)\r\n    window.requestAnimationFrame = function (callback, _element) {\r\n        var currTime = new Date().getTime();\r\n        var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n        var id = window.setTimeout(function () { callback(currTime + timeToCall); },\r\n            timeToCall);\r\n        lastTime = currTime + timeToCall;\r\n        return id;\r\n    };\r\n\r\nif (!window.cancelAnimationFrame)\r\n    window.cancelAnimationFrame = function (id) {\r\n        clearTimeout(id);\r\n    };\r\n\r\n// Nombres de tipos de eventos\r\nconst MOUSEMOVE = 'mousemove';\r\nconst MOUSEOVER = 'mouseover';\r\nconst DRAGENTER = ol.events.EventType.DRAGENTER;\r\nconst DRAGOVER = ol.events.EventType.DRAGOVER;\r\nconst DROP = ol.events.EventType.DROP;\r\nconst CHANGE = ol.events.EventType.CHANGE;\r\nconst CLICK = ol.MapBrowserEventType.CLICK\r\nconst SINGLECLICK = ol.MapBrowserEventType.SINGLECLICK;\r\nconst POINTERMOVE = ol.MapBrowserEventType.POINTERMOVE;\r\nconst MOVEEND = ol.MapEventType.MOVEEND;\r\nconst POSTRENDER = ol.render.EventType.POSTRENDER;\r\nconst ADDFEATURE = ol.source.VectorEventType.ADDFEATURE;\r\nconst REMOVEFEATURE = ol.source.VectorEventType.REMOVEFEATURE;\r\nconst CLEAR = ol.source.VectorEventType.CLEAR;\r\n\r\nconst hitTolerance = TC.Util.detectMouse() ? 3 : 10;\r\n\r\n/////////////////////////// ol patches\r\n\r\n// Parche para evitar el error AssertionError: Assertion failed: calculated value (1.020636810790192) ouside allowed range (0-1)\r\nol.View.prototype.getValueForResolutionFunction = function (opt_power) {\r\n    const power = opt_power || 2;\r\n    const maxResolution = this.maxResolution_;\r\n    const minResolution = this.minResolution_;\r\n    const max = Math.log(maxResolution / minResolution) / Math.log(power);\r\n    return (\r\n        /**\r\n             * @param {number} resolution Resolution.\r\n             * @return {number} Value.\r\n         */\r\n        function (resolution) {\r\n            var value = Math.log(maxResolution / resolution) / Math.log(power) / max;\r\n            value = Math.max(Math.min(1, value), 0);\r\n            return value;\r\n        });\r\n};\r\n\r\n// Modificación para cambiar el comportamiento de ol.control.OverviewMap:\r\n// Mantener la caja del extent siempre centrada.\r\nol.control.OverviewMap.prototype._validateExtent_ = ol.control.OverviewMap.prototype.validateExtent_;\r\nol.control.OverviewMap.prototype.validateExtent_ = function () {\r\n    var self = this;\r\n    self._validateExtent_();\r\n    if (self._wrap && self._wrap.parent.options.alwaysCentered) {\r\n        self.recenter_();\r\n    }\r\n};\r\n\r\n// Modificación para evitar un assertion error al cambiar a una vista de capa dinámica\r\nol.control.OverviewMap.prototype._bindView_ = ol.control.OverviewMap.prototype.bindView_;\r\nol.control.OverviewMap.prototype.bindView_ = function (view) {\r\n    const self = this;\r\n    const oldView = self.getOverviewMap().getView();\r\n    const result = ol.control.OverviewMap.prototype._bindView_.call(self, view);\r\n    const newView = self.getOverviewMap().getView();\r\n    const parentView = self._wrap.parent.map.wrap.map.getView();\r\n    if (!newView.getCenter()) {\r\n        newView.setCenter(parentView.getCenter());\r\n    }\r\n    if (!newView.getResolution()) {\r\n        newView.setResolution(oldView.getResolution());\r\n    }\r\n    return result;\r\n};\r\n\r\n// En modo 3D, cambiar la lógica de la escala para que siempre muestre área de visión.\r\nol.control.OverviewMap.prototype._resetExtent_ = ol.control.OverviewMap.prototype.resetExtent_;\r\nol.control.OverviewMap.prototype.resetExtent_ = function () {\r\n    var self = this;\r\n    self._resetExtent_.call(self);\r\n    var wrap = self._wrap;\r\n    if (wrap.is3D) {\r\n        var ovmap = self.ovmap_;\r\n        var ovview = ovmap.getView();\r\n        var extent = ovview.calculateExtent();\r\n        var feature = wrap.get3DCameraLayer().getSource().getFeatures()[0];\r\n        if (feature) {\r\n            const coordinates = feature.getGeometry().getCoordinates();\r\n            var coord1 = coordinates[0][0];\r\n            var coord2 = coordinates[0][1];\r\n            if (!ol.extent.containsCoordinate(extent, coord1) || !ol.extent.containsCoordinate(extent, coord2)) {\r\n                var buffer = Math.max(\r\n                    extent[0] - coord1[0],\r\n                    extent[1] - coord1[1],\r\n                    coord1[0] - extent[2],\r\n                    coord1[1] - extent[3],\r\n                    extent[0] - coord2[0],\r\n                    extent[1] - coord2[1],\r\n                    coord2[0] - extent[2],\r\n                    coord2[1] - extent[3]\r\n                );\r\n                ovview.fit(ol.extent.buffer(extent, buffer));\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nol.format.GML3CRS84 = function () {\r\n    ol.format.GML3.call(this, {\r\n        srsName: 'CRS:84'\r\n    });\r\n};\r\nTC.inherit(ol.format.GML3CRS84, ol.format.GML3);\r\n\r\nol.format.GML2CRS84 = function () {\r\n    ol.format.GML2.call(this, {\r\n        srsName: 'CRS:84'\r\n    });\r\n};\r\nTC.inherit(ol.format.GML2CRS84, ol.format.GML2);\r\n\r\n// Añadido el espacio de nombres de GML 3.2 al parser\r\nconst gmlNamespace = 'http://www.opengis.net/gml';\r\nconst gml32Namespace = 'http://www.opengis.net/gml/3.2';\r\nol.format.GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS[gml32Namespace] = ol.format.GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS[gmlNamespace];\r\nol.format.GML3.prototype.FLAT_LINEAR_RINGS_PARSERS[gml32Namespace] = ol.format.GML3.prototype.FLAT_LINEAR_RINGS_PARSERS[gmlNamespace];\r\nol.format.GML3.prototype.GEOMETRY_PARSERS[gml32Namespace] = ol.format.GML3.prototype.GEOMETRY_PARSERS[gmlNamespace];\r\nol.format.GML3.prototype.MULTICURVE_PARSERS[gml32Namespace] = ol.format.GML3.prototype.MULTICURVE_PARSERS[gmlNamespace];\r\nol.format.GML3.prototype.MULTISURFACE_PARSERS[gml32Namespace] = ol.format.GML3.prototype.MULTISURFACE_PARSERS[gmlNamespace];\r\nol.format.GML3.prototype.CURVEMEMBER_PARSERS[gml32Namespace] = ol.format.GML3.prototype.CURVEMEMBER_PARSERS[gmlNamespace];\r\nol.format.GML3.prototype.SURFACEMEMBER_PARSERS[gml32Namespace] = ol.format.GML3.prototype.SURFACEMEMBER_PARSERS[gmlNamespace];\r\nol.format.GML3.prototype.SURFACE_PARSERS[gml32Namespace] = ol.format.GML3.prototype.SURFACE_PARSERS[gmlNamespace];\r\nol.format.GML3.prototype.CURVE_PARSERS[gml32Namespace] = ol.format.GML3.prototype.CURVE_PARSERS[gmlNamespace];\r\nol.format.GML3.prototype.ENVELOPE_PARSERS[gml32Namespace] = ol.format.GML3.prototype.ENVELOPE_PARSERS[gmlNamespace];\r\nol.format.GML3.prototype.PATCHES_PARSERS[gml32Namespace] = ol.format.GML3.prototype.PATCHES_PARSERS[gmlNamespace];\r\nol.format.GML3.prototype.SEGMENTS_PARSERS[gml32Namespace] = ol.format.GML3.prototype.SEGMENTS_PARSERS[gmlNamespace];\r\n\r\nol.proj.proj4.register(proj4);\r\n// OpenLayers usa para las proyecciones geográficas un valor ol.proj.METERS_PER_UNIT[ol.proj.Units.DEGREES], calculado con una esfera, salvo\r\n// EPSG:4326, en la que usa ol.proj.EPSG4326.METERS_PER_UNIT, calculado con el geoide. Esto hace que las proyecciones en EPSG:4258 salgan desplazadas,\r\n// pese a que para todos los efectos son iguales a las EPSG:4326. Para evitar eso, introducimos en las 4258 el valor ol.proj.EPSG4326.METERS_PER_UNIT.\r\n//ol.proj.get('EPSG:4258').metersPerUnit_ = ol.proj.EPSG4326.METERS_PER_UNIT;\r\n//ol.proj.get('urn:ogc:def:crs:EPSG::4258').metersPerUnit_ = ol.proj.EPSG4326.METERS_PER_UNIT;\r\n//ol.proj.get('http://www.opengis.net/gml/srs/epsg.xml#4258').metersPerUnit_ = ol.proj.EPSG4326.METERS_PER_UNIT;\r\n\r\n// Reescribimos la obtención de proyección para que soporte códigos tipo EPSG:X, urn:ogc:def:crs:EPSG::X y http://www.opengis.net/gml/srs/epsg.xml#X\r\nol.proj.oldGet = ol.proj.get;\r\nol.proj.get = function (projectionLike) {\r\n    let result = ol.proj.oldGet.call(this, projectionLike);\r\n    if (!result && typeof projectionLike === 'string') {\r\n        projectionLike = projectionLike.trim();\r\n        TC.loadProjDef({ crs: projectionLike, sync: true });\r\n        result = ol.proj.oldGet.call(this, projectionLike);\r\n    }\r\n    return result;\r\n};\r\n\r\n\r\nconst isMobile = TC.Util.detectMobile();\r\n// El viewState del mapa tiene una resolución con respecto al pixel virtual. Esto hace que se pida\r\n// teselas en un nivel de zoom distinto al deseado para que se vean en el dispositivo en relación pixel 1:1.\r\n// Esto parchea el problema.\r\nconst oldGetTilePixelRatio = ol.source.WMTS.prototype.getTilePixelRatio;\r\nol.source.WMTS.prototype.getTilePixelRatio = function (pixelRatio) {\r\n    if (isMobile) {\r\n        return oldGetTilePixelRatio.call(this, pixelRatio);\r\n    }\r\n    return oldGetTilePixelRatio.call(this, pixelRatio) * (pixelRatio || 1);\r\n};\r\n\r\nconst oldGetZForResolution = ol.tilegrid.TileGrid.prototype.getZForResolution;\r\nol.tilegrid.TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {\r\n    let res = resolution;\r\n    if (!isMobile) {\r\n        res = res / window.devicePixelRatio;\r\n    }\r\n    return oldGetZForResolution.call(this, res, opt_direction);\r\n};\r\n\r\n// Parche para solucionar el aspecto borroso de los popup de GFI con dos filas en Chromium: volvemos a la función de la versión 5.3.3.\r\n// El problema es que la altura calculada no es un número entero de pixels.\r\nol.Overlay.prototype.updateRenderedPosition = function (pixel, mapSize) {\r\n    const style = this.element.style;\r\n    const offset = this.getOffset();\r\n\r\n    const positioning = this.getPositioning();\r\n\r\n    this.setVisible(true);\r\n\r\n    let offsetX = offset[0];\r\n    let offsetY = offset[1];\r\n    if (positioning == OverlayPositioning.BOTTOM_RIGHT ||\r\n        positioning == OverlayPositioning.CENTER_RIGHT ||\r\n        positioning == OverlayPositioning.TOP_RIGHT) {\r\n        if (this.rendered.left_ !== '') {\r\n            this.rendered.left_ = style.left = '';\r\n        }\r\n        const right = Math.round(mapSize[0] - pixel[0] - offsetX) + 'px';\r\n        if (this.rendered.right_ != right) {\r\n            this.rendered.right_ = style.right = right;\r\n        }\r\n    } else {\r\n        if (this.rendered.right_ !== '') {\r\n            this.rendered.right_ = style.right = '';\r\n        }\r\n        if (positioning == OverlayPositioning.BOTTOM_CENTER ||\r\n            positioning == OverlayPositioning.CENTER_CENTER ||\r\n            positioning == OverlayPositioning.TOP_CENTER) {\r\n            offsetX -= this.element.offsetWidth / 2;\r\n        }\r\n        const left = Math.round(pixel[0] + offsetX) + 'px';\r\n        if (this.rendered.left_ != left) {\r\n            this.rendered.left_ = style.left = left;\r\n        }\r\n    }\r\n    if (positioning == OverlayPositioning.BOTTOM_LEFT ||\r\n        positioning == OverlayPositioning.BOTTOM_CENTER ||\r\n        positioning == OverlayPositioning.BOTTOM_RIGHT) {\r\n        if (this.rendered.top_ !== '') {\r\n            this.rendered.top_ = style.top = '';\r\n        }\r\n        const bottom = Math.round(mapSize[1] - pixel[1] - offsetY) + 'px';\r\n        if (this.rendered.bottom_ != bottom) {\r\n            this.rendered.bottom_ = style.bottom = bottom;\r\n        }\r\n    } else {\r\n        if (this.rendered.bottom_ !== '') {\r\n            this.rendered.bottom_ = style.bottom = '';\r\n        }\r\n        if (positioning == OverlayPositioning.CENTER_LEFT ||\r\n            positioning == OverlayPositioning.CENTER_CENTER ||\r\n            positioning == OverlayPositioning.CENTER_RIGHT) {\r\n            offsetY -= this.element.offsetHeight / 2;\r\n        }\r\n        const top = Math.round(pixel[1] + offsetY) + 'px';\r\n        if (this.rendered.top_ != top) {\r\n            this.rendered.top_ = style.top = top;\r\n        }\r\n    }\r\n};\r\n\r\n// Parcheamos siguiente método para meter en todas las peticiones todos los vendor params si pixelRatio != 1\r\n// serverType lo tenemos como Geoserver, así que añadimos los parámetros de los demás.\r\nconst oldGetRequestUrl_ = ol.source.ImageWMS.prototype.getRequestUrl_;\r\nol.source.ImageWMS.prototype.getRequestUrl_ = function (extent, size, pixelRatio, projection, params) {\r\n    if (pixelRatio !== 1) {\r\n        // Redondeamos porque si no GeoServer peta\r\n        const dpi = (90 * pixelRatio + 0.5) | 0;\r\n        params.MAP_RESOLUTION = dpi;\r\n        params.DPI = dpi;\r\n    }\r\n    return oldGetRequestUrl_.call(this, extent, size, pixelRatio, projection, params);\r\n};\r\n\r\n//////////////////////// end ol patches\r\n\r\nconst getRGBA = function (color, opacity) {\r\n    var result;\r\n    if (color) {\r\n        result = ol.color.asArray(color);\r\n        result = result.slice();\r\n    }\r\n    else {\r\n        result = [0, 0, 0, 1];\r\n    }\r\n    if (opacity !== undefined) {\r\n        result[3] = opacity;\r\n    }\r\n    return result;\r\n};\r\n\r\n/*\r\n * Obtiene el objeto de opciones de una vista que restringe los niveles de zoom activos sobre el mapa dependiendo de las opciones definidas sobre\r\n * el mapa base activo.\r\n */\r\nconst getResolutionOptions = function (mapWrap, layer, options) {\r\n    var view = mapWrap.map.getView();\r\n    var prevRes = view.getResolution();\r\n    // Si es móvil mantenemos un pixelRatio de 1. Solución a bug 32575.\r\n    // En desktop se tiene en cuenta pixelRatio para que el mapa no salga con zoom\r\n    // cuando el navegador lo tiene\r\n    const pixelRatio = TC.Util.detectMobile() ? 1 : mapWrap.map.pixelRatio_;\r\n\r\n    var pms = {\r\n        projection: view.getProjection(),\r\n        center: view.getCenter(),\r\n        resolution: prevRes,\r\n        enableRotation: false,\r\n        constrainResolution: true,\r\n        showFullExtent: true,\r\n        smoothExtentConstraint: true\r\n    };\r\n\r\n    if (mapWrap.parent.maxExtent) {\r\n        pms.extent = mapWrap.parent.maxExtent;\r\n    }\r\n\r\n    // GLS 06/03/2019 Corregimos bug 24832, si el mapa de fondo es el mapa en blanco, asignamos las resoluciones del mapa de fondo actual\r\n    var layerForResolutions = layer;\r\n    if (layer.type === TC.Consts.layerType.VECTOR && mapWrap.parent.getBaseLayer()) {\r\n        layerForResolutions = mapWrap.parent.getBaseLayer();\r\n    }\r\n\r\n    var res = layerForResolutions.getResolutions ? layerForResolutions.getResolutions() : [];\r\n    var maxRes;\r\n    var minRes;\r\n\r\n    if (res && res.length) {\r\n        maxRes = layerForResolutions.maxResolution || options?.maxResolution || res[0];\r\n        minRes = layerForResolutions.minResolution || options?.minResolution || res[res.length - 1];\r\n\r\n        var minResIx = res.indexOf(minRes);\r\n        var maxResIx = res.indexOf(maxRes);\r\n\r\n        pms.resolutions = res.slice(maxResIx, minResIx + 1);\r\n\r\n        if (pixelRatio !== 1) {\r\n            pms.resolutions = pms.resolutions.map(r => r * pixelRatio);\r\n        }\r\n    }\r\n    else {\r\n        maxRes = layerForResolutions.maxResolution;\r\n        minRes = layerForResolutions.minResolution;\r\n    }\r\n    if (minRes) {\r\n        minRes = minRes * pixelRatio;\r\n        pms.minResolution = minRes;\r\n        if (prevRes < minRes) {\r\n            pms.resolution = minRes;\r\n        }\r\n    }\r\n    if (maxRes) {\r\n        maxRes = maxRes * pixelRatio;\r\n        pms.maxResolution = maxRes;\r\n        if (prevRes > maxRes) {\r\n            pms.resolution = maxRes;\r\n        }\r\n    }\r\n\r\n    return pms;\r\n};\r\n\r\nconst constrainResolution = function (resolution, resolutions, maxResolutionError) {\r\n    if (!resolutions) {\r\n        return resolution;\r\n    }\r\n    return resolutions\r\n        .slice()\r\n        .sort(function (a, b) { return a - b })\r\n        .reduce(function (prev, elm) {\r\n            if (prev === 0 &&\r\n                (elm > resolution || Math.abs(1 - resolution / elm) < maxResolutionError)) {\r\n                return elm;\r\n            }\r\n            return prev;\r\n        }, 0);\r\n};\r\n\r\nTC.wrap.Map.prototype.setMap = function () {\r\n    var self = this;\r\n    var center = [\r\n        (self.parent.initialExtent[0] + self.parent.initialExtent[2]) / 2,\r\n        (self.parent.initialExtent[1] + self.parent.initialExtent[3]) / 2\r\n    ];\r\n\r\n    var proj4Obj = proj4(self.parent.crs);\r\n    var addEquivalentProjections = function () {\r\n        // Añadimos proyecciones equivalentes y transformaciones necesarias.\r\n        var crsCode = self.parent.crs.substr(self.parent.crs.lastIndexOf(':') + 1);\r\n\r\n        var projOptions = {\r\n            units: proj4Obj.oProj.units\r\n        };\r\n\r\n        var equivalentProjections = [];\r\n        if (crsCode !== '4326') { // Este código ya está metido, no lo machacamos\r\n            projOptions.code = 'EPSG:' + crsCode;\r\n            equivalentProjections.push(new ol.proj.Projection(projOptions));\r\n            projOptions.code = 'urn:ogc:def:crs:EPSG::' + crsCode;\r\n            equivalentProjections.push(new ol.proj.Projection(projOptions));\r\n\r\n            ol.proj.addEquivalentProjections(equivalentProjections);\r\n        }\r\n\r\n        ol.proj.proj4.register(proj4);\r\n\r\n    };\r\n\r\n    addEquivalentProjections();\r\n\r\n    var projOptions = {\r\n        code: self.parent.crs,\r\n        units: proj4Obj.oProj.units\r\n    };\r\n    if (self.parent.crs === 'EPSG:4326') {\r\n        projOptions.axisOrientation = 'neu';\r\n    }\r\n    var projection = new ol.proj.Projection(projOptions);\r\n\r\n    var interactions = ol.interaction.defaults();\r\n\r\n    var viewOptions = {\r\n        projection: projection,\r\n        center: center,\r\n        enableRotation: false,\r\n        constrainResolution: true,\r\n        showFullExtent: true,\r\n        smoothExtentConstraint: true\r\n    };\r\n    const extentForResolution = self.parent.maxExtent || self.parent.initialExtent;\r\n    if (self.parent.maxExtent) {\r\n        viewOptions.extent = self.parent.maxExtent;\r\n    }\r\n    var rect = self.parent.div.getBoundingClientRect();\r\n    var dx = extentForResolution[2] - extentForResolution[0];\r\n    var dy = extentForResolution[3] - extentForResolution[1];\r\n    viewOptions.resolution = Math.max(dx / rect.width, dy / rect.height);\r\n\r\n    self.map = new ol.Map({\r\n        target: self.parent.div,\r\n        view: new ol.View(viewOptions),\r\n        controls: [],\r\n        interactions: interactions\r\n    });\r\n\r\n    //if (!TC.Util.detectMobile()) {\r\n    //    // Parche para corregir https://github.com/openlayers/openlayers/issues/2904\r\n    //    // saben que tienen un bug cuando se trabaja sobre un mapa con zoom\r\n    //    self.map.getEventPixel = function (event) {\r\n    //        var viewportPosition = this.viewport_.getBoundingClientRect();\r\n    //        var eventPosition = event.changedTouches ? event.changedTouches[0] : event;\r\n    //        eventPosition = eventPosition.clientX ? eventPosition : (eventPosition.pointerEvent ? eventPosition.pointerEvent : eventPosition);\r\n    //        return [\r\n    //            (eventPosition.clientX - viewportPosition.left) * window.devicePixelRatio,\r\n    //            (eventPosition.clientY - viewportPosition.top) * window.devicePixelRatio\r\n    //        ];\r\n    //    };\r\n    //}\r\n\r\n    self.map._wrap = self;\r\n    self._promise = Promise.resolve(self.map);\r\n\r\n    // mantenemos el ancho y alto del canvas en números enteros\r\n    self.manageSize.call(self.map);\r\n\r\n    // Para evitar estiramientos en canvas\r\n    var updateSize = function () {\r\n        self.updateSize();\r\n    };\r\n    //if (window.ResizeObserver) {\r\n    //    self.parent.loaded(function () {\r\n    //        const resizeObserver = new ResizeObserver(updateSize);\r\n    //        resizeObserver.observe(self.parent.div);\r\n    //    });\r\n    //}\r\n    //self.map.getViewport().addEventListener(RESIZE, updateSize);\r\n    self.parent.one(TC.Consts.event.MAPLOAD, updateSize);\r\n\r\n    self.map.on(SINGLECLICK, function (e) {\r\n\r\n        if (self.parent.view === TC.Consts.view.PRINTING) {\r\n            return;\r\n        }\r\n\r\n        self.parent.workLayers.forEach(function (wl) {\r\n            delete wl._noFeatureClicked;\r\n        });\r\n        var featuresInLayers = self.parent.workLayers.map(function () {\r\n            return false;\r\n        });\r\n        self.map.forEachFeatureAtPixel(e.pixel,\r\n            function (feature, layer) {\r\n                if (feature._wrap && feature._wrap.parent.showsPopup) {\r\n                    for (var i = 0; i < self.parent.workLayers.length; i++) {\r\n                        var wl = self.parent.workLayers[i];\r\n                        if (wl.wrap.layer === layer) {\r\n                            featuresInLayers[i] = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    self.parent.trigger(TC.Consts.event.FEATURECLICK, { feature: feature._wrap.parent });\r\n                    return feature;\r\n                }\r\n            },\r\n            {\r\n                hitTolerance: hitTolerance\r\n            });\r\n        for (var i = 0; i < featuresInLayers.length; i++) {\r\n            if (!featuresInLayers[i]) {\r\n                self.parent.trigger(TC.Consts.event.NOFEATURECLICK, { layer: self.parent.workLayers[i] });\r\n            }\r\n        }\r\n    });\r\n\r\n    let olView;\r\n\r\n    // GLS: 13/02/2019 cambiamos el orden de las suscripciones a eventos de cambio de resolución y moveend\r\n    // para gestionar el borrado del estado inicial. Si no lo hacemos el cambio al extent inicial se registra como evento de usuario\r\n    // porque la carga inicial del mapa con promesas nativas es más rápido que antes.\r\n    // Bug:26001 Borrar estado inicial al entrar\r\n    const addMoveEndListener = function () {\r\n        self.map.on(MOVEEND, function () {\r\n            self.parent.trigger(TC.Consts.event.ZOOM);\r\n        });\r\n    };\r\n\r\n    const changeResolutionListener = function (_e) {\r\n        const resolution = olView.getResolution();\r\n        const crs = olView.getProjection().getCode();\r\n        self.parent.layers\r\n            .filter(l => l.type === TC.Consts.layerType.WMS)\r\n            .forEach(l => {\r\n                const extent = l.getExtent({ crs: crs });\r\n                if (extent) {\r\n                    const bufferedExtent = bufferExtent(extent, resolution, 100); // 100 pixels de buffer\r\n                    l.wrap.layer.setExtent(bufferedExtent);\r\n                }\r\n            });\r\n    };\r\n\r\n    const addChangeResolutionListener = function () {\r\n        olView.on('change:resolution', changeResolutionListener);\r\n    };\r\n\r\n    const onChangeView = function () {\r\n        olView = self.map.getView();\r\n        addChangeResolutionListener();\r\n        changeResolutionListener();\r\n    };\r\n    addMoveEndListener();\r\n    onChangeView();\r\n\r\n    olView.on('change:resolution', function (_e) {\r\n        self.parent.trigger(TC.Consts.event.BEFOREZOOM);\r\n    }, self.parent);\r\n\r\n    self.map.on('change:view', onChangeView);\r\n\r\n    /*\r\n     * Restringe los niveles de zoom activos sobre el mapa dependiendo de las opciones definidas sobre\r\n     * el mapa base activo.\r\n     */\r\n    const limitZoomLevels = function (layer, options) {\r\n        if (layer) {\r\n            var pms = getResolutionOptions(self, layer, options);\r\n\r\n            var view = new ol.View(pms);\r\n            self.map.setView(view);\r\n            self.map.render();\r\n        }\r\n    };\r\n\r\n    self.parent.on(TC.Consts.event.BEFOREBASELAYERCHANGE, function (evt) {\r\n        // Solo se limitan las resoluciones cuando estamos en un CRS por defecto, donde no se repixelan teselas\r\n        if (self.parent.crs === self.parent.options.crs && !self.parent.on3DView && evt.newLayer.type !== TC.Consts.layerType.VECTOR) {\r\n            const oldResolutions = evt.oldLayer.getResolutions();\r\n            let modelLayer = evt.newLayer;\r\n            const limitZoomOptions = {};\r\n            if (!evt.newLayer.getResolutions() && oldResolutions) {\r\n                // Si la capa nueva no tiene resoluciones y la vieja sí, mantenemos las resoluciones anteriores.\r\n                // Esto evita que OpenLayers se invente los niveles de zoom y las resoluciones para la capa dinámica.\r\n                modelLayer = evt.oldLayer;\r\n                // Pero mantenemos los límites de resolución de la nueva capa.\r\n                limitZoomOptions.minResolution = evt.newLayer.minResolution;\r\n                limitZoomOptions.maxResolution = evt.newLayer.maxResolution;\r\n            }\r\n            self.parent.one(TC.Consts.event.BASELAYERCHANGE, function (_e) {\r\n                limitZoomLevels(modelLayer, limitZoomOptions);\r\n            });\r\n        }\r\n    });\r\n    self.parent.on(TC.Consts.event.MAPLOAD, function (_e) {\r\n        limitZoomLevels(self.parent.getBaseLayer());\r\n    });\r\n\r\n    const olMapViewport = self.map.getViewport();\r\n\r\n    olMapViewport.addEventListener(TC.Consts.event.MOUSEMOVE, function (e) {\r\n        var hit = false;\r\n\r\n        if (!self.parent.activeControl || !self.parent.activeControl.isExclusive()) {\r\n\r\n            if (self.parent.view === TC.Consts.view.PRINTING) {\r\n                return;\r\n            }\r\n\r\n            var pixel = self.map.getEventPixel(e);\r\n            hit = self.map.forEachFeatureAtPixel(pixel, function (feature, _layer) {\r\n                var result = true;\r\n                if (feature._wrap && !feature._wrap.parent.showsPopup && !feature._wrap.parent.options.selectable) {\r\n                    result = false;\r\n                }\r\n\r\n                if (result && feature._wrap) {\r\n                    self.parent.trigger(TC.Consts.event.FEATUREOVER, {\r\n                        feature: feature._wrap.parent\r\n                    });\r\n                }\r\n\r\n                return result;\r\n            }, { hitTolerance: hitTolerance });\r\n        }\r\n\r\n        if (hit) {\r\n            olMapViewport.style.cursor = 'pointer';\r\n        } else {\r\n            olMapViewport.style.cursor = '';\r\n            //self.parent.trigger(TC.Consts.event.FEATUREOUT);\r\n        }\r\n    });\r\n\r\n    // Listener para cuando cambia devicePixelRatio\r\n    (function updatePixelRatio() {\r\n        matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`)\r\n            .addEventListener('change', updatePixelRatio, { once: true });\r\n        //self.map.getViewport().querySelectorAll('.ol-layer canvas').forEach();\r\n        self.map.pixelRatio_ = window.devicePixelRatio;\r\n        limitZoomLevels(self.parent.baseLayer);\r\n        self.manageSize();\r\n    })();\r\n};\r\n\r\nTC.wrap.Map.prototype.updateSize = function () {\r\n    this.map.updateSize();\r\n};\r\n\r\nvar getMetersPerUnit = function (proj, extentInDegrees) {\r\n    var units = proj.getUnits();\r\n    if (!units || units === ol.proj.Units.DEGREES) {\r\n        return TC.Util.getMetersPerDegree(extentInDegrees);\r\n    }\r\n    return ol.proj.METERS_PER_UNIT[units];\r\n};\r\n\r\nTC.wrap.Map.prototype.getMetersPerUnit = function () {\r\n    var self = this;\r\n    return getMetersPerUnit(ol.proj.get(self.parent.crs), self.getExtent());\r\n};\r\n\r\nvar getUnitRatio = function (options) {\r\n    var self = this;\r\n    options = options || {};\r\n    var defaultCrs = self.parent.options.crs || TC.Cfg.crs;\r\n    var defaultProj = ol.proj.get(defaultCrs);\r\n    var newProj = ol.proj.get(options.crs);\r\n    return getMetersPerUnit(newProj, options.extentInDegrees) / getMetersPerUnit(defaultProj, options.extentInDegrees);\r\n};\r\n\r\nvar normalizeProjection = function (options) {\r\n    var result;\r\n    if (options.axisOrientation) {\r\n        result = new ol.proj.Projection({\r\n            code: options.crs,\r\n            axisOrientation: options.axisOrientation\r\n        });\r\n    }\r\n    else {\r\n        result = ol.proj.get(options.crs);\r\n    }\r\n    if (!result.getUnits()) {\r\n        result.units_ = ol.proj.Units.DEGREES;\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.Map.prototype.setProjection = function (options) {\r\n    const self = this;\r\n    options = options || {};\r\n    const baseLayer = options.baseLayer || self.parent.baseLayer;\r\n    var extent;\r\n    if (options.extent) {\r\n        extent = options.extent;\r\n    }\r\n    else {\r\n        extent = ol.proj.transformExtent(self.getExtent(), self.parent.crs, options.crs);\r\n    }\r\n    const extentInDegrees = ol.proj.transformExtent(extent, options.crs, 'EPSG:4326');\r\n    const unitRatio = getUnitRatio.call(self, {\r\n        crs: options.crs,\r\n        extentInDegrees: extentInDegrees\r\n    });\r\n    const projection = normalizeProjection(options);\r\n    const oldView = self.map.getView();\r\n    const viewOptions = {\r\n        projection: projection,\r\n        enableRotation: false,\r\n        constrainResolution: true,\r\n        showFullExtent: true,\r\n        smoothExtentConstraint: true\r\n    };\r\n    const resolutions = baseLayer.getResolutions();\r\n\r\n    if (resolutions && resolutions.length) {\r\n        viewOptions.resolutions = resolutions;\r\n    }\r\n    else {\r\n        viewOptions.minZoom = oldView.getMinZoom();\r\n        viewOptions.maxZoom = oldView.getMaxZoom();\r\n        const minResolution = baseLayer.wrap.layer.getMinResolution();\r\n        const maxResolution = baseLayer.wrap.layer.getMaxResolution();\r\n        var transformFactor = 1;\r\n        if (minResolution === 0 || maxResolution === Number.POSITIVE_INFINITY) {\r\n            const oldUnitRatio = getUnitRatio.call(self, {\r\n                crs: self.parent.crs,\r\n                extentInDegrees: extentInDegrees\r\n            });\r\n            transformFactor = oldUnitRatio / unitRatio;\r\n        }\r\n        if (minResolution === 0) {\r\n            viewOptions.minResolution = oldView.getMinResolution() * transformFactor;\r\n        }\r\n        else {\r\n            viewOptions.minResolution = minResolution;\r\n        }\r\n        if (maxResolution === Number.POSITIVE_INFINITY) {\r\n            viewOptions.maxResolution = oldView.getMaxResolution() * transformFactor;\r\n        }\r\n        else {\r\n            viewOptions.maxResolution = maxResolution;\r\n        }\r\n    }\r\n\r\n    // Reescribimos el extent de las capas para que sigan siendo visibles\r\n    self.parent.workLayers.forEach(l => {\r\n        if (l.type === TC.Consts.layerType.WMS) {\r\n            const oldExtent = l.getExtent({ crs: options.crs });\r\n            if (oldExtent) {\r\n                l.wrap.layer.setExtent(l.getExtent());\r\n            }\r\n        }\r\n    });\r\n\r\n    // GLS: transformamos también el centro     \r\n    viewOptions.center = ol.proj.transform(self.getCenter(), self.parent.crs, options.crs);\r\n\r\n    self.parent.initialExtent = unitRatio !== 1 ? ol.proj.transformExtent(self.parent.initialExtent, self.parent.crs, options.crs) : self.parent.options.initialExtent;\r\n    if (self.parent.options.maxExtent) {\r\n        self.parent.maxExtent = unitRatio !== 1 ? ol.proj.transformExtent(self.parent.maxExtent, self.parent.crs, options.crs) : self.parent.options.maxExtent;\r\n        viewOptions.extent = self.parent.maxExtent;\r\n    }\r\n    var newView = new ol.View(viewOptions);\r\n    self.map.setView(newView);\r\n    newView.fit(extent, { nearest: true });\r\n};\r\n\r\n/*\r\n *  insertLayer: inserts OpenLayers layer at index\r\n *  Parameters: OpenLayers.Layer, number\r\n */\r\nTC.wrap.Map.prototype.insertLayer = function (olLayer, idx) {\r\n    var self = this;\r\n    var layers = self.map.getLayers();\r\n    var alreadyExists = false;\r\n    for (var i = 0; i < layers.getLength(); i++) {\r\n        if (layers.item(i) === olLayer) {\r\n            alreadyExists = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    //Silme: secondBaseLayer \r\n    //Incrementen idx en 1 per a tenir en compte la segona capa de fons;\r\n    if (secondBaseLayer == true) {\r\n        try {\r\n            //if (olLayer.type != \"TILE\") {\r\n            //if (!olLayer._wrap.parent.isRaster()) {\r\n            if (olLayer._wrap.parent.type != \"WMTS\") {\r\n                idx = idx + 1;\r\n            }\r\n        }\r\n        catch (err) { }\r\n    }\r\n\r\n    const wrap = olLayer._wrap;\r\n    if (!wrap.parent.isBase && wrap.parent.type === TC.Consts.layerType.WMS) {\r\n        const layerExtent = wrap.parent.getExtent();\r\n        if (layerExtent) {\r\n            olLayer.setExtent(bufferExtent(layerExtent, self.getResolution(), 100)); // 100 pixels de buffer\r\n        }\r\n    }\r\n\r\n    if (alreadyExists) {\r\n        layers.remove(olLayer);\r\n        layers.insertAt(idx, olLayer);\r\n    }\r\n    else {\r\n        if (idx < 0) {\r\n            layers.push(olLayer);\r\n        }\r\n        else {\r\n            layers.insertAt(idx, olLayer);\r\n        }\r\n        // Solo se limitan las resoluciones cuando estamos en un CRS por defecto, donde no se repixelan teselas\r\n        var view = self.map.getView();\r\n        if (self.parent.crs === self.parent.options.crs) {\r\n            if (olLayer instanceof ol.layer.Tile) {\r\n                var resolutions = olLayer.getSource().getResolutions();\r\n                view.maxResolution_ = resolutions[0];\r\n                view.minResolution_ = resolutions[resolutions.length - 1];\r\n            }\r\n        }\r\n        else {\r\n            // Cambiamos los límites de resolución de la capa a los de la vista. Esto lo hacemos porque su resolución está en otro CRS.\r\n            if (olLayer instanceof ol.layer.Tile) {\r\n                olLayer.setMaxResolution(view.getMaxResolution());\r\n                olLayer.setMinResolution(view.getMinResolution());\r\n            }\r\n        }\r\n\r\n        var loadingTileCount = 0;\r\n\r\n        var beforeTileLoadHandler = function (_e) {\r\n            wrap.parent.state = TC.Layer.state.LOADING;\r\n            if (loadingTileCount <= 0) {\r\n                loadingTileCount = 0;\r\n                self.parent.trigger(TC.Consts.event.BEFORELAYERUPDATE, { layer: wrap.parent });\r\n            }\r\n            olLayer._loadingTileCount = olLayer._loadingTileCount + 1;\r\n        };\r\n        if (wrap.parent.state === TC.Layer.state.LOADING && wrap.parent.isRaster()) {\r\n            beforeTileLoadHandler();\r\n        }\r\n        wrap.$events.on(TC.Consts.event.BEFORETILELOAD, beforeTileLoadHandler);\r\n\r\n        wrap.$events.on(TC.Consts.event.TILELOAD + ' ' + TC.Consts.event.TILELOADERROR, function (_e) {\r\n            loadingTileCount = loadingTileCount - 1;\r\n            if (loadingTileCount <= 0) {\r\n                loadingTileCount = 0;\r\n                wrap.parent.state = TC.Layer.state.IDLE;\r\n                self.parent.trigger(TC.Consts.event.LAYERUPDATE, { layer: wrap.parent });\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\nTC.wrap.Map.prototype.removeLayer = function (olLayer) {\r\n    this.map.removeLayer(olLayer);\r\n};\r\n\r\nTC.wrap.Map.prototype.getLayerCount = function () {\r\n    return this.map.getLayerGroup().getLayers().getLength();\r\n};\r\n\r\nTC.wrap.Map.prototype.indexOfFirstVector = function () {\r\n    var result = -1;\r\n    this.map.getLayerGroup().getLayers().forEach(function (l, i) {\r\n        if (l instanceof ol.layer.Vector && result === -1) {\r\n            result = i;\r\n        }\r\n    });\r\n    return result;\r\n};\r\n\r\nTC.wrap.Map.prototype.getLayerIndex = function (olLayer) {\r\n    var result = -1;\r\n    this.map.getLayerGroup().getLayers().forEach(function (elm, idx) {\r\n        if (elm === olLayer) {\r\n            result = idx;\r\n        }\r\n    });\r\n    return result;\r\n};\r\n\r\nTC.wrap.Map.prototype.setLayerIndex = function (olLayer, index) {\r\n    var layers = this.map.getLayers();\r\n    var list = layers.getArray();\r\n    var ix = list.indexOf(olLayer);\r\n\r\n    if (ix > -1 && ix !== index) {\r\n        this.map.removeLayer(olLayer);\r\n        this.insertLayer(olLayer, index);\r\n        //layers.setAt(index, olLayer);\r\n    }\r\n    else {\r\n        //no está el layer, así que no hago nada\r\n    }\r\n\r\n};\r\n\r\nTC.wrap.Map.prototype.setBaseLayer = function (olLayer) {\r\n    var self = this;\r\n    return new Promise(function (resolve, _reject) {\r\n        var setLayer = function (curBl) {\r\n            // GLS: si se llega después de una animación el valor de self.parent.getBaseLayer() ya es el definitivo y no el actual lo que provoca efectos indeseados. \r\n            // ir a línea 1313: paso como parámetro el baseLayer actual en el caso de animación.\r\n            curBl = curBl || self.parent.getBaseLayer();\r\n            if (curBl) {\r\n                //self.map.removeLayer(curBl.wrap.layer); //Silme: secondBaseLayer\r\n                if (olLayer instanceof ol.layer.Image) { // Si es imagen no teselada\r\n                    olLayer._wrap.setProjection({\r\n                        crs: self.parent.crs\r\n                    });\r\n                }\r\n\r\n                if (olLayer._wrap.parent.type === TC.Consts.layerType.WMTS) {\r\n                    var layerProjectionOptions = { crs: self.parent.crs, oldCrs: olLayer.getSource().getProjection().getCode() };\r\n\r\n                    if (layerProjectionOptions.oldCrs !== layerProjectionOptions.crs) {\r\n                        olLayer._wrap.parent.setProjection(layerProjectionOptions);\r\n                    }\r\n                }\r\n\r\n                //if (olLayer instanceof ol.layer.Tile) { // Si es imagen teselada\r\n                //    const view = self.map.getView();\r\n                //    const resolutions = olLayer.getSource().getResolutions();\r\n                //    if (resolutions) {\r\n                //        view.options_.resolutions = resolutions;\r\n                //        view.applyOptions_(view.options_);\r\n                //    }\r\n                //}\r\n            }\r\n\r\n            //Silme: secondBaseLayer\r\n            if (activeBaseLayer == 0) {\r\n                try {\r\n                    self.removeLayer(self.map.getLayers().array_[0]);\r\n                }\r\n                catch (err) {\r\n                    console.log(err);\r\n                }\r\n                try {\r\n                    self.insertLayer(olLayer, 0);\r\n                }\r\n                catch (Err) { }\r\n\r\n                if (silmeMap.map.getLayers().array_[0]._wrap.parent.isRaster() && silmeMap.map.getLayers().array_[1]._wrap.parent.isRaster()) { \r\n                    setSpan1();\r\n                }\r\n            }\r\n            else {\r\n                try {\r\n                    self.removeLayer(self.map.getLayers().array_[1]);\r\n                }\r\n                catch (err) {\r\n                    console.log(err);\r\n                }\r\n                try {\r\n                    self.insertLayer(olLayer, 1);\r\n                }\r\n                catch (Err) { }\r\n                setSpan2();\r\n            }\r\n\r\n            //Silme self.insertLayer(olLayer, 0);\r\n            self.map.getControls().forEach(function (ctl) {\r\n                if (ctl instanceof ol.control.ZoomSlider) {\r\n                    ctl.initSlider_();\r\n                }\r\n            });\r\n            resolve();\r\n        };\r\n\r\n        // Toda esta lógica antes de llamar a setLayer() es para hacer un zoom a la nueva resolución\r\n        // cuando la nueva capa no llega a la resolución actual\r\n        var viewOptions = getResolutionOptions(self, olLayer._wrap.parent);\r\n        var view = self.map.getView();\r\n        var currentResolution = view.getResolution();\r\n        if (!viewOptions.resolutions && (viewOptions.minResolution || viewOptions.maxResolution)) {\r\n            const resolutions = view.getResolutions();\r\n            if (resolutions) {\r\n                const newResolutions = resolutions\r\n                    .filter(r => {\r\n                        if (viewOptions.minResolution && r < viewOptions.minResolution) {\r\n                            return false;\r\n                        }\r\n                        if (viewOptions.maxResolution && r > viewOptions.maxResolution) {\r\n                            return false;\r\n                        }\r\n                        return true;\r\n                    });\r\n                if (newResolutions.length < resolutions.length) {\r\n                    viewOptions.resolutions = newResolutions;\r\n                }\r\n            }\r\n        }\r\n        if (viewOptions.resolutions) {\r\n            const newView = new ol.View(viewOptions);\r\n            // buscamos la nueva resolución según las nuevas restricciones de la capa\r\n            var newRes = constrainResolution(currentResolution, viewOptions.resolutions, self.parent.options.maxResolutionError);\r\n            if (newRes !== currentResolution && self.parent.isLoaded) {\r\n                view.animate({ resolution: newRes, duration: TC.Consts.ZOOM_ANIMATION_DURATION }, function () {\r\n                    self.map.setView(newView);\r\n                    setLayer(self.parent.getBaseLayer());\r\n                });\r\n            }\r\n            else {\r\n                self.map.setView(newView);\r\n                newView.setResolution(newRes);\r\n                setLayer();\r\n            }\r\n        }\r\n        else {\r\n            setLayer();\r\n        }\r\n    });\r\n};\r\n\r\nTC.wrap.Map.prototype.setExtent = function (extent, options, callback) {\r\n    const self = this;\r\n    if (TC.Util.isFunction(options)) {\r\n        callback = options;\r\n        options = {};\r\n    }\r\n    else {\r\n        options = options || {};\r\n    }\r\n\r\n    const setPromise = function (extent) {\r\n        self._setExtentPromise = new Promise(function (resolve, _reject) {\r\n            // Timeout porque OL3 no tiene evento featuresadded, por tanto cuando se activa map.options.zoomToMarkers\r\n            // se lanza un setExtent por marcador. El timeout evita ejecuciones a lo tonto.\r\n            clearTimeout(self._timeout);\r\n            self._timeout = setTimeout(function applyExtent() {\r\n\r\n                const getExtentAndEnd = function () {\r\n                    const extent = self.getExtent();\r\n                    if (TC.Util.isFunction(callback)) {\r\n                        callback(extent);\r\n                    }\r\n                    resolve(extent);\r\n                };\r\n\r\n                const fitOptions = {\r\n                    callback: getExtentAndEnd,\r\n                    nearest: !options.contain\r\n                };\r\n                if (options.animate === void (0) || options.animate) {\r\n                    // Si no se especifica animate, se anima\r\n                    fitOptions.duration = TC.Consts.ZOOM_ANIMATION_DURATION;\r\n                }\r\n\r\n                self.map.getView().fit(extent, fitOptions);\r\n            }, 50);\r\n        });\r\n    };\r\n    Promise.resolve(self._setExtentPromise).finally(function () {\r\n        setPromise(extent);\r\n    });\r\n\r\n    return self._setExtentPromise;\r\n};\r\n\r\nTC.wrap.Map.prototype.getExtent = function () {\r\n    return this.map.getView().calculateExtent(this.map.getSize());\r\n};\r\n\r\nTC.wrap.Map.prototype.setCenter = function (coords, options) {\r\n    const self = this;\r\n    return new Promise(function (resolve, _reject) {\r\n        const callback = function () {\r\n            resolve();\r\n        };\r\n\r\n        const opts = options || {};\r\n        const view = self.map.getView();\r\n\r\n        if (opts.animate) {\r\n            view.animate({\r\n                center: coords, duration: TC.Consts.ZOOM_ANIMATION_DURATION\r\n            }, callback);\r\n        }\r\n        else {\r\n            view.setCenter(coords);\r\n            resolve();\r\n        }\r\n    });\r\n};\r\n\r\nTC.wrap.Map.prototype.getCenter = function () {\r\n    return this.map.getView().getCenter();\r\n};\r\n\r\nTC.wrap.Map.prototype.getResolution = function () {\r\n    return this.map.getView().getResolution();\r\n};\r\n\r\nTC.wrap.Map.prototype.setResolution = async function (resolution) {\r\n    const olMap = await this.getMap();\r\n    olMap.getView().setResolution(resolution);\r\n    return resolution;\r\n};\r\n\r\nTC.wrap.Map.prototype.setRotation = function (rotation) {\r\n    this.getMap().then(function (olMap) {\r\n        olMap.getView().setRotation(rotation);\r\n    });\r\n};\r\n\r\nTC.wrap.Map.prototype.getRotation = function () {\r\n    return this.map.getView().getRotation();\r\n};\r\n\r\nTC.wrap.Map.prototype.getResolutions = function () {\r\n    return this.map.getView().getResolutions() || [];\r\n};\r\n\r\nTC.wrap.Map.prototype.getCoordinateFromPixel = function (xy) {\r\n    return this.map.getCoordinateFromPixel(xy);\r\n};\r\n\r\nTC.wrap.Map.prototype.getPixelFromCoordinate = function (coord) {\r\n    return this.map.getPixelFromCoordinate(coord);\r\n};\r\n\r\nTC.wrap.Map.prototype.getViewport = function (options) {\r\n    const self = this;\r\n    var result;\r\n    var opts = options || {\r\n    };\r\n    if (opts.synchronous) {\r\n        result = self.map.getViewport();\r\n    }\r\n    else {\r\n        result = new Promise(function (resolve, _reject) {\r\n            self.getMap().then(function (olMap) {\r\n                resolve(olMap.getViewport());\r\n            });\r\n        });\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.Map.prototype.getCanvas = function () {\r\n    const self = this;\r\n    return Array.from(self.parent.div.querySelectorAll('.ol-viewport canvas:not(.tc-ctl-ovmap canvas)'));\r\n};\r\n\r\nTC.wrap.Map.prototype.isNative = function (map) {\r\n    return map instanceof ol.Map;\r\n};\r\n\r\nTC.wrap.Map.prototype.isGeo = function () {\r\n    var units = this.map.getView().getProjection().getUnits();\r\n    return !units || units === ol.proj.Units.DEGREES;\r\n};\r\n\r\nTC.wrap.Map.prototype.addPopup = function (popupCtl) {\r\n    const self = this;\r\n    return new Promise(function (resolve, _reject) {\r\n        var draggable = popupCtl.options.draggable === undefined || popupCtl.options.draggable;\r\n        TC.loadJS(\r\n            draggable && !window.Draggabilly,\r\n            [TC.apiLocation + TC.Consts.url.DRAGGABILLY],\r\n            function () {\r\n                self.getMap().then(function (olMap) {\r\n                    if (!popupCtl.wrap.popup) {\r\n                        // No popups yet\r\n                        var popup = new ol.Overlay({\r\n                            element: popupCtl.popupDiv,\r\n                            positioning: ol.OverlayPositioning.BOTTOM_LEFT\r\n                        });\r\n                        olMap.addOverlay(popup);\r\n                        popupCtl.wrap.popup = popup;\r\n\r\n                        //popupCtl._firstRender.resolve();\r\n                        //popupCtl.trigger(TC.Consts.event.CONTROLRENDER);\r\n                        const olMapViewport = olMap.getViewport();\r\n\r\n                        if (draggable) {\r\n                            const container = popupCtl.popupDiv.parentElement;\r\n                            popupCtl.popupDiv.classList.add(TC.Consts.classes.DRAGGABLE);\r\n\r\n\r\n                            container.addEventListener('touchmove', function (e) {\r\n                                var parent = e.target;\r\n                                do {\r\n                                    if (parent.matches && parent.matches('.tc-ctl-finfo-layer-content')) {\r\n                                        e.stopPropagation();\r\n                                        break;\r\n                                    }\r\n                                    parent = parent.parentElement;\r\n                                }\r\n                                while (parent);\r\n                            }, { passive: true });\r\n\r\n                            // Tuneamos Draggabilly para que acepte excepciones a los asideros del elemento.\r\n                            const drag = new Draggabilly(container, {\r\n                                not: 'th,td, td *,input,select,.tc-ctl-finfo-coords'\r\n                            });\r\n                            drag.handleEvent = function (event) {\r\n                                const notSelector = this.options.not;\r\n                                if (notSelector) {\r\n                                    let elm = event.target;\r\n                                    let isException = false;\r\n                                    while (elm && !isException) {\r\n                                        isException = elm.matches && elm.matches(notSelector);\r\n                                        elm = elm.parentElement;\r\n                                    }\r\n                                    if (isException) {\r\n                                        return;\r\n                                    }\r\n                                }\r\n                                Draggabilly.prototype.handleEvent.call(this, event);\r\n                            };\r\n                            drag.on('pointerDown', function (e, pointer) {\r\n                                var bcr = e.target.getBoundingClientRect();\r\n                                // Si estamos pulsando sobre una barra de scroll abortamos drag\r\n                                if (bcr.left + e.target.clientWidth < pointer.pageX || bcr.top + e.target.clientHeight < pointer.pageY) {\r\n                                    drag._pointerCancel(e, pointer);\r\n                                    return false;\r\n                                }\r\n                            });\r\n                            drag.on('dragStart', function (_e, _pointer) {\r\n                                popupCtl.setDragging(true);\r\n                                popupCtl._currentOffset = popup.getOffset();\r\n                                if (popupCtl._previousContainerPosition) {\r\n                                    var mapSize = olMap.getSize();\r\n                                    popup.setPosition(olMap.getCoordinateFromPixel([popupCtl._previousContainerPosition[0], mapSize[1] - popupCtl._previousContainerPosition[1]]));\r\n                                    popupCtl._currentOffset = [0, 0];\r\n                                    popup.setOffset(popupCtl._currentOffset);\r\n                                    delete popupCtl._previousContainerPosition;\r\n                                }\r\n                                else {\r\n                                    popupCtl._currentOffset = popup.getOffset();\r\n                                }\r\n                            });\r\n                            drag.on('dragEnd', function (_e) {\r\n                                popupCtl.setDragging(false);\r\n                                var coord1 = olMap.getCoordinateFromPixel([0, 0]);\r\n                                var coord2 = olMap.getCoordinateFromPixel(popup.getOffset());\r\n                                var coordDelta = [coord2[0] - coord1[0], coord2[1] - coord1[1]];\r\n                                var position = popup.getPosition();\r\n                                popup.setPosition([position[0] + coordDelta[0], position[1] + coordDelta[1]]);\r\n                                popup.setOffset([0, 0]);\r\n                                popupCtl._currentOffset = [0, 0];\r\n\r\n                                const containerRect = container.getBoundingClientRect();\r\n                                popupCtl._previousContainerPosition = [containerRect.left, containerRect.bottom];\r\n                            });\r\n                            //drag.on('dragMove', function (e, pointer, moveVector) {\r\n                            //popup.setOffset([popupCtl._currentOffset[0] + moveVector.x, popupCtl._currentOffset[1] + moveVector.y]);\r\n                            //});\r\n                            //.drag(function (ev, dd) {\r\n                            //    if (!ev.buttons && !Modernizr.touch) { // Evitamos que se mantenga el drag si no hay botón pulsado (p.e. en IE pulsando una scrollbar)\r\n                            //        return false;\r\n                            //    }\r\n                            //    popup.setOffset([popupCtl._currentOffset[0] + dd.deltaX, popupCtl._currentOffset[1] + dd.deltaY]);\r\n                            //}, {\r\n                            //    not: 'th,td, td *,input,select,.tc-ctl-finfo-coords'\r\n                            //    })                                \r\n                        }\r\n\r\n                        const mouseMoveHandler = function (e) {\r\n                            const viewport = olMap.getViewport();\r\n                            var hit = false;\r\n                            if (!self.parent.activeControl || !self.parent.activeControl.isExclusive()) {\r\n                                var pixel = olMap.getEventPixel(e);\r\n                                hit = olMap.forEachFeatureAtPixel(pixel, function (feature, _layer) {\r\n                                    var result = true;\r\n                                    if (feature._wrap && !feature._wrap.parent.showsPopup) {\r\n                                        result = false;\r\n                                    }\r\n                                    return result;\r\n                                },\r\n                                    {\r\n                                        hitTolerance: hitTolerance\r\n                                    });\r\n                            }\r\n                            if (hit) {\r\n                                viewport.style.cursor = 'pointer';\r\n                            } else {\r\n                                viewport.style.cursor = '';\r\n                            }\r\n                        };\r\n\r\n                        // change mouse cursor when over marker\r\n                        olMapViewport.removeEventListener(MOUSEMOVE, mouseMoveHandler);\r\n                        olMapViewport.addEventListener(MOUSEMOVE, mouseMoveHandler);\r\n                    }\r\n                });\r\n                resolve();\r\n            }\r\n        );\r\n    });\r\n};\r\n\r\nTC.wrap.Map.prototype.hidePopup = function (popupCtl) {\r\n    var self = this;\r\n    self.parent.currentFeature = null;\r\n    if (popupCtl.popupDiv) {\r\n        popupCtl.popupDiv.classList.remove(TC.Consts.classes.VISIBLE);\r\n    }\r\n};\r\n\r\nTC.wrap.Map.prototype.manageSize = function () {\r\n    const self = this;\r\n    self.pixelRatio_ = window.devicePixelRatio;\r\n\r\n    // Para controlar que el mapa no se vea borroso porque no encajan el width y height con los width y height de CSS\r\n    const manageSize = function () {\r\n        self.updateSize();\r\n    };\r\n\r\n    if (!TC.Util.detectMobile()) {\r\n        //self.on(POSTRENDER, manageSize);\r\n        manageSize();\r\n        window.addEventListener('resize', manageSize);\r\n    }\r\n};\r\n\r\nvar getFormatFromName = function (name, extractStyles) {\r\n    switch (name) {\r\n        case TC.Consts.layerType.KML:\r\n        case TC.Consts.mimeType.KML:\r\n        case TC.Consts.format.KMZ:\r\n            //10/11/2021 URI:Ahora el KML Custom es una modificación directa del KML y no una sobrecarga de éste. Se añade al build de ol al compilar\r\n            //return new ol.format.KMLCustom({\r\n            return new ol.format.KML({\r\n                showPointNames: false,\r\n                extractStyles: extractStyles !== undefined ? extractStyles : true\r\n            });\r\n        case TC.Consts.layerType.GPX:\r\n        case TC.Consts.mimeType.GPX:\r\n            return new ol.format.GPX();\r\n        case TC.Consts.layerType.GEOJSON:\r\n        case TC.Consts.mimeType.GEOJSON:\r\n        case TC.Consts.mimeType.JSON:\r\n        case TC.Consts.format.JSON:\r\n            return new ol.format.GeoJSON();\r\n        case TC.Consts.format.GML2:\r\n            return new ol.format.GML2();\r\n        case TC.Consts.format.GML3:\r\n            return new ol.format.GML3();\r\n        case TC.Consts.format.GML32:\r\n            return new ol.format.GML32();\r\n        case TC.Consts.mimeType.GML:\r\n        case TC.Consts.format.GML:\r\n            return new ol.format.GML();\r\n        case TC.Consts.format.TOPOJSON:\r\n            return new ol.format.TopoJSON();\r\n        case TC.Consts.format.WKT:\r\n            return new ol.format.WKT();\r\n        default:\r\n            return null;\r\n    }\r\n};\r\n\r\nTC.wrap.Map.prototype.exportFeatures = function (features, options) {\r\n    var self = this;\r\n    options = options || {};\r\n    var nativeStyle = createNativeStyle({\r\n        styles: self.parent.options.styles\r\n    });\r\n    var olFeatures = features.map(function (feature) {\r\n        var result = feature.wrap.feature.clone();\r\n        const path = feature.getPath();\r\n        if (path) {\r\n            result._folders = path;\r\n        }\r\n        //URI:replicamos el id a la feature OL\r\n        result.id_ = feature.id;\r\n        // Si la feature no tiene estilo propio le ponemos el definido por la API\r\n        if (!result.getStyle()) {\r\n            result.setStyle(nativeStyle);\r\n        }\r\n        // Miramos si tiene texto, en cuyo caso la features se clona para no contaminar la feature original\r\n        // y al clon se le añade el texto como atributo (necesario para exportar etiquetas en KML y GPX)\r\n        const text = getNativeFeatureStyle(result).getText();\r\n        if (text) {\r\n            const name = text.getText();\r\n            if (name) {\r\n                result.setProperties({\r\n                    name: text.getText()\r\n                });\r\n            }\r\n        }\r\n        return result;\r\n    });\r\n    var format = getFormatFromName(options.format);\r\n\r\n    if (format instanceof ol.format.KML) {\r\n        // KML no tiene estilo para puntos aparte del de icono. Para puntos sin icono creamos uno en SVG.\r\n        olFeatures = olFeatures\r\n            .map(function (feature) {\r\n                const geom = feature.getGeometry();\r\n                if (geom instanceof ol.geom.Point) {\r\n                    // Si el punto no tiene icono, creamos uno nuevo con un icono generado como data URI a partir del estilo\r\n                    var style = getNativeFeatureStyle(feature);\r\n                    const shape = style.getImage();\r\n                    if (shape instanceof ol.style.RegularShape) {\r\n                        const radius = shape.getRadius();\r\n                        const stroke = shape.getStroke();\r\n                        const strokeWidth = stroke.getWidth();\r\n                        const diameter = 2 * radius + strokeWidth;\r\n                        //const position = diameter / 2;\r\n                        const canvas = document.createElement('canvas');\r\n                        canvas.width = diameter;\r\n                        canvas.height = diameter;\r\n                        //const ctx = canvas.getContext('2d');\r\n                        //const vectorContext = ol.render.toContext(canvas.getContext('2d'), {\r\n                        //    size: [diameter, diameter]\r\n                        //});\r\n                        const text = style.getText();\r\n                        style = style.clone();\r\n                        style.setText(); // Quitamos el texto para que no salga en el canvas\r\n                        //ctx.beginPath();\r\n                        //ctx.strokeStyle = stroke.getColor();\r\n                        //ctx.lineWidth = strokeWidth;\r\n                        //ctx.arc(diameter/2, diameter/2, radius, 0, 2 * Math.PI, false);\r\n                        //ctx.stroke();\r\n                        //vectorContext.setStyle(style);\r\n                        //vectorContext.drawGeometry(new ol.geom.Point([position, position]));\r\n                        const newFeature = new ol.Feature(geom);\r\n                        newFeature.setId(feature.getId());\r\n                        newFeature.setProperties(feature.getProperties());\r\n\r\n                        newFeature.setStyle(new ol.style.Style({\r\n                            image: new ol.style.Icon({\r\n                                src: (\"data:image/svg+xml;base64,\" + window.btoa('<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + diameter + '\" height=\"' + diameter + '\">' +\r\n                                    '<circle cx=\"' + diameter / 2 + '\" cy=\"' + diameter / 2 + '\" r=\"' + radius + '\" stroke=\"' + stroke.getColor() + '\" fill=\"none\" stroke-width=\"' + strokeWidth + '\" />' +\r\n                                    '</svg>')),\r\n                                //canvas.toDataURL('image/png'),\r\n                                size: [diameter, diameter],\r\n                                imgSize: [diameter, diameter],\r\n                                scale: shape.getScale()\r\n                            }),\r\n                            text: text\r\n                        }));\r\n                        return newFeature;\r\n                    }\r\n                }\r\n                return feature;\r\n            });\r\n        // KML no pone etiquetas a líneas y polígonos. En esos casos ponemos un punto con la etiqueta.\r\n        const pointsToAdd = [];\r\n        olFeatures.forEach(function (feature) {\r\n            var style = getNativeFeatureStyle(feature);\r\n            const geometry = feature.getGeometry();\r\n            const text = style.getText();\r\n            var point;\r\n            if (text && text.getText()) {\r\n                switch (true) {\r\n                    case geometry instanceof ol.geom.LineString:\r\n                        point = new ol.geom.Point(geometry.getCoordinateAt(0.5));\r\n                        break;\r\n                    case geometry instanceof ol.geom.Polygon:\r\n                        point = geometry.getInteriorPoint();\r\n                        break;\r\n                    case geometry instanceof ol.geom.MultiLineString: {\r\n                        // Seleccionamos la línea más larga\r\n                        const lineStrings = geometry.getLineStrings();\r\n                        var maxLength = -1;\r\n                        point = new ol.geom.Point(lineStrings[lineStrings\r\n                            .map(function (line) {\r\n                                return line.getLength();\r\n                            })\r\n                            .reduce(function (prev, cur, idx) {\r\n                                if (cur > maxLength) {\r\n                                    maxLength = cur;\r\n                                    return idx;\r\n                                }\r\n                                return prev;\r\n                            }, -1)].getCoordinateAt(0.5));\r\n                        break;\r\n                    }\r\n                    case geometry instanceof ol.geom.MultiPolygon: {\r\n                        // Seleccionamos el polígono más grande\r\n                        const polygons = geometry.getPolygons();\r\n                        var maxArea = -1;\r\n                        point = polygons[polygons\r\n                            .map(function (polygon) {\r\n                                return polygon.getArea();\r\n                            })\r\n                            .reduce(function (prev, cur, idx) {\r\n                                if (cur > maxArea) {\r\n                                    maxArea = cur;\r\n                                    return idx;\r\n                                }\r\n                                return prev;\r\n                            }, -1)].getInteriorPoint();\r\n                        break;\r\n                    }\r\n                    default:\r\n                        break;\r\n                }\r\n                if (point) {\r\n                    const newFeature = new ol.Feature(point);\r\n                    newFeature.setStyle(new ol.style.Style({\r\n                        text: text.clone(),\r\n                        image: new ol.style.Icon({\r\n                            crossOrigin: 'anonymous',\r\n                            src: TC.apiLocation + 'TC/css/img/transparent.gif'\r\n                        })\r\n                    }));\r\n                    pointsToAdd.push(newFeature);\r\n                }\r\n            }\r\n        });\r\n        if (pointsToAdd.length) {\r\n            olFeatures = olFeatures.concat(pointsToAdd);\r\n        }\r\n    }\r\n\r\n    if (format instanceof ol.format.GMLBase) {\r\n        format.hasZ = features[0].getGeometryStride() >= 3;\r\n        format.srsName = self.parent.crs;\r\n        // Quitamos los espacios en blanco de los nombres de atributo en las features: no son válidos en GML.\r\n        olFeatures = olFeatures.map(function (f) {\r\n            var temp = f.clone();\r\n            temp.id_ = f.id_;\r\n            return temp;\r\n        });\r\n        olFeatures.forEach(function (f) {\r\n            const values = f.values_;\r\n            const keysToChange = [];\r\n            for (var key in values) {\r\n                if (key.indexOf(' ') >= 0) {\r\n                    keysToChange.push(key);\r\n                }\r\n            }\r\n            keysToChange.forEach(function (key) {\r\n                // Quitamos espacios en blanco y evitamos que empiece por un número\r\n                var newKey = key.replace(/ /g, '_');\r\n                if (/^\\d/.test(newKey)) {\r\n                    newKey = '_' + newKey;\r\n                }\r\n                if (key !== newKey) {\r\n                    while (values[newKey] !== undefined) {\r\n                        newKey += '_';\r\n                    }\r\n                }\r\n                values[newKey] = values[key];\r\n                delete values[key];\r\n            });\r\n        });\r\n\r\n        format.featureNS = \"http://www.opengis.net/gml\";\r\n        format.featureType = \"feature\";\r\n        var featuresNode = format.writeFeaturesNode(olFeatures, {\r\n            featureProjection: self.parent.crs\r\n        });\r\n        featuresNode\r\n            .querySelectorAll(\"feature geometry > * *[srsName]\")\r\n            .forEach(item => item.removeAttribute(\"srsName\"));\r\n\r\n        var featureCollectionNode = ol.xml.createElementNS('http://www.opengis.net/wfs',\r\n            'FeatureCollection');\r\n        featureCollectionNode.setAttributeNS('http://www.w3.org/2001/XMLSchema-instance',\r\n            'xsi:schemaLocation', format.schemaLocation);\r\n\r\n        featuresNode.removeAttribute('xmlns:xsi');\r\n        featuresNode.removeAttribute('xsi:schemaLocation');\r\n        featureCollectionNode.appendChild(featuresNode);\r\n        //ol.xml.setAttributeNS(node, 'http://www.w3.org/2001/XMLSchema-instance',\r\n        //    'xsi:schemaLocation', this.schemaLocation);\r\n        return featureCollectionNode.outerHTML;\r\n    }\r\n\r\n    if (format instanceof ol.format.GPX) {\r\n        // Queremos exportar tracks en vez de routes. OpenLayers exporta LineStrings como routes y MultiLineStrings como tracks.\r\n        olFeatures = olFeatures.map(function (f) {\r\n            const geom = f.getGeometry();\r\n            if (geom instanceof ol.geom.LineString) {\r\n                f = f.clone();\r\n                f.setGeometry(new ol.geom.MultiLineString([geom.getCoordinates()]));\r\n            }\r\n            return f;\r\n        });\r\n    }\r\n\r\n    var result = format.writeFeatures(olFeatures, {\r\n        dataProjection: 'EPSG:4326',\r\n        featureProjection: self.parent.crs\r\n    });\r\n    if (format instanceof ol.format.GPX) {\r\n        // Este formato no procesa bien las elevaciones cuando son nulas. Hemos hecho un preproceso para transformarlas en NaN y ahora hay que eliminarlas.\r\n        result = result.replace(/<ele>NaN<\\/ele>/g, '');\r\n    }\r\n    return result;\r\n};\r\n\r\nvar isFileDrag = function (e) {\r\n    for (var i = 0, len = e.dataTransfer.types.length; i < len; i++) {\r\n        if (e.dataTransfer.types[i] === 'Files') {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nvar handleDragEnter = function (e) {\r\n    var self = this;\r\n    if (isFileDrag(e)) { // Solo hay gestión si lo que se arrastra es un archivo\r\n        self.getMap()._wrap.parent.div.classList.add(TC.Consts.classes.DROP);\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n    }\r\n};\r\n\r\nvar handleDragExit = function (e) {\r\n    var self = this;\r\n    if (isFileDrag(e)) { // Solo hay gestión si lo que se arrastra es un archivo\r\n        var map = self.getMap()._wrap.parent;\r\n        if (e.target === self.target) {\r\n            map.div.classList.remove(TC.Consts.classes.DROP);\r\n        }\r\n    }\r\n};\r\n\r\nTC.wrap.Map.prototype.enableDragAndDrop = function (options) {\r\n    var self = this;\r\n    var opts = options || {};\r\n    var ddOptions = {\r\n        formatConstructors: [\r\n            //10/11/2021 URI:Ahora el KML Custom es una modificación directa del KML y no una sobrecarga de éste. Se añade al build de ol al compilar\r\n            //ol.format.KMLCustom,\r\n            ol.format.KML,\r\n            ol.format.GPX,\r\n            ol.format.GML32,\r\n            ol.format.GML2,\r\n            ol.format.GML3CRS84,\r\n            ol.format.GML2CRS84,\r\n            ol.format.GML3,\r\n            //ol.format.GML32,\r\n            ol.format.GeoJSON,\r\n            function () {\r\n                return new ol.format.WKT({\r\n                    splitCollection: true\r\n                });\r\n            },\r\n            ol.format.TopoJSON\r\n        ]\r\n    };\r\n    if (opts.dropTarget) {\r\n        ddOptions.target = TC.Util.getDiv(opts.dropTarget);\r\n    }\r\n    else {\r\n        ddOptions.target = self.parent.div;\r\n    }\r\n    var zipFiles = null;\r\n    var ddInteraction = new ol.interaction.DragAndDrop(ddOptions);\r\n    ddInteraction.on('addfeatures', function (e) {\r\n        var featurePromises = e.features ? e.features.map(function (elm) {\r\n            if (!elm.getId()) {\r\n                elm.setId(TC.getUID());\r\n            }\r\n            return TC.wrap.Feature.createFeature(elm);\r\n        }) : [];\r\n\r\n        Promise.all(featurePromises).then(function (features) {\r\n            var li = self.parent.getLoadingIndicator();\r\n            if (li) {\r\n                li.removeWait(self.parent._featureImportWaitId);\r\n            }\r\n            const featuresWithGeometry = features.filter(f => f.geometry);\r\n            //15/11/2021 RI: Cambio la lógica. Si alguna fatures no tienen geometría lanzo un evento nuevo para a posteriori sacar un warning\r\n            if (featuresWithGeometry.length) {\r\n                const featuresImportEventData = {\r\n                    features: featuresWithGeometry,\r\n                    file: e.file,\r\n                    fileHandle: ddInteraction.getFileHandle(e.file),\r\n                    fileName: e.file.name,\r\n                    dropTarget: e.target.target,\r\n                    timeStamp: e.file.lastModified,\r\n                    groupIndex: e._groupIndex,\r\n                    groupCount: e._groupCount\r\n                };\r\n                if (e.file.name.substring(e.file.name.lastIndexOf(\".\") + 1).toLowerCase() === 'shp') {\r\n                    // Los shapefiles son multiarchivo, añado los demás fileHandles.\r\n                    const nameBase = e.file.name.substring(0, e.file.name.lastIndexOf(\".\"));\r\n                    featuresImportEventData.additionalFileHandles = ['.dbf', '.prj', '.cst', '.cpg']\r\n                        .map(ext => ddInteraction.getFileHandleByName(nameBase + ext))\r\n                        .filter(fh => fh !== null);\r\n                }\r\n                if (e.file._fileSystemFile) {\r\n                    featuresImportEventData.fileSystemFile = e.file._fileSystemFile;\r\n                    delete e.file._fileSystemFile;\r\n                }\r\n                if (ddInteraction._fileLayers) {\r\n                    const fileLayers = ddInteraction._fileLayers.filter(l =>\r\n                        l.options.file === e.file.name && l.options.groupIndex === e._groupIndex);\r\n                    if (fileLayers.length) {\r\n                        featuresImportEventData.targetLayers = fileLayers;\r\n                        fileLayers.forEach(fileLayer => ddInteraction._fileLayers.splice(ddInteraction._fileLayers.indexOf(fileLayer), 1));\r\n                    }\r\n                }\r\n                self.parent.trigger(TC.Consts.event.FEATURESIMPORT, featuresImportEventData);\r\n                if (features.some(f => !f.geometry)) {\r\n                    self.parent.trigger(TC.Consts.event.FEATURESIMPORTWARN, {\r\n                        file: e.file\r\n                    });\r\n                }\r\n            }\r\n            else { //if (!features.length || features.some(f => !f.geometry)) {\r\n                if (zipFiles) {\r\n                    if (++zipFiles.failed < zipFiles.total) {\r\n                        return;\r\n                    }\r\n                    else {\r\n                        const fileHandle = ddInteraction.getFileHandle(e.file);\r\n                        e.file = new File([], zipFiles.zipName);\r\n                        if (fileHandle) {\r\n                            ddInteraction.setFileHandle(e.file, fileHandle);\r\n                        }\r\n                    }\r\n                }\r\n                self.parent.trigger(TC.Consts.event.FEATURESIMPORTERROR, {\r\n                    file: e.file\r\n                });\r\n            }\r\n        });\r\n    });\r\n    if (opts.once) {\r\n        ddInteraction.map_ = self.map;\r\n    }\r\n    else {\r\n        self.map.addInteraction(ddInteraction);\r\n        var dropArea = ddInteraction.target ? ddInteraction.target : self.map.getViewport();\r\n\r\n        const originalFnc = ddInteraction.handleResult_;\r\n\r\n        var zipUncompressed = {};\r\n        var getFileData = function (file) {\r\n            if (file.arrayBuffer)\r\n                return file.arrayBuffer();\r\n            else {\r\n                return new Promise(function (resolve, reject) {\r\n                    var fr = new FileReader();\r\n                    fr.onload = function (_e) {\r\n                        resolve(new Uint8Array(this.result));\r\n                    };\r\n                    fr.onerror = reject;\r\n                    fr.readAsArrayBuffer(file);\r\n                });\r\n            }\r\n        };\r\n        var getFileText = function (file) {\r\n            if (file.text)\r\n                return file.text();\r\n            else {\r\n                return new Promise(function (resolve, reject) {\r\n                    var fr = new FileReader();\r\n                    fr.onload = function (_e) {\r\n                        resolve(new Uint8Array(this.result));\r\n                    };\r\n                    fr.onerror = reject;\r\n                    fr.readAsText(file);\r\n                });\r\n            }\r\n        };\r\n\r\n        ddInteraction.handleResult_ = async function (file, evt) {\r\n            var _self = this;\r\n            //URI: si el fichero es ZIP o KMZ lo proceso sino llamo a la función original con los datos originales\r\n            zipFiles = null;\r\n            const defaultEncoding = \"ISO-8859-1\";\r\n            //_self.getMap()._wrap.parent.dropFilesCounter = 0;\r\n            if (/\\.gpkg$/ig.test(file.name) || file.type === \"application/geopackage+sqlite3\") {\r\n\r\n                import(\"../../lib/geopackagejs/dist/geopackage-browser\").then(async function (gp) {\r\n                    const geopackage = gp.GeoPackageAPI;\r\n                    const manageError = function (err) {\r\n                        if (err)\r\n                            TC.error(err, TC.Consts.msgErrorMode.CONSOLE);\r\n\r\n                        originalFnc.apply(_self, [file, { target: { result: null } }]);\r\n                    };\r\n                    const loadFile = async function (array) {\r\n                        geopackage.open(array).then(async function (myPackage) {\r\n                            const vectorLayers = myPackage.getFeatureTables();\r\n                            const numTables = vectorLayers.length;\r\n                            var finished = 0, notLoaded = 0;\r\n                            var warnings = [];\r\n\r\n                            //me subscribo al evento\r\n                            const manageLoad = function (_evt) {\r\n                                if (++finished === numTables) {\r\n                                    self.parent.off(TC.Consts.event.FEATURESIMPORT, manageLoad);\r\n                                    for (var i = 0; i < warnings.length; i++)\r\n                                        self.parent.trigger(TC.Consts.event.FEATURESIMPORTPARTIAL, {\r\n                                            file: file,\r\n                                            table: warnings[i].table,\r\n                                            reason: warnings[i].reason\r\n                                        });\r\n                                }\r\n                            };\r\n                            const fileHandle = _self.getFileHandle(file);\r\n                            self.parent.on(TC.Consts.event.FEATURESIMPORT, manageLoad);\r\n                            if (vectorLayers.length > 1) window.dropFilesCounter = window.dropFilesCounter + vectorLayers.length - 1;\r\n                            for (var i = 0; i < vectorLayers.length; i++) {\r\n                                //vamos a ver si construimos en JSON\r\n                                try {\r\n                                    var arr = [];\r\n                                    for (let row of myPackage.iterateGeoJSONFeatures(vectorLayers[i])) {\r\n                                        if (Object.prototype.hasOwnProperty.call(row, \"id\"))\r\n                                            row.id = vectorLayers[i] + \".\" + row.id;\r\n                                        if (row.geometry) {\r\n                                            row.type = \"Feature\";\r\n                                            arr[arr.length] = row;\r\n                                        }\r\n                                    }\r\n                                    if (!arr.length) throw 'empty table';\r\n\r\n                                    var jsonObj = {\r\n                                        \"type\": \"FeatureCollection\",\r\n                                        \"features\": arr\r\n                                    };\r\n                                    var newFile = new File([], vectorLayers[i]);\r\n                                    //window.dropFilesCounter = (window.dropFilesCounter ? window.dropFilesCounter + 1 : 1);\r\n                                    if (fileHandle) {\r\n                                        _self.setFileHandle(newFile, fileHandle);\r\n                                    }\r\n                                    originalFnc.apply(_self, [newFile, { target: { result: jsonObj } }]);\r\n\r\n                                } catch (err) {\r\n                                    notLoaded++;\r\n                                    manageLoad({ fileName: vectorLayers[i] });\r\n                                    warnings.push({ table: vectorLayers[i], reason: err });\r\n                                    TC.error(\"Error: \" + err + \" Table: \" + vectorLayers[i], TC.Consts.msgErrorMode.CONSOLE);\r\n                                }\r\n                            }\r\n                            if (numTables === notLoaded) {\r\n                                manageError(\"Error: No hay capas vectoriales válidas que mostrar\");\r\n                            }\r\n                        }, manageError);\r\n                    };\r\n                    try {\r\n                        loadFile(new Uint8Array(await getFileData(file)));\r\n                    }\r\n                    catch (ex) {\r\n                        manageError(ex);\r\n                    }\r\n                });\r\n            }\r\n            else if (!/\\.(json|geojson|kml|kmz|wkt|gml|gml2|gpx)$/ig.test(file.name)) {\r\n                if (!/\\.(shp)$/ig.test(file.name)) {\r\n                    window.dropFilesCounter--;\r\n                }\r\n                //const fileName = new RegExp(/(spaSITNA)*(\\w+)(\\.\\w{2,})+$/gi).exec(file.name)[2];\r\n\r\n                const fileName = /(spaSITNA)*((\\w|-)+)(\\.\\w{2,})/gi.test(file.name) ? new RegExp(/(spaSITNA)*((\\w|-)+)(\\.\\w{2,})/gi).exec(file.name)[2] : file.name;\r\n\r\n                const extension = file.name.substring(file.name.lastIndexOf(\".\") + 1);\r\n                //este objeto tiene una referencia al objeto del atributo \"filename\" del objeto zipCompressed\r\n                var shpParams = null;\r\n                //Si no tiene información referente al shp actual lo inicializo\r\n                if (!Object.prototype.hasOwnProperty.call(zipUncompressed, fileName)) {\r\n                    shpParams = zipUncompressed[fileName] = { isSHP: false, promises: [] };\r\n                }\r\n                else\r\n                    //Si ya hay información del shp la recupero\r\n                    shpParams = zipUncompressed[fileName];\r\n                //los ficheros de texto los leo, guardo la promesa en un array para cuando estén todos los fichero\r\n                if (/\\.(cst|cpg|prj)$/ig.test(file.name)) {\r\n                    shpParams.isSHP = true;\r\n                    let filePromise = getFileText(file);\r\n                    shpParams.promises.push(filePromise);\r\n                    //tambien espero a que se resuelva esta promesa para guardar el contenido en una variable\r\n                    filePromise.then(function (data) {\r\n                        zipUncompressed[fileName][extension] = data;\r\n                    });\r\n                }\r\n                //los ficheros binarios los leo, guardo la promesa en un array para cuando estén todos los fichero\r\n                else if (/\\.(shp|dbf|str)$/ig.test(file.name)) {\r\n                    shpParams.isSHP = true;\r\n                    if (/\\.(shp)$/ig.test(file.name)) {\r\n                        shpParams.shpFile = file;\r\n                    }\r\n                    let filePromise = getFileData(file);\r\n                    shpParams.promises.push(filePromise);\r\n                    //tambien espero a que se resuelva esta promesa para guardar el contenido en una variable\r\n                    filePromise.then(function (data) {\r\n                        zipUncompressed[fileName][extension] = data;\r\n                    });\r\n                }\r\n                //si no existe todavia la promesa del timer la genero. Esto solo se hace una vez por cada shape.\r\n                if (!shpParams.timer) {\r\n                    //este timer resuelve una promesa durante ese tiempo todos los ficheros con el mismo nombre que el shape se procesaran. El resto quedan fuera\r\n                    shpParams.timer = new Promise(function (resolve) {\r\n                        setTimeout(function () {\r\n                            resolve();\r\n                        }, 1300);\r\n                    });\r\n                    //añado la promesa del timer al resto de promesas. Cuando todas las promesas de lecturas de ficheros esten acabadas ademas del timer se procesa el fichero\r\n                    shpParams.promises.push(shpParams.timer);\r\n                    Promise.all(shpParams.promises).then(function (_results) {\r\n                        if (!shpParams.isSHP) {\r\n                            //si el fichero se llama wfsRequest.txt y no hay ningún SHP\r\n                            if (file.name.toLowerCase() !== \"wfsrequest.txt\" ||\r\n                                !Object.keys(zipUncompressed).some(k => zipUncompressed[k].isSHP)) {\r\n                                window.dropFilesCounter++;\r\n                                self.parent.trigger(TC.Consts.event.FEATURESIMPORTERROR, {\r\n                                    file: file\r\n                                });\r\n                            }\r\n                            delete zipUncompressed[fileName];\r\n                        }\r\n                        else {\r\n                            import('@sitna/shpjs/dist/shp').then(async ({ default: shp }) => {\r\n                                var shapes;\r\n                                let shpFile;\r\n                                try {\r\n                                    //window.dropFilesCounter = (window.dropFilesCounter ? window.dropFilesCounter + 1 : 1);\r\n                                    if (!shpParams.shp || !shpParams.prj || !shpParams.dbf) {\r\n                                        if (!shpParams.shp) window.dropFilesCounter++;\r\n                                        self.parent.trigger(TC.Consts.event.FEATURESIMPORTERROR, {\r\n                                            file: file,\r\n                                            message: \"fileImport.shapeImcomplete\"\r\n                                        });\r\n                                        delete zipUncompressed[fileName];\r\n                                        return;\r\n                                    }\r\n                                    shpFile = shpParams.shpFile;\r\n                                    shapes = await shp.combine([\r\n                                        shp.parseShp(shpParams.shp, shpParams.prj, shpParams.str),\r\n                                        shp.parseDbf(shpParams.dbf, shpParams.cst || shpParams.cpg || defaultEncoding)]);\r\n                                    delete zipUncompressed[fileName];\r\n                                }\r\n                                catch (err) {\r\n                                    self.parent.trigger(TC.Consts.event.FEATURESIMPORTERROR, {\r\n                                        file: file\r\n                                    });\r\n                                    return;\r\n                                }\r\n                                (shapes instanceof Array ? shapes : [shapes]).forEach(function (collection) {\r\n                                    // El parser no añade ids, los añadimos nosotros.\r\n                                    collection.features.forEach((f, i) => {\r\n                                        f.id = `${fileName}.${i + 1}`;\r\n                                    });\r\n                                    var newFile = new File([], fileName + '.shp');\r\n                                    const fileHandle = _self.getFileHandle(shpFile);\r\n                                    if (fileHandle) {\r\n                                        _self.setFileHandle(newFile, fileHandle);\r\n                                    }\r\n                                    originalFnc.apply(_self, [newFile, { target: { result: JSON.stringify(collection) } }]);\r\n                                });\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n\r\n            }\r\n            else {\r\n                //window.dropFilesCounter = (window.dropFilesCounter ? window.dropFilesCounter + 1 : 1);\r\n                originalFnc.apply(_self, [file, evt]);\r\n            }\r\n        };\r\n\r\n        // Añadidos gestores de eventos para mostrar el indicador visual de drop.\r\n        var handleDrop = function (e) {\r\n            if (isFileDrag(e)) { // Solo hay gestión si lo que se arrastra es un archivo\r\n                var map = self.parent;\r\n                if (ddInteraction.target === e.target) {\r\n                    if (!isEmpty(e.dataTransfer.items)) {\r\n                        var li = map.getLoadingIndicator();\r\n                        if (li) {\r\n                            map._featureImportWaitId = li.addWait(map._featureImportWaitId);\r\n                        }\r\n                    }\r\n                    e.stopPropagation();\r\n                }\r\n                else {\r\n                    e.preventDefault();\r\n                }\r\n                map.div.classList.remove(TC.Consts.classes.DROP);\r\n            }\r\n        };\r\n        var isEmpty = function (items) {\r\n            for (var i = 0, ii = items.length; i < ii; ++i) {\r\n                if (items[i].kind === \"file\") {\r\n                    if (items[i].getAsFile() || items[i].webkitGetAsEntry() && items[i].webkitGetAsEntry().isFile) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        return isEmpty(items[i].webkitGetAsEntry());\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        ddInteraction.dropListenKeys_.push(\r\n            ol.events.listen(dropArea, DRAGENTER,\r\n                handleDragEnter, ddInteraction)\r\n        );\r\n        ddInteraction.dropListenKeys_.push(\r\n            ol.events.listen(document.body, DRAGENTER,\r\n                handleDragEnter, ddInteraction)\r\n        );\r\n        ddInteraction.dropListenKeys_.push(\r\n            ol.events.listen(dropArea, DRAGOVER,\r\n                handleDragEnter, ddInteraction)\r\n        );\r\n        ddInteraction.dropListenKeys_.push(\r\n            ol.events.listen(document.body, DRAGOVER,\r\n                handleDragEnter, ddInteraction)\r\n        );\r\n        ddInteraction.dropListenKeys_.push(\r\n            ol.events.listen(dropArea, DROP,\r\n                handleDrop, ddInteraction)\r\n        );\r\n        ddInteraction.dropListenKeys_.push(\r\n            ol.events.listen(document.body, DROP,\r\n                handleDrop, ddInteraction)\r\n        );\r\n        ddInteraction.dropListenKeys_.push(\r\n            ol.events.listen(document.body, 'dragleave',\r\n                handleDragExit, ddInteraction)\r\n        );\r\n        ddInteraction.dropListenKeys_.push(\r\n            ol.events.listen(document.body, 'dragend',\r\n                handleDragExit, ddInteraction)\r\n        );\r\n        ddInteraction.dropListenKeys_.push(\r\n            ol.events.listen(document.body, 'dragexit',\r\n                handleDragExit, ddInteraction)\r\n        );\r\n        document.addEventListener('mouseenter', function (e) {\r\n            if (!e.buttons) {\r\n                self.parent.div.classList.remove(TC.Consts.classes.DROP);\r\n            }\r\n        }, false);\r\n        self.ddEnabled = true;\r\n    }\r\n    return ddInteraction;\r\n};\r\n\r\nTC.wrap.Map.prototype.loadFiles = async function (files, options) {\r\n    const self = this;\r\n    let ddInteraction;\r\n    if (!files.length) {\r\n        return;\r\n    }\r\n    if (self.ddEnabled) {\r\n        self.map.getInteractions().forEach(function (elm) {\r\n            if (elm instanceof ol.interaction.DragAndDrop) {\r\n                ddInteraction = elm;\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        ddInteraction = self.enableDragAndDrop({\r\n            once: true\r\n        });\r\n    }\r\n\r\n    if (ddInteraction && options) {\r\n        var currentTarget = ddInteraction.target;\r\n        ddInteraction.target = options.control;\r\n\r\n        self.parent.one(TC.Consts.event.FEATURESIMPORT, function undoTarget(_e) {\r\n            ddInteraction.target = currentTarget;\r\n        });\r\n\r\n        if (options.layers) {\r\n            ddInteraction._fileLayers = (ddInteraction._fileLayers || []).concat(options.layers);\r\n        }\r\n    }\r\n\r\n    var li = self.parent.getLoadingIndicator();\r\n    if (li) {\r\n        self.parent._featureImportWaitId = li.addWait(self.parent._featureImportWaitId);\r\n    }\r\n    for (var i = 0, ii = files.length; i < ii; ++i) {\r\n        const file = files[i];\r\n        ddInteraction.processFile(file);\r\n    }\r\n};\r\n\r\nTC.wrap.Map.prototype.linkTo = function (map) {\r\n    const self = this;\r\n    const onChangeView = function () {\r\n        const thisView = self.map.getView();\r\n        const thatView = map.wrap.map.getView();\r\n        setTimeout(function () {\r\n            if (thisView !== thatView) {\r\n                self.map.setView(thatView);\r\n            }\r\n        }, 100);\r\n    };\r\n    map.wrap.map.on('change:view', onChangeView);\r\n    self.map.on('change:view', onChangeView);\r\n    onChangeView();\r\n};\r\n\r\n/*\r\n *  getVisibility: gets the OpenLayers layer visibility\r\n *  Result: boolean\r\n */\r\nTC.wrap.Layer.prototype.getVisibility = function () {\r\n    const self = this;\r\n    var result = false;\r\n    if (self.layer) {\r\n        result = self.layer.getVisible();\r\n    }\r\n    return result;\r\n};\r\n\r\n/*\r\n *  setVisibility: Sets the OpenLayers layer visibility\r\n *  Parameter: boolean\r\n */\r\nTC.wrap.Layer.prototype.setVisibility = function (visible) {\r\n    const self = this;\r\n    self.getLayer().then(function (layer) {\r\n        layer.setVisible(visible);\r\n    });\r\n};\r\n\r\nTC.wrap.Layer.prototype.isNative = function (layer) {\r\n    return layer instanceof ol.layer.Layer;\r\n};\r\n\r\nTC.wrap.Layer.prototype.setProjection = function (options) {\r\n    const self = this;\r\n    options = options || {};\r\n    const layer = self.parent;\r\n    if (layer.map) {\r\n        const unitRatio = getUnitRatio.call(self, {\r\n            crs: options.crs,\r\n            extentInDegrees: ol.proj.transformExtent(layer.map.getExtent(), layer.map.crs, 'EPSG:4326')\r\n        });\r\n\r\n        var resolutions = layer.getResolutions();\r\n        if (resolutions && resolutions.length) {\r\n            resolutions = resolutions.map(function (r) {\r\n                return r / unitRatio;\r\n            });\r\n            layer.wrap.layer.setMaxResolution(resolutions[0]);\r\n            layer.wrap.layer.setMinResolution(resolutions[resolutions.length - 1]);\r\n        }\r\n        else {\r\n            // de metros a grados\r\n            if (options.oldCrs && ol.proj.get(options.oldCrs).getUnits() === ol.proj.Units.METERS && (!ol.proj.get(options.crs).getUnits() || ol.proj.get(options.crs).getUnits() === ol.proj.Units.DEGREES)) {\r\n\r\n                if (layer.minResolution) {\r\n                    layer.minResolution = layer.minResolution / unitRatio;\r\n                    self.layer.setMinResolution(layer.minResolution);\r\n                }\r\n\r\n                if (layer.maxResolution) {\r\n                    layer.maxResolution = layer.maxResolution / unitRatio;\r\n                    self.layer.setMaxResolution(layer.maxResolution);\r\n                }\r\n\r\n                // de grados a metros\r\n            } else if (options.oldCrs && ol.proj.get(options.oldCrs).getUnits() === ol.proj.Units.DEGREES && ol.proj.get(options.crs).getUnits() === ol.proj.Units.METERS) {\r\n                var metersPerDegree = TC.Util.getMetersPerDegree(ol.proj.transformExtent(layer.map.getExtent(), layer.map.crs, 'EPSG:4326'));\r\n\r\n                if (layer.minResolution) {\r\n                    layer.minResolution = layer.minResolution * metersPerDegree;\r\n                    self.layer.setMinResolution(layer.minResolution);\r\n                }\r\n\r\n                if (layer.maxResolution) {\r\n                    layer.maxResolution = layer.maxResolution * metersPerDegree;\r\n                    self.layer.setMaxResolution(layer.maxResolution);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nconst createPathFromGeometry = function (geometry) {\r\n    const result = new Path2D();\r\n    const p0 = geometry[0];\r\n    result.moveTo(p0[0], p0[1]);\r\n    for (var i = 1, ii = geometry.length; i < ii; i++) {\r\n        const p = geometry[i];\r\n        result.lineTo(p[0], p[1]);\r\n    }\r\n    result.closePath();\r\n    return result;\r\n};\r\n\r\nconst getPixelRatioScalePath = function (path) {\r\n    // flacunza:\r\n    // En desktop escalamos la geometría según devicePixelRatio porque hemos escalado el mapa previamente\r\n    // (ver TC.wrap.Map.prototype.manageSize)\r\n    if (TC.Util.detectMobile()) {\r\n        return path;\r\n    }\r\n    else {\r\n        const result = new Path2D();\r\n        result.addPath(path, new DOMMatrix('scale(' + window.devicePixelRatio + ')'));\r\n        return result;\r\n    }\r\n};\r\n\r\nconst execCanvasOperation = function (geometry, operationName, prerenderHandler, postrenderHandler) {\r\n    const self = this;\r\n    const prerenderHandlerName = `_${operationName}PrerenderHandler`;\r\n    const postrenderHandlerName = `_${operationName}PostrenderHandler`;\r\n    if (self[prerenderHandlerName]) {\r\n        self.layer.un(ol.render.EventType.PRERENDER, self[prerenderHandlerName]);\r\n        delete self[prerenderHandlerName];\r\n        self.layer.un(ol.render.EventType.POSTRENDER, self[postrenderHandlerName]);\r\n        delete self[postrenderHandlerName];\r\n    }\r\n\r\n    if (geometry) {\r\n        self[prerenderHandlerName] = prerenderHandler;\r\n        self.layer.on(ol.render.EventType.PRERENDER, self[prerenderHandlerName]);\r\n\r\n        self[postrenderHandlerName] = postrenderHandler;\r\n        self.layer.on(ol.render.EventType.POSTRENDER, self[postrenderHandlerName]);\r\n    }\r\n\r\n    self.parent.map.wrap.map.render();\r\n};\r\n\r\nTC.wrap.Layer.prototype.clip = function (geometry) {\r\n    const self = this;\r\n    execCanvasOperation.call(self, geometry, 'clip', function (e) {\r\n        let geom = geometry;\r\n        if (TC.Util.isFunction(geometry)) {\r\n            geom = geometry.call(self._wrap);\r\n        }\r\n        if (!(geom instanceof Path2D)) {\r\n            geom = createPathFromGeometry(geom);\r\n        }\r\n        geom = getPixelRatioScalePath(geom);\r\n        const ctx = e.context;\r\n        ctx.save();\r\n        ctx.clip(geom, 'evenodd');\r\n    }, function (e) {\r\n        e.context.restore();\r\n    });\r\n};\r\n\r\nTC.wrap.Layer.prototype.stroke = function (geometry, style) {\r\n    const self = this;\r\n    execCanvasOperation.call(self, geometry, 'stroke', function (_e) {\r\n    }, function (e) {\r\n        let geom = geometry;\r\n        if (TC.Util.isFunction(geometry)) {\r\n            geom = geometry.call(self._wrap);\r\n        }\r\n        if (!(geom instanceof Path2D)) {\r\n            geom = createPathFromGeometry(geom);\r\n        }\r\n        geom = getPixelRatioScalePath(geom);\r\n        const ctx = e.context;\r\n        if (style.strokeWidth) {\r\n            ctx.lineWidth = style.strokeWidth;\r\n        }\r\n        if (style.strokeColor) {\r\n            ctx.strokeStyle = style.strokeColor;\r\n        }\r\n        ctx.stroke(geom);\r\n    });\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.WmsParser = ol.format.WMSCapabilities;\r\n\r\nTC.wrap.layer.Raster.prototype.WmtsParser = ol.format.WMTSCapabilities;\r\n\r\nTC.wrap.Layer.prototype.addCommonEvents = function (layer) {\r\n    var self = this;\r\n    layer.on('change:visible', function () {\r\n        if (self.parent.map) {\r\n            self.parent.map.trigger(TC.Consts.event.LAYERVISIBILITY, {\r\n                layer: self.parent\r\n            });\r\n        }\r\n    }, self.parent.map);\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getGetMapUrl = function () {\r\n    var result = null;\r\n    var self = this;\r\n    switch (self.getServiceType()) {\r\n        case TC.Consts.layerType.WMS:\r\n            var dcpType = self.parent.capabilities.Capability.Request.GetMap.DCPType;\r\n            for (var i = 0; i < dcpType.length; i++) {\r\n                if (dcpType[i].HTTP && dcpType[i].HTTP.Get) {\r\n                    result = dcpType[i].HTTP.Get.OnlineResource;\r\n                    break;\r\n                }\r\n            }\r\n            break;\r\n        case TC.Consts.layerType.WMTS:\r\n            result = self.parent.capabilities.OperationsMetadata.GetTile.DCP.HTTP.Get[0].href;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    const fragment = document.createDocumentFragment();\r\n    const textarea = document.createElement('textarea');\r\n    fragment.appendChild(textarea);\r\n    textarea.innerHTML = result;\r\n    result = textarea.textContent;\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getInfoFormats = function () {\r\n    var result = null;\r\n    var c = this.parent.capabilities;\r\n    if (c.Capability && c.Capability.Request.GetFeatureInfo) {\r\n        result = c.Capability.Request.GetFeatureInfo.Format;\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.infoFormatPreference = [\r\n    'application/json',\r\n    'application/vnd.ogc.gml/3.1.1',\r\n    'application/vnd.ogc.gml',\r\n    'application/vnd.esri.wms_featureinfo_xml',\r\n    'text/html',\r\n    'text/plain',\r\n    'text/xml'\r\n];\r\n\r\nTC.wrap.layer.Raster.prototype.getWMTSLayer = function (options) {\r\n    var result = null;\r\n    var self = this;\r\n    var capabilities = self.parent.capabilities;\r\n    options = options || {};\r\n    let tileMatrixSetByCRS;\r\n    if (options.crs) {\r\n        tileMatrixSetByCRS = capabilities.Contents.TileMatrixSet.filter(tms => TC.Util.CRSCodesEqual(options.crs, tms.SupportedCRS));\r\n    }\r\n    if (capabilities && capabilities.Contents) {\r\n        for (var i = 0; i < capabilities.Contents.Layer.length; i++) {\r\n            var layer = capabilities.Contents.Layer[i];\r\n            if (self.parent.options.layerNames === layer.Identifier) {\r\n                for (var j = 0; j < layer.TileMatrixSetLink.length; j++) {\r\n                    if (options.crs) {\r\n                        let tms = tileMatrixSetByCRS.filter(tmsCRS => tmsCRS.Identifier === layer.TileMatrixSetLink[j].TileMatrixSet);\r\n                        if (tms.length > 0) {\r\n                            result = layer;\r\n                            break;\r\n                        }\r\n                    } else if ((options.matrixSetId || self.parent.options.matrixSet) === layer.TileMatrixSetLink[j].TileMatrixSet) {\r\n                        result = layer;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getTileMatrix = function (matrixSet) {\r\n    var result = null;\r\n    var self = this;\r\n    var capabilities = self.parent.capabilities;\r\n    if (capabilities && capabilities.Contents && capabilities.Contents.TileMatrixSet) {\r\n        for (var i = 0; i < capabilities.Contents.TileMatrixSet.length; i++) {\r\n            var tms = capabilities.Contents.TileMatrixSet[i];\r\n            if (tms.Identifier === matrixSet) {\r\n                result = tms.TileMatrix;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getScaleDenominators = function (node) {\r\n    var result = [];\r\n    var self = this;\r\n    if (node.ScaleDenominator) {\r\n        result = [node.ScaleDenominator, node.ScaleDenominator];\r\n    }\r\n    else {\r\n        if (node.MinScaleDenominator || node.MaxScaleDenominator) {\r\n            result = [node.MaxScaleDenominator, node.MinScaleDenominator];\r\n        }\r\n    }\r\n    // Contemplamos el caso de una capa sin nombre: sus escalas válidas serán las de sus hijas.\r\n    if (!result.length && !self.getName(node)) {\r\n        var children = self.getLayerNodes(node);\r\n        var max = -Infinity, min = Infinity;\r\n        for (var i = 0, len = children.length; i < len; i++) {\r\n            var childDenominators = self.getScaleDenominators(children[i]);\r\n            if (childDenominators[0] > max) {\r\n                max = childDenominators[0];\r\n            }\r\n            if (childDenominators[1] < min) {\r\n                min = childDenominators[1];\r\n            }\r\n        }\r\n        if (max > -Infinity && min < Infinity) {\r\n            result = [max, min];\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getAttribution = function () {\r\n    const self = this;\r\n    const result = {};\r\n    const capabilities = TC.capabilities[self.parent.url];\r\n\r\n    try {//SILME\r\n        if (capabilities) {\r\n            if (capabilities.ServiceProvider) {\r\n                result.name = capabilities.ServiceProvider.ProviderName.trim();\r\n                result.site = capabilities.ServiceProvider.ProviderSite;\r\n                if (result.site && result.site.href && result.site.href.trim().length > 0) {\r\n                    result.site = result.site.href;\r\n                } else {\r\n                    delete result.site;\r\n                }\r\n            }\r\n            else if (capabilities.ServiceIdentification) {\r\n                result.name = capabilities.ServiceIdentification.Title.trim();\r\n            }\r\n            else {\r\n                result.name = capabilities.Service.Title.trim();\r\n            }\r\n        }\r\n    } catch (ex) {\r\n\r\n    }//END SILME\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getInfo = function (name) {\r\n    var self = this;\r\n    var result = {};\r\n    var capabilities = self.parent.capabilities;\r\n    var url = self.parent.url;//silme\r\n    if (capabilities) {\r\n        var i;\r\n        if (capabilities.Capability) { // WMS\r\n            var layerNodes = self.getAllLayerNodes();\r\n            for (i = 0; i < layerNodes.length; i++) {\r\n                var l = layerNodes[i];\r\n                if (self.parent.compareNames(self.getName(l), name)) {\r\n                    if (l.Title) {\r\n                        result.title = l.Title;\r\n                    }\r\n                    if (l.Abstract) {\r\n                        result.abstract = l.Abstract;\r\n                    }\r\n\r\n                    //Silme\r\n                    if (l.Name) {\r\n                        if (l.Name.includes(\":\"))\r\n                            result['name'] = l.Name.substr(l.Name.indexOf(\":\") + 1);\r\n                        else\r\n                            result['name'] = l.Name;\r\n                    }\r\n\r\n                    if (l.Layer) {\r\n                        result.isGroup = true;\r\n                    }\r\n                    //End Silme\r\n\r\n                    result.legend = [];\r\n\r\n                    var _process = function (value) {\r\n                        var legend = this.getLegend(value);\r\n\r\n                        if (legend.src)\r\n                            result.legend.push({\r\n                                src: legend.src, title: value.Title\r\n                            });\r\n                    };\r\n\r\n                    var _traverse = function (o, func) {\r\n                        if (o.Layer && o.Layer.length > 0) {\r\n                            for (var i in o.Layer) {\r\n                                //bajar un nivel en el árbol\r\n                                _traverse(o.Layer[i], func);\r\n                            }\r\n                        } else {\r\n                            func.apply(self, [o]);\r\n                        }\r\n                    };\r\n\r\n                    //Obtenemos todas las leyendas de la capa o grupo de capas\r\n                    _traverse(l, _process);\r\n\r\n                    if (l.MetadataURL && l.MetadataURL.length) {\r\n                        result.metadata = [];\r\n                        for (var j = 0; j < l.MetadataURL.length; j++) {\r\n                            var md = l.MetadataURL[j];\r\n                            result.metadata.push({\r\n                                format: md.Format, type: md.type, url: md.OnlineResource\r\n                            });\r\n                        }\r\n                    }\r\n\r\n                    //Silme\r\n                    result.dataUrl = [];\r\n                    if (l.DataURL) {\r\n                        result.dataUrl.push({ format: l.DataURL.Format, type: l.DataURL.OnlineResource.type, url: l.DataURL.OnlineResource.href });\r\n                    }\r\n\r\n                    result.parentAbstract = [];\r\n                    if (capabilities.Service.Abstract) {\r\n                        result.parentAbstract = capabilities.Service.Abstract;\r\n                    }\r\n\r\n                    result.contactPerson = [];\r\n                    if (capabilities.Service.ContactInformation.ContactPersonPrimary.ContactPerson) {\r\n                        result.contactPerson = capabilities.Service.ContactInformation.ContactPersonPrimary.ContactPerson;\r\n                    }\r\n\r\n                    result.contactOrganization = [];\r\n                    if (capabilities.Service.ContactInformation.ContactPersonPrimary.ContactOrganization) {\r\n                        result.contactOrganization = capabilities.Service.ContactInformation.ContactPersonPrimary.ContactOrganization;\r\n                    }\r\n\r\n                    result.contactMail = [];\r\n                    if (capabilities.Service.ContactInformation.ContactElectronicMailAddress) {\r\n                        result.contactMail = capabilities.Service.ContactInformation.ContactElectronicMailAddress;\r\n                    }\r\n\r\n                    result.contactTelephone = [];\r\n                    if (capabilities.Service.ContactInformation.ContactVoiceTelephone) {\r\n                        result.contactTelephone = capabilities.Service.ContactInformation.ContactVoiceTelephone;\r\n                    }\r\n\r\n                    result.fees = [];\r\n                    if (capabilities.Service.Fees) {\r\n                        result.fees = capabilities.Service.Fees;\r\n                    }\r\n\r\n                    result.accessConstraints = [];\r\n                    if (capabilities.Service.AccessConstraints) {\r\n                        result.accessConstraints = capabilities.Service.AccessConstraints;\r\n                    }\r\n\r\n                    result.url = [];\r\n                    if (url) {\r\n                        result.url = url;\r\n                    }\r\n                    //End silme\r\n\r\n                    result.queryable = l.queryable;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else if (capabilities.Contents) { // WMTS\r\n            const layerName = self.parent.names[0];\r\n            for (i = 0; i < capabilities.Contents.Layer.length; i++) {\r\n                const layer = capabilities.Contents.Layer[i];\r\n                if (layer.Identifier === layerName) {\r\n                    result.abstract = layer.Abstract;\r\n                    let metadata = layer.Metadata;\r\n                    if (metadata) {\r\n                        if (!Array.isArray(metadata)) {\r\n                            metadata = [metadata];\r\n                        }\r\n                        result.metadata = metadata.map(md => ({\r\n                            format: md.format,\r\n                            url: md.href\r\n                        }));\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getServiceType = function () {\r\n    var result = null;\r\n    var capabilities = this.parent.capabilities;\r\n    if (capabilities.Capability && capabilities.Capability.Request && capabilities.Capability.Request.GetMap) {\r\n        result = TC.Consts.layerType.WMS;\r\n    }\r\n    else if (capabilities.OperationsMetadata && capabilities.OperationsMetadata.GetTile) {\r\n        result = TC.Consts.layerType.WMTS;\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getServiceTitle = function () {\r\n    var result = null;\r\n    var capabilities = this.parent.capabilities;\r\n    if (capabilities.Capability && capabilities.Service) {\r\n        result = capabilities.Service.Title;\r\n    }\r\n    else if (capabilities.ServiceIdentification) {\r\n        result = capabilities.ServiceIdentification.Title;\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getRootLayerNode = function () {\r\n    var self = this;\r\n    var result;\r\n    if (self.getServiceType() === TC.Consts.layerType.WMS) {\r\n        result = self.parent.capabilities.Capability.Layer;\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getName = function (node, ignorePrefix) {\r\n    var result = node.Name;\r\n    if (result && ignorePrefix) {\r\n        var idx = result.indexOf(':');\r\n        if (idx >= 0) {\r\n            result = result.substr(idx + 1);\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getIdentifier = function (node) {\r\n    return node.Identifier;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getLayerNodes = function (node) {\r\n    var result = node.Layer;\r\n    if (!Array.isArray(result)) {\r\n        if (result) {\r\n            result = [result];\r\n        }\r\n        else {\r\n            result = [];\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getAllLayerNodes = function () {\r\n    var self = this;\r\n    if (!self._layerList) {\r\n        switch (self.getServiceType()) {\r\n            case TC.Consts.layerType.WMS:\r\n                var getNodeArray = function getNodeArray(node) {\r\n                    var r = [node];\r\n                    var children = self.getLayerNodes(node);\r\n                    for (var i = 0; i < children.length; i++) {\r\n                        r = r.concat(getNodeArray(children[i]));\r\n                    }\r\n                    return r;\r\n                };\r\n                var root = self.getRootLayerNode();\r\n                self._layerList = root ? getNodeArray(root) : [];\r\n                break;\r\n            case TC.Consts.layerType.WMTS:\r\n                self._layerList = self.parent.capabilities.Contents.Layer.slice();\r\n                break;\r\n            default:\r\n                self._layerList = [];\r\n                break;\r\n        }\r\n    }\r\n    return self._layerList;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.normalizeLayerNode = function (node) {\r\n    return node;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.normalizeCapabilities = function (capabilities) {\r\n    return capabilities;\r\n};\r\n\r\n// Objetos de apoyo para getLegend\r\nconst _fragment = document.createDocumentFragment();\r\nconst _textarea = document.createElement('textarea');\r\n_fragment.appendChild(_textarea);\r\n\r\nTC.wrap.layer.Raster.prototype.getLegend = function (node) {\r\n    var result = {};\r\n    var styles = node.Style;\r\n    if (styles && styles.length) {\r\n        if (styles.length && styles[0].LegendURL && styles[0].LegendURL.length) {\r\n            var legend = styles[0].LegendURL[0];\r\n            _textarea.innerHTML = legend.OnlineResource;\r\n            result.src = _textarea.textContent;\r\n            // Eliminado porque GeoServer miente con el tamaño de sus imágenes de la leyenda\r\n            //if (legend.size) {\r\n            //    result.width = legend.size[0];\r\n            //    result.height = legend.size[1];\r\n            //}\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.isCompatible = function (crs) {\r\n    var self = this;\r\n    var result = true;\r\n    var layer = self.parent;\r\n    switch (self.getServiceType()) {\r\n        case TC.Consts.layerType.WMS:\r\n            if (layer.capabilities && layer.capabilities.Capability && layer.capabilities.Capability.Layer) {\r\n                if (layer.names.length > 0) {\r\n                    var names = layer.names.slice(0);\r\n                    var _isCompatible = function _isCompatible(nodes, name, inCrs) {\r\n                        var r = false;\r\n                        if (nodes) {\r\n                            for (var i = 0; i < nodes.length; i++) {\r\n                                var n = nodes[i];\r\n                                const itemCRS = n.CRS || n.SRS;\r\n                                const crsList = Array.isArray(itemCRS) ? itemCRS : [itemCRS];\r\n                                var isIn = inCrs || crsList.indexOf(crs) >= 0;\r\n                                if (layer.compareNames(self.getName(n), name)) {\r\n                                    if (isIn) {\r\n                                        r = true;\r\n                                    }\r\n                                    break;\r\n                                }\r\n                                else if (_isCompatible(n.Layer, name, isIn)) {\r\n                                    r = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        return r;\r\n                    };\r\n                    while (names.length > 0) {\r\n                        if (!_isCompatible([layer.capabilities.Capability.Layer], names.pop())) {\r\n                            result = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        case TC.Consts.layerType.WMTS:\r\n            result = false;\r\n            if (layer.capabilities && layer.capabilities.Contents && layer.capabilities.Contents.TileMatrixSet) {\r\n                var tms = layer.capabilities.Contents.TileMatrixSet;\r\n                for (var i = 0; i < tms.length; i++) {\r\n                    if (tms[i].Identifier === layer.options.matrixSet) {\r\n                        result = TC.Util.CRSCodesEqual(crs, tms[i].SupportedCRS);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getCompatibleCRS = function () {\r\n    var self = this;\r\n    var result = [];\r\n    var layer = self.parent;\r\n    switch (self.getServiceType()) {\r\n        case TC.Consts.layerType.WMS:\r\n            if (layer.capabilities && layer.capabilities.Capability && layer.capabilities.Capability.Layer) {\r\n                if (layer.names.length > 0) {\r\n                    const crsLists = layer.names\r\n                        .map(function (name) {\r\n                            return layer\r\n                                .getNodePath(name) // array de nodos\r\n                                .map(function (node) {\r\n                                    const itemCRS = node.CRS || node.SRS || [];\r\n                                    const crsList = Array.isArray(itemCRS) ? itemCRS : [itemCRS];\r\n                                    return Array.isArray(crsList) ? crsList : [crsList];\r\n                                }) // array de arrays de crs\r\n                                .reduce(function (prev, cur) {\r\n                                    if (prev.length === 0) {\r\n                                        return cur;\r\n                                    }\r\n                                    cur.forEach(function (elm) {\r\n                                        if (prev.indexOf(elm) < 0) {\r\n                                            prev[prev.length - 1] = elm;\r\n                                        }\r\n                                    });// array con todos los crs\r\n                                    return prev;\r\n                                }, []);\r\n                        });\r\n\r\n                    if (crsLists.length === 1) {\r\n                        result = crsLists[0];\r\n                    } else {\r\n                        const otherCrsLists = crsLists.slice(1);\r\n                        result = crsLists[0].filter(function (elm) {\r\n                            return otherCrsLists.every(function (crsList) {\r\n                                return crsList.indexOf(elm) >= 0;\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        case TC.Consts.layerType.WMTS:\r\n            if (layer.capabilities && layer.capabilities.Contents) {\r\n                layer.capabilities.Contents.Layer\r\n                    .filter(function (l) {\r\n                        return l.Identifier === layer.layerNames;\r\n                    })  // La capa de interés\r\n                    .forEach(function (l) {\r\n                        const tileMatrixSets = l.TileMatrixSetLink\r\n                            .map(function (tmsl) {\r\n                                return tmsl.TileMatrixSet;\r\n                            });\r\n                        result = layer.capabilities.Contents.TileMatrixSet\r\n                            .filter(function (tms) {\r\n                                return tileMatrixSets.indexOf(tms.Identifier) >= 0;\r\n                            }) // TileMatrixSets asociados a la capa de interés\r\n                            .map(function (tms) {\r\n                                return tms.SupportedCRS;\r\n                            });\r\n                    });\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    if (result.length == 0) result.push(\"EPSG:3857\")//Silme\r\n\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getCompatibleLayers = function (crs) {\r\n    var self = this;\r\n    var result = [];\r\n    var layer = self.parent;\r\n    switch (self.getServiceType()) {\r\n        case TC.Consts.layerType.WMS:\r\n            if (layer.capabilities && layer.capabilities.Capability && layer.capabilities.Capability.Layer) {\r\n                var _recursiveFn = function (item, crs, inCrs) {\r\n                    var crsToCheck = item.CRS || item.SRS;\r\n                    var itemCRS = Array.isArray(crsToCheck) ? crsToCheck : [crsToCheck];\r\n                    var isIn = inCrs || itemCRS.indexOf(crs) >= 0;\r\n                    if (isIn && item.Name) {\r\n                        result.push(item.Name);\r\n                    }\r\n                    if (item.Layer) {\r\n                        for (var i = 0; i < item.Layer.length; i++) {\r\n                            _recursiveFn(item.Layer[i], crs, isIn);\r\n                        }\r\n                    }\r\n                };\r\n                _recursiveFn(layer.capabilities.Capability.Layer, crs);\r\n            }\r\n            break;\r\n        case TC.Consts.layerType.WMTS:\r\n            if (layer.capabilities && layer.capabilities.Contents && layer.capabilities.Contents.TileMatrixSet) {\r\n                var tmsList = layer.capabilities.Contents.TileMatrixSet;\r\n                for (var i = 0, ii = tmsList.length; i < ii; i++) {\r\n                    var tms = tmsList[i];\r\n                    if (TC.Util.CRSCodesEqual(crs, tms.SupportedCRS)) {\r\n                        var tmsIdentifier = tms.Identifier;\r\n                        var layerList = layer.capabilities.Contents.Layer;\r\n                        for (var j = 0, jj = layerList.length; j < jj; j++) {\r\n                            var tmsLinkList = layerList[j].TileMatrixSetLink;\r\n                            for (var k = 0, kk = tmsLinkList.length; k < kk; k++) {\r\n                                if (tmsLinkList[k].TileMatrixSet === tmsIdentifier) {\r\n                                    result.push(layerList[j].Identifier);\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getCompatibleMatrixSets = function (crs) {\r\n    var self = this;\r\n    var result = [];\r\n    normalizeProjection({\r\n        crs: crs\r\n    });\r\n    var layer = self.parent;\r\n    if (self.getServiceType() === TC.Consts.layerType.WMTS) {\r\n        var layerList = layer.capabilities.Contents.Layer;\r\n        var tmsList = layer.capabilities.Contents.TileMatrixSet;\r\n        for (var i = 0, ii = layerList.length; i < ii; i++) {\r\n            if (layer.layerNames === layerList[i].Identifier) {\r\n                var tmsLinkList = layerList[i].TileMatrixSetLink;\r\n                for (var j = 0, jj = tmsLinkList.length; j < jj; j++) {\r\n                    var tmsLink = tmsLinkList[j];\r\n                    for (var k = 0, kk = tmsList.length; k < kk; k++) {\r\n                        var tms = tmsList[k];\r\n                        if (tms.Identifier === tmsLink.TileMatrixSet) {\r\n                            if (TC.Util.CRSCodesEqual(crs, tms.SupportedCRS)) {\r\n                                result.push(tms.Identifier);\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.setWMTSUrl = function () {\r\n    var self = this;\r\n\r\n    self.getLayer().then(function (l) {\r\n        self.parent.options = self.parent.options || {};\r\n        var urls = l.getSource().getUrls();\r\n        self.parent.options.urlPattern = urls[urls.length - 1];\r\n    });\r\n};\r\n\r\nconst bufferExtent = function (extent, resolution, width) {\r\n    const extentBuffer = width * (resolution || 1);\r\n    return extent.map((v, i) => i < 2 ? v - extentBuffer : v + extentBuffer);\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.createWMSLayer = function (url, params, options) {\r\n    const self = this;\r\n    var result = null;\r\n\r\n    var source = new ol.source.ImageWMS({\r\n        url: url,\r\n        crossOrigin: options.map ? options.map.crossOrigin : undefined,\r\n        params: params,\r\n        ratio: TC.Cfg.imageRatio,\r\n        imageLoadFunction: self.parent.getImageLoad.bind(self.parent),\r\n        serverType: ol.source.WMSServerType.GEOSERVER\r\n    });\r\n\r\n    // flacunza: Aparentemente esta gestión de eventos es redundante, porque ya se están lanzando en Raster.getImageLoad\r\n    //source.on('imageloadstart', function (e) {\r\n    //    self.trigger(TC.Consts.event.BEFORETILELOAD, {\r\n    //        tile: e.image.getImage()\r\n    //    });\r\n    //});\r\n    //source.on('imageloadend', function (e) {\r\n    //    self.trigger(TC.Consts.event.TILELOAD, {\r\n    //        tile: e.image.getImage()\r\n    //    });\r\n    //});\r\n    //source.on('imageloaderror', function (e) {\r\n    //    self.trigger(TC.Consts.event.TILELOAD, {\r\n    //        tile: e.image.getImage()\r\n    //    });\r\n    //});\r\n\r\n\r\n    var layerOptions = {\r\n        visible: !!params.LAYERS.length || options && options.method && options.method === 'POST', //Las capas de temáticos cargadas por POST no tienen el atributo LAYERS\r\n        source: source\r\n    };\r\n\r\n    if (options.minResolution) {\r\n        layerOptions.minResolution = options.minResolution;\r\n    }\r\n    if (options.maxResolution) {\r\n        layerOptions.maxResolution = options.maxResolution;\r\n    }\r\n    result = new ol.layer.Image(layerOptions);\r\n\r\n    result._wrap = self;\r\n\r\n    self.addCommonEvents(result);\r\n\r\n    return result;\r\n};\r\n\r\nvar createWmtsSource = function (options) {\r\n    var self = this;\r\n    var result = null;\r\n    var sourceOptions = ol.source.WMTS.optionsFromCapabilities(self.parent.capabilities, {\r\n        layer: options.layerNames,\r\n        matrixSet: options.matrixSet,\r\n        crossOrigin: options.map ? options.map.options.crossOrigin : undefined,\r\n        requestEncoding: options.encoding,\r\n        format: options.format\r\n    });\r\n\r\n    // Parche: OL calcula fullTileRanges_ en base a la extensión cubierta por los límites del último nivel de zoom. \r\n    // Esto es un problema porque mapabase tiene límites más extensos en los primeros niveles de zoom que en los últimos.\r\n    // Reasignamos los límites en base a los que salen en el capabilities.\r\n    let matrixSetLinkNode;\r\n    const layerNode = self\r\n        .parent\r\n        .capabilities\r\n        .Contents\r\n        .Layer\r\n        .find(l => l.Identifier === options.layerNames);\r\n    if (layerNode) {\r\n        matrixSetLinkNode = layerNode\r\n            .TileMatrixSetLink\r\n            .find(tmsl => tmsl.TileMatrixSet === options.matrixSet);\r\n        if (matrixSetLinkNode) {\r\n            const tmsLimits = matrixSetLinkNode.TileMatrixSetLimits;\r\n            if (tmsLimits) {\r\n                sourceOptions.tileGrid.fullTileRanges_.forEach(function (range, idx) {\r\n                    const tmsl = tmsLimits[idx];\r\n                    range.minX = tmsl.MinTileCol;\r\n                    range.minY = tmsl.MinTileRow;\r\n                    range.maxX = tmsl.MaxTileCol;\r\n                    range.maxY = tmsl.MaxTileRow;\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(`Matrix set '${options.matrixSet}' not found`);\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(`Layer '${options.layerNames}' not found`);\r\n    }\r\n    /// Fin de parche ///\r\n    var https = 'https:';\r\n\r\n    if (sourceOptions) {\r\n        // añadido porque a partir de OL6 pasa el valor por defecto de 2048 al número de teselas que cabe en el viewport\r\n        sourceOptions.cacheSize = 2048;\r\n\r\n        if (location.protocol === https) {\r\n            sourceOptions.urls = sourceOptions.urls.map(function (elm) {\r\n                return elm.replace('http:', https);\r\n            });\r\n        }\r\n\r\n        sourceOptions.extent = self.parent.getExtent();\r\n\r\n        sourceOptions.crossOrigin = options.map ? options.map.crossOrigin : undefined;\r\n\r\n        result = new ol.source.WMTS(sourceOptions);\r\n        result.setTileLoadFunction(self.parent.getImageLoad.bind(self.parent));\r\n\r\n        // flacunza: Aparentemente esta gestión de eventos es redundante, porque ya se están lanzando en Raster.getImageLoad\r\n        //result.on(TILELOADSTART, function (e) {\r\n        //    self.trigger(TC.Consts.event.BEFORETILELOAD, {\r\n        //        tile: e.tile.getImage()\r\n        //    });\r\n        //});\r\n        //result.on(TILELOADEND, function (e) {\r\n        //    self.trigger(TC.Consts.event.TILELOAD, {\r\n        //        tile: e.tile.getImage()\r\n        //    });\r\n        //});\r\n        //result.on(TILELOADERROR, function (e) {\r\n        //    self.trigger(TC.Consts.event.TILELOAD, {\r\n        //        tile: e.tile.getImage()\r\n        //    });\r\n        //});\r\n\r\n        var prevFn = result.getResolutions.bind(result);\r\n        result.getResolutions = function () {\r\n            var resolutions = prevFn();\r\n            var matrix = self.parent.getLimitedMatrixSet();\r\n            //esto está mal, porque matrix podría empezar más abajo (tener recortado por ambos lados)\r\n            if (matrix && matrix.length) {\r\n                var ix = matrix[0].matrixIndex;\r\n                if (ix !== undefined) {\r\n                    resolutions = resolutions.slice(ix, matrix.length + ix);\r\n                }\r\n            }\r\n\r\n            return resolutions;\r\n        };\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.createWMTSLayer = function (options) {\r\n    const self = this;\r\n    var result = null;\r\n\r\n    var source = createWmtsSource.call(self, options);\r\n\r\n    if (source) {\r\n        var layerOptions = {\r\n            source: source\r\n        };\r\n        if (options.minResolution) {\r\n            layerOptions.minResolution = options.minResolution;\r\n        }\r\n        if (options.maxResolution) {\r\n            layerOptions.maxResolution = options.maxResolution;\r\n        }\r\n        result = new ol.layer.Tile(layerOptions);\r\n        result._wrap = self;\r\n\r\n        self.addCommonEvents(result);\r\n\r\n        var resolutions = source.getResolutions();\r\n        //Este +1 tan chungo es porque, en el caso en que la resolución del mapa es igual a la máxima del layer, openLayers lo oculta\r\n        result.setMaxResolution(resolutions[0] + 1);\r\n        result.setMinResolution(resolutions[resolutions.length - 1]);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n\r\n/*\r\n *  getParams: Gets the WMS layer getmap parameters\r\n *  Returns: object\r\n */\r\nTC.wrap.layer.Raster.prototype.getParams = function () {\r\n    return this.layer.getSource().getParams();\r\n};\r\n\r\n/*\r\n *  setParams: Sets the WMS layer getmap parameters\r\n *  Parameter: object\r\n */\r\nTC.wrap.layer.Raster.prototype.setParams = function (params) {\r\n    this.layer.getSource().updateParams(params);\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.setMatrixSet = function (matrixSet) {\r\n    const self = this;\r\n    if (self.parent.type === TC.Consts.layerType.WMTS) {\r\n        const newSource = createWmtsSource.call(self, TC.Util.extend({}, self.parent.options, { matrixSet: matrixSet }));\r\n        const newResolutions = newSource.getResolutions();\r\n        const newMaxResolution = newResolutions[0];\r\n        const newMinResolution = newResolutions[newResolutions.length - 1];\r\n        self.layer.setMaxResolution(newMaxResolution);\r\n        self.layer.setMinResolution(newMinResolution);\r\n        if (self.parent.minResolution) {\r\n            self.parent.minResolution = newMinResolution;\r\n        }\r\n        if (self.parent.maxResolution) {\r\n            self.parent.maxResolution = newMaxResolution;\r\n        }\r\n        self.layer.setSource(newSource);\r\n    }\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.getResolutions = function () {\r\n    if (this.layer.getSource) {\r\n        var ts = this.layer.getSource();\r\n        if (ts.getResolutions) return ts.getResolutions();\r\n        else return [];\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.setResolutions = function (resolutions) {\r\n    if (this.layer.getSource) {\r\n        var ts = this.layer.getSource();\r\n        if (ts.resolutions_) {\r\n            ts.resolutions_ = resolutions;\r\n        }\r\n        else if (ts.tileGrid) {\r\n            ts.tileGrid.resolutions_ = resolutions;\r\n        }\r\n    }\r\n};\r\n\r\nTC.wrap.layer.Raster.prototype.reloadSource = function () {\r\n    const self = this;\r\n    return new Promise(function (resolve, reject) {\r\n        if (self.layer.getSource) {\r\n            self.layer.getSource().refresh();\r\n            resolve();\r\n        }\r\n        else {\r\n            reject();\r\n        }\r\n    });\r\n};\r\n\r\nTC.wrap.Geometry = {\r\n    getNearest: function (point, candidates) {\r\n        var pline = new ol.geom.LineString(candidates);\r\n        return pline.getClosestPoint(point);\r\n    }\r\n};\r\n\r\n// En OL3 la imagen tiene el tamaño original. Escalamos si hace falta.\r\nvar setScaleFunction = function (imageStyle, iconWidth, olFeat) {\r\n    if (imageStyle) {\r\n        var setScaleForWidth = function (imgWidth) {\r\n            var markerWidth = (olFeat && olFeat._wrap ? olFeat._wrap.parent.options.width : null) || iconWidth;\r\n            if (markerWidth < imgWidth) {\r\n                var factor = markerWidth / imgWidth;\r\n                imageStyle.setScale(factor);\r\n            }\r\n        };\r\n        var imageSize = imageStyle.getSize();\r\n        if (imageSize) {\r\n            setScaleForWidth(imageSize[0]);\r\n        }\r\n        else {\r\n            var img = imageStyle.getImage();\r\n            if (img.naturalWidth) {\r\n                setScaleForWidth(img.naturalWidth);\r\n            }\r\n            else {\r\n                const fragment = document.createDocumentFragment();\r\n                const img = document.createElement('img');\r\n                img.src = imageStyle.getSrc();\r\n                fragment.appendChild(img);\r\n                return new Promise(function (resolve) {\r\n                    img.addEventListener('load', function () {\r\n                        setScaleForWidth(this.naturalWidth);\r\n                        resolve(this);\r\n                    });\r\n                });\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nvar getStyleValue = function (property, feature) {\r\n    var result = property;\r\n    var olFeat = feature && feature.wrap && feature.wrap.feature;\r\n    if (typeof property === 'string') {\r\n        var match = property.match(/^\\$\\{(.+)\\}$/);\r\n        if (match && olFeat) {\r\n            // Permitimos el formato ${prop.subprop.subsubprop}\r\n            var m = match[1].split('.');\r\n            var r = olFeat.getProperties();\r\n            for (var i = 0; i < m.length && r !== undefined; i++) {\r\n                r = r[m[i]];\r\n            }\r\n            if (r === undefined) {\r\n                r = feature.data;\r\n                for (i = 0; i < m.length && r !== undefined; i++) {\r\n                    r = r[m[i]];\r\n                }\r\n            }\r\n            result = r;\r\n        }\r\n    }\r\n    else if (TC.Util.isFunction(property)) {\r\n        result = property(feature);\r\n    }\r\n    return result;\r\n};\r\n\r\nconst mergeMapAndGeneralStyles = function (layer) {\r\n    const result = TC.Util.extend(true, {}, TC.Cfg.styles);\r\n    if (layer && layer.map) {\r\n        TC.Util.extend(true, result, layer.map.options.styles);\r\n    }\r\n    return result;\r\n};\r\n\r\n// Transformación de opciones de estilo en un estilo nativo OL3.\r\nconst createNativeStyle = function (options, olFeat) {\r\n    const nativeStyleOptions = [];\r\n\r\n    var feature;\r\n    var isPoint, isLine, isPolygon;\r\n    if (olFeat) {\r\n        const olGeom = olFeat.getGeometry();\r\n        switch (olGeom && olGeom.getType()) {\r\n            case 'Point':\r\n            case 'MultiPoint':\r\n                isPoint = true;\r\n                break;\r\n            case 'LineString':\r\n            case 'MultiLineString':\r\n                isLine = true;\r\n                break;\r\n            case 'Polygon':\r\n            case 'MultiPolygon':\r\n                isPolygon = true;\r\n                break;\r\n        }\r\n        if (olFeat._wrap) {\r\n            feature = olFeat._wrap.parent;\r\n        }\r\n        else {\r\n            // Si la API SITNA no ha completado su feature, creamos un mock-up para que no fallen las funciones de estilo\r\n            feature = {\r\n                id: TC.wrap.Feature.prototype.getId.call({\r\n                    feature: olFeat\r\n                }), // GLS añado el id de la feature para poder filtrar por la capa a la cual pertenece                    \r\n                features: olFeat.get('features'),\r\n                getData: function () {\r\n                    return TC.wrap.Feature.prototype.getData.call({\r\n                        feature: olFeat\r\n                    });\r\n                }\r\n            };\r\n\r\n\r\n        }\r\n    }\r\n    var isCluster = feature && Array.isArray(feature.features) && feature.features.length > 1;\r\n    var styles;\r\n    const externalStyles = mergeMapAndGeneralStyles(options.layer);\r\n    if (isCluster) {\r\n        styles = TC.Util.extend(true, {}, externalStyles.cluster, options && options.styles && options.styles.cluster ? options.styles.cluster : {});\r\n    }\r\n    else {\r\n        styles = TC.Util.extend(true, {}, externalStyles, options.styles);\r\n    }\r\n\r\n    var styleOptions = {};\r\n    if (styles.line && (isLine || !olFeat)) {\r\n        styleOptions = styles.line;\r\n        (styleOptions instanceof Array ? styleOptions : [styleOptions]).forEach(function (currentStyle, index) {\r\n            nativeStyleOptions[index] = Object.assign(nativeStyleOptions[index] || {},\r\n                {\r\n                    \"stroke\": new ol.style.Stroke({\r\n                        color: getStyleValue(currentStyle.strokeColor, feature),\r\n                        width: getStyleValue(currentStyle.strokeWidth, feature),\r\n                        lineDash: currentStyle.lineDash\r\n                    })\r\n                });\r\n        });\r\n    }\r\n\r\n    if (styles.polygon && (isPolygon || !olFeat)) {\r\n        styleOptions = styles.polygon;\r\n        (styleOptions instanceof Array ? styleOptions : [styleOptions]).forEach(function (currentStyle, index) {\r\n            nativeStyleOptions[index] = Object.assign(nativeStyleOptions[index] || {},\r\n                {\r\n                    \"fill\": new ol.style.Fill({\r\n                        color: getRGBA(getStyleValue(currentStyle.fillColor, feature), getStyleValue(currentStyle.fillOpacity, feature))\r\n                    }),\r\n                    \"stroke\": new ol.style.Stroke({\r\n                        color: getStyleValue(currentStyle.strokeColor, feature),\r\n                        width: getStyleValue(currentStyle.strokeWidth, feature),\r\n                        lineDash: currentStyle.lineDash\r\n                    })\r\n                });\r\n        });\r\n    }\r\n\r\n    if (styles.point && (isPoint || !olFeat)) {\r\n        styleOptions = styles.point;\r\n        (styleOptions instanceof Array ? styleOptions : [styleOptions]).forEach(function (currentStyle, index) {\r\n            var circleOptions = {\r\n                radius: getStyleValue(currentStyle.radius, feature) ||\r\n                    (getStyleValue(currentStyle.height, feature) + getStyleValue(currentStyle.width, feature)) / 4\r\n            };\r\n            if (currentStyle.fillColor) {\r\n                circleOptions.fill = new ol.style.Fill({\r\n                    color: getRGBA(getStyleValue(currentStyle.fillColor, feature), getStyleValue(currentStyle.fillOpacity, feature))\r\n                });\r\n            }\r\n            if (currentStyle.strokeColor) {\r\n                circleOptions.stroke = new ol.style.Stroke({\r\n                    color: getStyleValue(currentStyle.strokeColor, feature),\r\n                    width: getStyleValue(currentStyle.strokeWidth, feature),\r\n                    lineDash: currentStyle.lineDash\r\n                });\r\n            }\r\n\r\n            if (!isNaN(circleOptions.radius))\r\n                nativeStyleOptions[index] = Object.assign(nativeStyleOptions[index] || {}, { \"image\": new ol.style.Circle(circleOptions) });\r\n        });\r\n\r\n    }\r\n\r\n    if (styleOptions.label) {\r\n        nativeStyleOptions[nativeStyleOptions.length] = { \"text\": createNativeTextStyle(styleOptions, feature) };\r\n    }\r\n\r\n    if (styles.marker && (isPoint || !olFeat)) {\r\n        styleOptions = styles.marker;\r\n        (styleOptions instanceof Array ? styleOptions : [styleOptions]).forEach(function (currentStyle, index) {\r\n            var ANCHOR_DEFAULT_UNITS = 'fraction';\r\n            if (currentStyle.url) {\r\n                nativeStyleOptions[index] = Object.assign(nativeStyleOptions[index] || {},{\r\n                    \"image\": new ol.style.Icon({\r\n                        crossOrigin: 'anonymous',\r\n                        anchor: styleOptions.anchor || styles.marker.anchor || [0.5, 1],\r\n                        anchorXUnits: styleOptions.anchorXUnits || ANCHOR_DEFAULT_UNITS,\r\n                        anchorYUnits: styleOptions.anchorYUnits || ANCHOR_DEFAULT_UNITS,\r\n                        src: styleOptions.url,\r\n                        //10/11/2021 URI: Recuperamos la rotación de los iconos que viene en grados y lo pasamos a radianes\r\n                        rotation: styleOptions.rotation ? styleOptions.rotation / 180 * Math.PI : undefined\r\n                    }),\r\n                    \"text\": createNativeTextStyle(styleOptions, feature)\r\n                });\r\n            }\r\n        });\r\n    }\r\n    //10/11/2021 URI:Si entre la opciones de estilos trae un globo (balloon), seguramente se trate de la importación de un KML. Creamos un atributo nuevo llamado _balloon que posteriormente\r\n    //será leido en el método getTemplate de la feature para pintar el bocadillo tipado\r\n    //if (styleOptions.balloon)\r\n    //    (styleOptions.balloon instanceof Array ? styleOptions.balloon : [styleOptions.balloon]).forEach(function (currentStyle, index) {\r\n    //        nativeStyleOptions[index] = Object.assign(nativeStyleOptions[index] || {}, {\r\n    //            \"_balloon\": new ol.style.Text({ text: currentStyle })\r\n    //        });\r\n    //    });\r\n    var nativeStyle = nativeStyleOptions.map((currentStyle) => {\r\n        var style = new ol.style.Style(currentStyle)\r\n        if (styleOptions.balloon) style._balloon = new ol.style.Text({ text: styleOptions.balloon });\r\n        return style;\r\n    });\r\n    return nativeStyle;\r\n};\r\n\r\nconst createNativeTextStyle = function (styleObj, feature) {\r\n    if (!styleObj || !styleObj.label) {\r\n        return;\r\n    }\r\n\r\n    const textOptions = {\r\n        text: '' + getStyleValue(styleObj.label, feature),\r\n        overflow: true\r\n    };\r\n    //const olGeom = feature.wrap.feature.getGeometry();\r\n    //if (olGeom instanceof ol.geom.LineString || olGeom instanceof ol.geom.MultiLineString) {\r\n    //    textOptions.placement = ol.style.TextPlacement.LINE;\r\n    //}\r\n    if (styleObj.font) {\r\n        textOptions.font = styleObj.font;\r\n    }\r\n    else if (styleObj.fontSize) {\r\n        textOptions.font = getStyleValue(styleObj.fontSize, feature) + 'pt sans-serif';\r\n    }\r\n    if (styleObj.angle) {\r\n        textOptions.rotation = -Math.PI * getStyleValue(styleObj.angle, feature) / 180;\r\n    }\r\n    if (styleObj.fontColor) {\r\n        const fontColor = getStyleValue(styleObj.fontColor, feature);\r\n        textOptions.fill = new ol.style.Fill({\r\n            //09/11/2021 URI:Se estaba forzando la opacidad a 1 incluso si esta está definida en el 4 elemento del color\r\n            color: getRGBA(fontColor, (Array.isArray(fontColor) ? fontColor[3] : 1) || 1)\r\n            //color: getRGBA(getStyleValue(styleObj.fontColor, feature), 1)\r\n        });\r\n    }\r\n    if (styleObj.labelOutlineColor) {\r\n        const outlineColor = getStyleValue(styleObj.labelOutlineColor, feature);\r\n        textOptions.stroke = new ol.style.Stroke({\r\n            //09/11/2021 URI:Se estaba forzando la opacidad a 1 incluso si esta está definida en el 4 elemento del color\r\n            color: getRGBA(outlineColor, (Array.isArray(outlineColor) ? outlineColor[3] : 1) || 1),\r\n            //color: getRGBA(getStyleValue(styleObj.labelOutlineColor, feature), 1),\r\n            width: getStyleValue(styleObj.labelOutlineWidth, feature)\r\n        });\r\n    }\r\n    if (styleObj.labelOffset) {\r\n        textOptions.offsetX = styleObj.labelOffset[0];\r\n        textOptions.offsetY = styleObj.labelOffset[1];\r\n    }\r\n    //09/11/2021 URI: Antes no se le podía especificar la escala de la fuente de los labels        \r\n    if (styleObj.textScale) {\r\n        textOptions.scale = styleObj.textScale;\r\n    }\r\n    //09/11/2021 URI: Antes no se le podía especificar la alineación de la fuente de los labels           \r\n    if (styleObj.textAlign) {\r\n        textOptions.textAlign = styleObj.textAlign;\r\n    }\r\n    //\r\n    return new ol.style.Text(textOptions);\r\n};\r\n\r\nvar toHexString = function (number) {\r\n    var result = number.toString(16);\r\n    if (result.length === 1) {\r\n        result = '0' + result;\r\n    }\r\n    return result;\r\n};\r\n\r\nvar getHexColorFromArray = function (colorArray) {\r\n    return '#' + toHexString(colorArray[0]) + toHexString(colorArray[1]) + toHexString(colorArray[2]);\r\n};\r\n\r\nvar getStyleFromNative = function (olStyle, olFeat) {\r\n    var result = {\r\n    };\r\n    if (TC.Util.isFunction(olStyle)) {\r\n        if (olFeat) {\r\n            olStyle = olStyle(olFeat);\r\n        }\r\n    }\r\n    if (Array.isArray(olStyle)) {\r\n        olStyle = olStyle[0];\r\n    }\r\n    if (!TC.Util.isFunction(olStyle)) {\r\n        var color;\r\n        var stroke;\r\n        var fill;\r\n        if (olFeat) {\r\n            const olGeom = olFeat.getGeometry();\r\n            if (olGeom) {\r\n                const olGeomType = olGeom.getType();\r\n                // Si la geometría no aplica, no poner ol.style.Image\r\n                // Esto es porque el parser de KML genera estilos \"totum revolutum\" a partir de las URL de estilos (bug 27470)\r\n                if (olGeomType !== ol.geom.GeometryType.POINT && olGeomType !== ol.geom.GeometryType.MULTI_POINT) {\r\n                    olStyle.setImage(null);\r\n                }\r\n            }\r\n        }\r\n        var image = olStyle.getImage();\r\n        if (image) {\r\n            if (image instanceof ol.style.RegularShape) {\r\n                stroke = image.getStroke();\r\n                color = stroke.getColor();\r\n                if (color) {\r\n                    color = ol.color.asArray(color);\r\n                    result.strokeColor = getHexColorFromArray(color);\r\n                }\r\n                result.strokeWidth = stroke.getWidth();\r\n                fill = image.getFill();\r\n                if (fill) {\r\n                    color = fill.getColor();\r\n                    if (color) {\r\n                        color = ol.color.asArray(color);\r\n                        result.fillColor = getHexColorFromArray(color);\r\n                    }\r\n                    result.fillOpacity = color[3];\r\n                }\r\n            }\r\n            else {\r\n                result.url = image.getSrc();\r\n                var size = image.getSize();\r\n                if (size) {\r\n                    result.width = size[0];\r\n                    result.height = size[1];\r\n                    result.anchor = image.getAnchor();\r\n                    if (result.anchor) {\r\n                        result.anchor[0] = (result.anchor[0] / result.width) * (image.getScale() || 1);\r\n                        result.anchor[1] = (result.anchor[1] / result.height) * (image.getScale() || 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            stroke = olStyle.getStroke();\r\n            if (stroke) {\r\n                color = stroke.getColor();\r\n                if (color) {\r\n                    color = ol.color.asArray(color);\r\n                    result.strokeColor = getHexColorFromArray(color);\r\n                }\r\n                result.strokeWidth = stroke.getWidth();\r\n                result.lineDash = stroke.getLineDash();\r\n            }\r\n            fill = olStyle.getFill();\r\n            if (fill) {\r\n                color = fill.getColor();\r\n                if (color) {\r\n                    color = ol.color.asArray(color);\r\n                    result.fillColor = getHexColorFromArray(color);\r\n                }\r\n                result.fillOpacity = color[3];\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.getStyle = function () {\r\n    return getStyleFromNative(this.layer.getStyle());\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.reloadSource = function () {\r\n    const self = this;\r\n    return new Promise(function (resolve, _reject) {\r\n        const layerOptions = self.createVectorSource(self.parent, self.createStyles(self.parent));\r\n\r\n        if (self.parent.type === TC.Consts.layerType.WFS) {\r\n            var listenerKey = layerOptions.source.on('change', function (_e) {\r\n                if (layerOptions.source.getState() === 'ready') {\r\n                    ol.Observable.unByKey(listenerKey);\r\n\r\n                    resolve();\r\n                }\r\n            });\r\n        }\r\n\r\n        var features = self.layer.getSource().getFeatures();\r\n        self.layer.setSource(layerOptions.source);\r\n\r\n        if (layerOptions.style)\r\n            self.layer.setStyle(layerOptions.style);\r\n\r\n        if (self.parent.type !== TC.Consts.layerType.WFS) {\r\n            layerOptions.source.addFeatures(features);\r\n            resolve();\r\n        }\r\n    });\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.import = function (options) {\r\n    var self = this;\r\n    var opts = TC.Util.extend({\r\n    }, options);\r\n    opts.type = options.format;\r\n\r\n    var oldFeatures = self.layer.getSource().getFeatures();\r\n    var layerOptions = self.createVectorSource(opts, self.createStyles(self.parent));\r\n    self.layer.setSource(layerOptions.source);\r\n    if (layerOptions.style) {\r\n        self.layer.setStyle(layerOptions.style);\r\n    }\r\n\r\n    layerOptions.source.addFeatures(oldFeatures);\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.createVectorSource = function (options, nativeStyle) {\r\n    const self = this;\r\n\r\n    var createGenericLoader = function (url, format) {\r\n        var internalLoader = ol.featureloader.xhr(url, format);\r\n        return function (extent, resolution, projection) {\r\n            self.parent.state = TC.Layer.state.LOADING;\r\n            if (self.parent.map) {\r\n                self.parent.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, {\r\n                    layer: self.parent\r\n                });\r\n            }\r\n            internalLoader.call(this, extent, resolution, projection);\r\n        };\r\n    };\r\n    var usesGenericLoader = false;\r\n\r\n    var source;\r\n    var vectorOptions;\r\n\r\n    const isHeatmap = options.styles && options.styles.heatmap;\r\n    if (Array.isArray(options.url) || options.urls) {\r\n        var urls = options.urls || options.url;\r\n        urls = urls.map(function (elm, _idx) {\r\n            return TC.proxify(elm);\r\n        });\r\n        vectorOptions = {\r\n            url: urls,\r\n            //10/11/2021 URI:Ahora el KML Custom es una modificación directa del KML y no una sobrecarga de éste. Se añade al build de ol al compilar\r\n            //format: new ol.format.KMLCustom({\r\n            format: new ol.format.KML({\r\n                showPointNames: false,\r\n                extractStyles: !isHeatmap\r\n            }),\r\n            projection: options.crs\r\n        };\r\n    }\r\n    else if (options.url && options.type !== TC.Consts.layerType.WFS) {\r\n        vectorOptions = {\r\n            url: options.url,//TC.proxify(options.url),\r\n            projection: options.crs\r\n        };\r\n        vectorOptions.format = getFormatFromName(options.format, !isHeatmap) ||\r\n            getFormatFromName(TC.Util.getMimeTypeFromUrl(options.url), !isHeatmap) ||\r\n            getFormatFromName(options.type, !isHeatmap);\r\n        vectorOptions.loader = !(vectorOptions.format instanceof ol.format.KML) ? createGenericLoader(vectorOptions.url, vectorOptions.format) : function (_extent, _resolution, projection) {\r\n            const url = vectorOptions.url;\r\n            const format = vectorOptions.format;\r\n            self.parent.state = TC.Layer.state.LOADING;\r\n            if (self.parent.map) {\r\n                self.parent.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, {\r\n                    layer: self.parent\r\n                });\r\n            }\r\n            const toolProxification = new TC.tool.Proxification(TC.proxify);\r\n            toolProxification.fetch(url, { method: \"GET\",nomanage:true }).then(async function (response) {\r\n                if (response.ok) {\r\n                    const text = await response.text()\r\n                    var features = format.readFeatures(text, { featureProjection: projection });\r\n                    const xDocFilename = new DOMParser().parseFromString(text, \"text/xml\").querySelector(\"Document > name\");\r\n\r\n                    self.addFeatures(features);\r\n                    self.parent.state = TC.Layer.state.IDLE;\r\n                    if (response.headers.has(\"content-disposition\") && /(attachment);([^;]*)/gi.test(response.headers.get(\"content-disposition\"))) {\r\n                        const contentDisposition = response.headers.get(\"content-disposition\");\r\n                        var name;\r\n                        try {\r\n                            name = /filename\\*?=\\\"?([\\w|-]*\\'\\')?(.*\\.\\w*)\\\"?/gi.exec(contentDisposition)[2];\r\n                        } catch (ex) {\r\n                            try {\r\n                                name = contentDisposition.substring((contentDisposition.lastIndexOf(\"'\") || contentDisposition.indexOf(\"=\")) + 1);\r\n                            } catch (ex2) { }\r\n                        }\r\n                        self.parent.title = (xDocFilename ? xDocFilename.textContent : \"\") + (name ? (xDocFilename && xDocFilename.textContent != name ? \" (\" + name + \")\" : name) : \"\")\r\n                    }\r\n                    else\r\n                        self.parent.title = (xDocFilename ? xDocFilename.textContent : \"\") + (xDocFilename && xDocFilename.textContent != self.parent.title ? \" (\" + self.parent.title + \")\" : self.parent.title)\r\n\r\n                    if (self.parent.map) {\r\n                        self.parent.map.trigger(TC.Consts.event.LAYERUPDATE, {\r\n                            layer: self.parent\r\n                        });\r\n                    }\r\n                }\r\n            }).catch(function (response) {\r\n                self.parent.state = TC.Layer.state.IDLE;\r\n                if (self.parent.map) {\r\n                    self.parent.map.trigger(TC.Consts.event.LAYERERROR, {\r\n                        layer: self.parent, reason: response\r\n                    });\r\n                }\r\n            })\r\n            \r\n        };\r\n        usesGenericLoader = true;\r\n    }\r\n    else if (options.data) {\r\n        vectorOptions = {\r\n            projection: options.crs,\r\n            loader: function (extent, resolution, projection) {\r\n                self.parent.state = TC.Layer.state.LOADING;\r\n                if (self.parent.map) {\r\n                    self.parent.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, {\r\n                        layer: self.parent\r\n                    });\r\n                }\r\n                var format = this.getFormat();\r\n                try {\r\n                    var fs = format.readFeatures(options.data, {\r\n                        featureProjection: projection\r\n                    });\r\n                    this.addFeatures(fs);\r\n                    self.parent.state = TC.Layer.state.IDLE;\r\n                    if (self.parent.map) {\r\n                        self.parent.map.trigger(TC.Consts.event.LAYERUPDATE, {\r\n                            layer: self.parent, newData: options.data\r\n                        });\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    self.parent.state = TC.Layer.state.IDLE;\r\n                    if (self.parent.map) {\r\n                        self.parent.map.trigger(TC.Consts.event.LAYERERROR, {\r\n                            layer: self.parent, reason: e.message\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        vectorOptions.format = getFormatFromName(options.format) || getFormatFromName(options.type);\r\n    }\r\n    else if (options.type === TC.Consts.layerType.WFS) {\r\n        var outputFormat;\r\n        var mimeType;\r\n        switch (options.outputFormat) {\r\n            case TC.Consts.format.JSON:\r\n                outputFormat = new ol.format.GeoJSON({\r\n                    geometryName: options.geometryName\r\n                });\r\n                mimeType = 'json';\r\n                break;\r\n            case TC.Consts.format.GML3:\r\n                outputFormat = new ol.format.WFS({ gmlFormat: new ol.format.GML3() });\r\n                mimeType = TC.Consts.mimeType.GML;\r\n                break;\r\n            case TC.Consts.format.GML32:\r\n                outputFormat = new ol.format.WFS({ gmlFormat: new ol.format.GML32() });\r\n                mimeType = TC.Consts.mimeType.GML;\r\n                break;\r\n            default:\r\n                outputFormat = new ol.format.WFS({ gmlFormat: new ol.format.GML2() });\r\n                mimeType = TC.Consts.mimeType.GML;\r\n                break;\r\n        }\r\n        vectorOptions = {\r\n            format: outputFormat,\r\n            loader: function (_extent, _resolution, projection) {\r\n                var sOrigin = this;\r\n                var serviceUrl = options.url;\r\n                if (serviceUrl) {\r\n                    self.parent.state = TC.Layer.state.LOADING;\r\n                    self.parent.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, {\r\n                        layer: self.parent\r\n                    });\r\n\r\n                    const isFilterText = function () {\r\n                        return typeof options.properties === \"string\";\r\n                    };\r\n                    const manageResponse = (response) => {\r\n                        const data = response.data;\r\n                        let feats;\r\n                        try {\r\n                            feats = outputFormat.readFeatures(data);\r\n                        }\r\n                        catch (e) {\r\n                            self.parent.map.trigger(TC.Consts.event.LAYERERROR, { layer: self.parent, reason: e.message });\r\n                        }\r\n                        const triggerLayerUpdate = function () {\r\n                            self.parent.map.trigger(TC.Consts.event.LAYERUPDATE, {\r\n                                layer: self.parent, newData: data\r\n                            });\r\n                        };\r\n                        const onFeaturesAdd = function (e) {\r\n                            if (e.layer === self.parent) {\r\n                                self.parent.map.off(TC.Consts.event.FEATURESADD, onFeaturesAdd);\r\n                                triggerLayerUpdate();\r\n                            }\r\n                        };\r\n                        if (feats && feats.length) {\r\n                            self.parent.map.on(TC.Consts.event.FEATURESADD, onFeaturesAdd);\r\n                            sOrigin.addFeatures(feats);\r\n                        }\r\n                        else {\r\n                            triggerLayerUpdate();\r\n                        }\r\n                        self.parent.state = TC.Layer.state.IDLE;\r\n                    };\r\n                    const manageError = (error) => {\r\n                        if (error instanceof XMLDocument) {\r\n                            self.parent.map.trigger(TC.Consts.event.LAYERERROR, { layer: self.parent, reason: error.querySelector(\"ExceptionText\").innerHTML });\r\n                        }\r\n                        else {\r\n                            self.parent.map.trigger(TC.Consts.event.LAYERERROR, { layer: self.parent, reason: error });\r\n                        }\r\n                    };\r\n\r\n                    const makeAjaxCall = (onlyHits, capabilities) => {\r\n                        var ajaxOptions = {};\r\n                        var crs = projection.getCode();\r\n                        var version = options.version || capabilities.version || '1.1.0';\r\n                        capabilities.version = version;\r\n                        var url = serviceUrl;\r\n                        var featureType = Array.isArray(options.featureType) ? options.featureType : [options.featureType];\r\n                        //const isSpatial = function (filter) {\r\n                        //    switch (true) {\r\n                        //        case filter instanceof TC.filter.LogicalNary:\r\n                        //            return filter.conditions.some(f => isSpatial(f));\r\n                        //        case filter instanceof TC.filter.Spatial:\r\n                        //            return true;\r\n                        //        case filter instanceof TC.filter.EqualTo:               //SILME MV 20210503\r\n                        //            return true;                                        //SILME MV 20210503\r\n                        //        case filter instanceof TC.filter.NotEqualTo:            //SILME MV 20210607\r\n                        //            return true;                                        //SILME MV 20210607\r\n                        //        case filter instanceof TC.filter.GreaterThan:           //SILME MV 20210607\r\n                        //            return true;                                        //SILME MV 20210607\r\n                        //        case filter instanceof TC.filter.GreaterThanOrEqualTo:  //SILME MV 20210607\r\n                        //            return true;                                        //SILME MV 20210607\r\n                        //        case filter instanceof TC.filter.LessThan:              //SILME MV 20210607\r\n                        //            return true;                                        //SILME MV 20210607\r\n                        //        case filter instanceof TC.filter.LessThanOrEqualTo:     //SILME MV 20210607\r\n                        //            return true;                                        //SILME MV 20210607\r\n                        //        case filter instanceof TC.filter.IsLike:                //SILME MV 20210603 Aquesta es per sa crida WFS de  sa consulta alfanumèrica\r\n                        //            return true;                                        //SILME MV 20210603\r\n                        //        case typeof filter === \"string\":\r\n                        //            return Object.keys(window.TC.filter).filter(f => new TC.filter[f]() instanceof TC.filter.Spatial).some(f => filter.indexOf(f) > -1);\r\n                        //        default:\r\n                        //            return false;\r\n                        //    }\r\n                        //};\r\n                        const filterText = isFilterText();\r\n                        // flacunza: quitamos temporalmente la condicion isSpatial para no romper WFSEdit.\r\n                        //if (options.properties && (isSpatial(options.properties) || (filterText ? options.properties.length > TC.Consts.URL_MAX_LENGTH : options.properties.getText(capabilities.version).length > TC.Consts.URL_MAX_LENGTH))) {\r\n                        if (options.properties && (filterText ? options.properties.length > TC.Consts.URL_MAX_LENGTH : options.properties.getText(capabilities.version).length > TC.Consts.URL_MAX_LENGTH)) {\r\n                            ajaxOptions.method = 'POST';\r\n                            ajaxOptions.url = url;\r\n                            ajaxOptions.data = filterText ? options.properties : TC.Util.WFSQueryBuilder(featureType, options.properties, capabilities, onlyHits ? null : options.outputFormat, onlyHits, crs, options.maxFeatures);\r\n\r\n                            if (!filterText) {\r\n                                self.parent.map.trigger(TC.Consts.event.BEFOREAPPLYQUERY, { layer: self.parent, query: ajaxOptions.data });\r\n                            }\r\n                        }\r\n                        else {\r\n                            ajaxOptions.method = 'GET';\r\n                            ajaxOptions.url = url;\r\n                            ajaxOptions.data = {\r\n                                service: \"WFS\",\r\n                                request: \"GetFeature\",\r\n                                version: version,\r\n                                outputFormat: options.outputFormat,\r\n                                srsname: crs\r\n                            };\r\n                            ajaxOptions.data[\"typename\" + (version === \"2.0.0\" ? \"s\" : \"\")] = (options.featurePrefix ? options.featurePrefix + \":\" : \"\") + options.featureType;\r\n                            if (onlyHits)\r\n                                ajaxOptions.data = Object.assign(ajaxOptions.data, {\r\n                                    resultType: \"hits\"\r\n                                });\r\n                            if (options.properties) {\r\n                                if (options.properties instanceof TC.filter.Bbox)\r\n                                    ajaxOptions.data = Object.assign(ajaxOptions.data, {\r\n                                        BBOX: '{0},{1},{2},{3},{4}'.format(options.properties.extent.concat([crs]))\r\n                                    });\r\n                                else\r\n                                    ajaxOptions.data = Object.assign(ajaxOptions.data, {\r\n                                        filter: filterText ? options.properties : options.properties.getText(version).replace(/(fes\\:|ogc\\:)/g, \"\")\r\n                                    });\r\n\r\n                                if (!filterText && !onlyHits) {\r\n                                    self.parent.map.trigger(TC.Consts.event.BEFOREAPPLYQUERY, { layer: self.parent, query: options.properties.getText() });\r\n                                }\r\n                            }\r\n                            if (options.maxFeatures)\r\n                                ajaxOptions.data = Object.assign(ajaxOptions.data, {\r\n                                    maxFeatures: options.maxFeatures\r\n                                });\r\n                        }\r\n                        switch (onlyHits ? \"\" : mimeType) {\r\n                            case 'json':\r\n                                ajaxOptions.responseType = TC.Consts.mimeType.JSON;\r\n                                break;\r\n                            default:\r\n                                ajaxOptions.responseType = TC.Consts.mimeType.XML;\r\n                                break;\r\n                        }\r\n                        ajaxOptions.contentType = TC.Consts.mimeType.XML;\r\n\r\n                        return TC.ajax(ajaxOptions);\r\n                    };\r\n\r\n                    self.parent.getCapabilitiesPromise().then((_capabilities) => {\r\n                        const capabilities = _capabilities;\r\n                        //obtenos del capabilities nummax de features\r\n                        let numMaxFeatures = null;\r\n                        try {\r\n                            numMaxFeatures = capabilities.Operations.GetFeature.CountDefault.DefaultValue;\r\n                        }\r\n                        catch (e) {\r\n                        }\r\n                        if (numMaxFeatures) {\r\n                            if (!options.maxFeatures) options.maxFeatures = numMaxFeatures;\r\n                            let filterText = isFilterText();\r\n                            makeAjaxCall(filterText ? false : true, capabilities).then((response) => {\r\n                                if (filterText) {\r\n                                    manageResponse(response);\r\n                                    return;\r\n                                }\r\n                                var firstNode = response.data.children[0];\r\n                                if (firstNode.tagName.toLowerCase().indexOf(\"exception\") >= 0) {\r\n                                    self.parent.map.trigger(TC.Consts.event.LAYERERROR, { layer: self.parent, reason: firstNode.querySelector(\"ExceptionText\").innerHTML });\r\n                                }\r\n                                else if (firstNode.tagName.toLowerCase().indexOf(\"featurecollection\") >= 0) {\r\n                                    let numOfFeaturesFounded = parseInt((firstNode.attributes.numberMatched || firstNode.attributes.numberOfFeatures).value, 10);\r\n                                    if (isNaN(numOfFeaturesFounded) || numOfFeaturesFounded >= parseInt(numMaxFeatures, 10)) {\r\n                                        self.parent.map.trigger(TC.Consts.event.LAYERERROR, { layer: self.parent, reason: TC.Consts.WFSErrors.MAX_NUM_FEATURES, data: { limit: parseInt(numMaxFeatures, 10), founded: numOfFeaturesFounded } });\r\n                                        return;\r\n                                    }\r\n                                    else if (!isNaN(numOfFeaturesFounded) && numOfFeaturesFounded === 0) {\r\n                                        //si no encuentra nada. LLamo a la función para \r\n                                        manageResponse({\r\n                                            data: outputFormat instanceof ol.format.GeoJSON ? { \"type\": \"FeatureCollection\", \"totalFeatures\": 0, \"features\": [], \"crs\": null } : outputFormat.writeFeatures([])\r\n                                        });\r\n                                        return;\r\n                                    }\r\n                                    makeAjaxCall(false, capabilities).then(manageResponse).catch(manageError);\r\n                                }\r\n                            }).catch(manageError);\r\n                        }\r\n                        else {\r\n                            makeAjaxCall(false, capabilities).then(manageResponse).catch(manageError);\r\n                        }\r\n                    });\r\n                    self._requestUrl = serviceUrl;\r\n                }\r\n            },\r\n            //strategy: ol.loadingstrategy.all(),\r\n            projection: options.crs\r\n        };\r\n    }\r\n\r\n    if (options.features) {\r\n        vectorOptions = vectorOptions || {};\r\n        vectorOptions.features = options.features.map(f => f instanceof TC.Feature ? f.wrap.feature : f);\r\n    }\r\n\r\n    source = new ol.source.Vector(vectorOptions);\r\n\r\n    if (usesGenericLoader) {\r\n        source.on(CHANGE, function (_e) {\r\n            if (self.parent.map) {\r\n                self.parent.map.trigger(TC.Consts.event.LAYERUPDATE, {\r\n                    layer: self.parent\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    source._tcLayer = self.parent;\r\n\r\n    var markerStyle = options.style && options.style.marker ? options.style.marker : TC.Cfg.styles.marker;\r\n    if (!options.style || !options.style.marker) {\r\n        markerStyle = TC.Util.extend({}, markerStyle, {\r\n            anchor: TC.Cfg.styles.point.anchor\r\n        });\r\n    }\r\n\r\n    // Si habilitamos el clustering la fuente es especial\r\n    if (options.cluster) {\r\n        source = new ol.source.Cluster({\r\n            projection: options.crs,\r\n            distance: options.cluster.distance,\r\n            source: source\r\n        });\r\n\r\n        // Animación\r\n        if (options.cluster.animate) {\r\n            var getCurrentCoordinates = function (fromCoords, toCoords, duration, start) {\r\n                var fraction = Math.min((Date.now() - start) / duration, 1);\r\n                var dx = (toCoords[0] - fromCoords[0]) * fraction;\r\n                var dy = (toCoords[1] - fromCoords[1]) * fraction;\r\n                return [fromCoords[0] + dx, fromCoords[1] + dy];\r\n            };\r\n            var animate = function (parent, child) {\r\n                var start = Date.now();\r\n                var pCoords = parent.getGeometry().getCoordinates();\r\n                var cCoords = child.getGeometry().getCoordinates();\r\n                child.setGeometry(new ol.geom.Point(pCoords));\r\n                var step = function step() {\r\n                    var coords = getCurrentCoordinates(pCoords, cCoords, TC.Consts.CLUSTER_ANIMATION_DURATION, start);\r\n                    child.setGeometry(new ol.geom.Point(coords));\r\n                    if (coords[0] !== cCoords[0] && coords[1] !== cCoords[1]) {\r\n                        requestAnimationFrame(step);\r\n                    }\r\n                    else {\r\n                        clusterCache.splice(clusterCache.indexOf(parent), 1);\r\n                    }\r\n                };\r\n                requestAnimationFrame(step);\r\n            };\r\n            var clusterCache = [];\r\n            source.addEventListener(REMOVEFEATURE, function (e) {\r\n                var features = e.feature.get('features');\r\n                if (features && features.length > 1) {\r\n                    clusterCache.push(e.feature);\r\n                }\r\n            });\r\n            source.addEventListener(ADDFEATURE, function (e) {\r\n                var features = e.feature.get('features');\r\n                if (features) {\r\n                    var coords = features[0].getGeometry().getCoordinates();\r\n                    if (features.length > 1) {\r\n                        var match = clusterCache.filter(function (elm) {\r\n                            var elmCoords = elm.getGeometry().getCoordinates();\r\n                            return elmCoords[0] === coords[0] && elmCoords[1] === coords[1];\r\n                        });\r\n                        if (match.length) {\r\n                            clusterCache.splice(clusterCache.indexOf(match[0]), 1);\r\n                        }\r\n                    }\r\n                    var parent = clusterCache.filter(function (elm) {\r\n                        var children = elm.get('features');\r\n                        if (children && children.length > 0) {\r\n                            var child = children.filter(function (cElm) {\r\n                                var cCoords = cElm.getGeometry().getCoordinates();\r\n                                return cCoords[0] === coords[0] && cCoords[1] === coords[1];\r\n                            });\r\n                            return child.length > 0;\r\n                        }\r\n                    });\r\n                    if (parent.length) {\r\n                        animate(parent[parent.length - 1], e.feature);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    var s = source;\r\n    do {\r\n        s.addEventListener(ADDFEATURE, function (e) {\r\n            var olFeat = e.feature;\r\n            // OL3 dibuja el tamaño original del icono del marcador, lo escalamos si es necesario:\r\n            var style = getNativeFeatureStyle(olFeat, true);\r\n            if (style) {\r\n                const result = setScaleFunction(style.getImage(), markerStyle.width, olFeat);\r\n                if (result) {\r\n                    result.then(function () {\r\n                        if (e.feature._wrap.parent._legend) {\r\n                            const layer = e.feature._wrap.parent.layer;\r\n                            delete e.feature._wrap.parent._legend;\r\n                            layer.map.trigger(TC.Consts.event.VECTORUPDATE, { \"layer\": layer });\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        });\r\n        if (TC.Util.isFunction(s.getSource)) {\r\n            s = s.getSource();\r\n        }\r\n        else {\r\n            s = null;\r\n        }\r\n    }\r\n    while (s);\r\n\r\n    source.addEventListener(ADDFEATURE, function (e) {\r\n        const olFeat = e.feature;\r\n\r\n        const addFeatureToLayer = function (feat) {\r\n            var addFn;\r\n            switch (true) {\r\n                case TC.feature.Point && feat instanceof TC.feature.Point:\r\n                    addFn = self.parent.addPoint;\r\n                    break;\r\n                case TC.feature.Polyline && feat instanceof TC.feature.Polyline:\r\n                    addFn = self.parent.addPolyline;\r\n                    break;\r\n                case TC.feature.Polygon && feat instanceof TC.feature.Polygon:\r\n                    addFn = self.parent.addPolygon;\r\n                    break;\r\n                case TC.feature.MultiPolygon && feat instanceof TC.feature.MultiPolygon:\r\n                    addFn = self.parent.addMultiPolygon;\r\n                    break;\r\n                case TC.feature.MultiPolyline && feat instanceof TC.feature.MultiPolyline:\r\n                    addFn = self.parent.addMultiPolyline;\r\n                    break;\r\n                default:\r\n                    addFn = self.parent.addFeature;\r\n                    break;\r\n            }\r\n            if (addFn) {\r\n                var _timeout;\r\n                addFn.call(self.parent, olFeat).then(function (f) {\r\n                    var features = olFeat.get('features');\r\n                    if (Array.isArray(features)) {\r\n                        // Es una feature de fuente ol.source.Cluster\r\n                        f.features = features.map(function (elm) {\r\n                            return new feat.constructor(elm);\r\n                        });\r\n                    }\r\n\r\n                    // Timeout porque OL3 no tiene evento featuresadded. El timeout evita ejecuciones a lo tonto.\r\n                    clearTimeout(_timeout);\r\n                    _timeout = setTimeout(function () {\r\n                        self.parent.map.trigger(TC.Consts.event.FEATURESADD, {\r\n                            layer: self.parent, features: [f]\r\n                        });\r\n                    }, 50);\r\n                });\r\n            }\r\n        };\r\n\r\n        if (!olFeat._wrap || !olFeat._wrap.parent.layer) { // Solo actuar si no es una feature añadida desde la API\r\n            TC.wrap.Feature.createFeature(olFeat).then(addFeatureToLayer);\r\n        }\r\n    });\r\n\r\n    source.addEventListener(REMOVEFEATURE, function (e) {\r\n        var olFeat = e.feature;\r\n        if (olFeat._wrap) {\r\n            var idx = self.parent.features.indexOf(olFeat._wrap.parent);\r\n            if (idx > -1) {\r\n                self.parent.map.trigger(TC.Consts.event.BEFOREFEATUREREMOVE, {\r\n                    layer: self.parent, feature: olFeat._wrap.parent\r\n                });\r\n                self.parent.features.splice(idx, 1);\r\n                self.parent.map.trigger(TC.Consts.event.FEATUREREMOVE, {\r\n                    layer: self.parent, feature: olFeat._wrap.parent\r\n                });\r\n            }\r\n        }\r\n    });\r\n\r\n    source.addEventListener(ADDFEATURE, function (_e) {\r\n        if (self.parent.map) {\r\n            self.parent.map.trigger(TC.Consts.event.VECTORUPDATE, {\r\n                layer: self.parent\r\n            });\r\n        }\r\n    });\r\n\r\n    source.addEventListener(REMOVEFEATURE, function () {\r\n        if (self.parent.map) {\r\n            self.parent.map.trigger(TC.Consts.event.VECTORUPDATE, {\r\n                layer: self.parent\r\n            });\r\n        }\r\n    });\r\n\r\n    source.addEventListener(CLEAR, function () {\r\n        if (self.parent.map) {\r\n            self.parent.map.trigger(TC.Consts.event.FEATURESCLEAR, {\r\n                layer: self.parent\r\n            });\r\n        }\r\n    });\r\n\r\n    var layerOptions = {\r\n        source: source\r\n    };\r\n\r\n    if (options.minResolution) {\r\n        layerOptions.minResolution = options.minResolution;\r\n    }\r\n    if (options.maxResolution) {\r\n        layerOptions.maxResolution = options.maxResolution;\r\n    }\r\n\r\n    // En KML conservamos el estilo que viene con el archivo, así que no entramos aquí.\r\n    // A no ser que tenga clusters, porque OL no soporta por defecto la combinación de estilo KML con clusters.\r\n    if (!(vectorOptions && vectorOptions.format instanceof ol.format.KML) || options.cluster) {\r\n        layerOptions.style = nativeStyle || options.styles;\r\n    }\r\n\r\n    return layerOptions;\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.createStyles = function (options) {\r\n    var self = this;\r\n\r\n    var dynamicStyle = false;\r\n\r\n    if (TC.Util.isFunction(options)) {\r\n        dynamicStyle = true;\r\n        self.styleFunction = function (olFeat) {\r\n            return createNativeStyle(options(olFeat));\r\n        };\r\n    }\r\n    else {\r\n        options = TC.Util.extend({}, options);\r\n        options.crs = options.crs || TC.Cfg.crs;\r\n        const externalStyles = mergeMapAndGeneralStyles(self.parent);\r\n        options.styles = TC.Util.extend(true, externalStyles, options.styles);\r\n        var isDynamicStyle = function isDynamicStyle(obj) {\r\n            for (var key in obj) {\r\n                var prop = obj[key];\r\n                switch (typeof prop) {\r\n                    case 'string':\r\n                        if (/^\\$\\{(.+)\\}$/.test(prop)) {\r\n                            return true;\r\n                        }\r\n                        break;\r\n                    case 'object':\r\n                        if (isDynamicStyle(prop)) {\r\n                            return true;\r\n                        }\r\n                        break;\r\n                    case 'function':\r\n                        return true;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n\r\n        dynamicStyle = !!(options.cluster && options.cluster.styles) || isDynamicStyle(options.styles);\r\n        const opts = {};\r\n        if (self.parent.styles) {\r\n            opts.styles = Object.assign({}, self.parent.styles);\r\n        }\r\n        if (options.cluster && options.cluster.styles) {\r\n            opts.styles = Object.assign({}, opts.styles, { cluster: options.cluster.styles });\r\n        }\r\n        self.styleFunction = function (olFeat) {\r\n            opts.layer = self.parent;\r\n            return createNativeStyle(opts, olFeat);\r\n        };\r\n    }\r\n\r\n    var nativeStyle = dynamicStyle ? self.styleFunction : self.styleFunction();\r\n\r\n    return nativeStyle;\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.setStyles = function (options) {\r\n    const self = this;\r\n    self.getLayer().then(function (olLayer) {\r\n        if (options && options.heatmap || olLayer instanceof ol.layer.Heatmap) {\r\n            const features = olLayer.getSource().getFeatures();\r\n            features.forEach(f => f.setStyle(null));\r\n            const newOptions = TC.Util.extend(true, { features: features }, self.parent.options);\r\n            delete newOptions.styles;\r\n            self.layer = self.createVectorLayer(TC.Util.extend(newOptions, { styles: options }));\r\n            if (self.parent.map) {\r\n                const mapWrap = self.parent.map.wrap;\r\n                mapWrap.insertLayer(self.layer, mapWrap.getLayerIndex(olLayer));\r\n                mapWrap.removeLayer(olLayer);\r\n            }\r\n        }\r\n        else {\r\n            olLayer.setStyle(self.createStyles({ styles: options }));\r\n        }\r\n    });\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.createVectorLayer = function (options) {\r\n    const self = this;\r\n    var result = null;\r\n\r\n    options = options || self.parent.options;\r\n\r\n    const layerOptions = self.createVectorSource(options, self.createStyles(options));\r\n\r\n    //layerOptions.declutter = options.declutter || false;\r\n    if (options.styles && options.styles.heatmap) {\r\n        const hmOptions = TC.Util.extend({}, options.styles.heatmap);\r\n        if (TC.Util.isFunction(hmOptions.weight)) {\r\n            const oldWeightFn = hmOptions.weight;\r\n            hmOptions.weight = function (olFeat) {\r\n                return oldWeightFn(olFeat._wrap.parent);\r\n            };\r\n        }\r\n        result = new ol.layer.Heatmap(TC.Util.extend({ source: layerOptions.source }, hmOptions));\r\n    }\r\n    else {\r\n        result = new ol.layer.Vector(layerOptions);\r\n    }\r\n    result._wrap = self;\r\n\r\n    self.addCommonEvents(result);\r\n\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.addFeatures = function (features) {\r\n    const self = this;\r\n    const commit = function (l) {\r\n        if (l instanceof ol.layer.Heatmap) {\r\n            features.forEach(f => f.setStyle(null));\r\n        }\r\n        var source = l;\r\n        while (TC.Util.isFunction(source.getSource)) {\r\n            source = source.getSource();\r\n        }\r\n        source.addFeatures(features);\r\n    };\r\n    if (self.layer) {\r\n        commit(self.layer);\r\n    }\r\n    else {\r\n        self.getLayer().then(commit);\r\n    }\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.getFeatures = function () {\r\n    var olLayer = this.getLayer();\r\n    if (olLayer instanceof ol.layer.Layer) {\r\n        return olLayer.getSource().getFeatures();\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.getFeatureById = function (id) {\r\n    var olLayer = this.layer;\r\n    if (olLayer instanceof ol.layer.Layer) {\r\n        return olLayer.getSource().getFeatureById(id);\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.removeFeature = function (feature) {\r\n    const self = this;\r\n    const commit = function (l) {\r\n        if (feature.wrap.feature) {\r\n            let source = l.getSource();\r\n            let id = feature.wrap.feature.getId();\r\n            if (id && source.getFeatureById(id)) {\r\n                source.removeFeature(feature.wrap.feature);\r\n                if (source.getSource && Array.isArray(feature.features)) {\r\n                    const subSource = source.getSource();\r\n                    feature.features.slice().forEach(f => subSource.removeFeature(f.wrap.feature));\r\n                }\r\n            }\r\n        }\r\n    };\r\n    if (self.layer) {\r\n        commit(self.layer);\r\n    }\r\n    else {\r\n        self.getLayer().then(commit);\r\n    }\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.clearFeatures = function () {\r\n    const self = this;\r\n    const commit = function (l) {\r\n        var source = l.getSource();\r\n        if (source.clearFeatures) {\r\n            source.clearFeatures();\r\n        }\r\n        else {\r\n            source.clear();\r\n        }\r\n    };\r\n    if (self.layer) {\r\n        commit(self.layer);\r\n    }\r\n    else {\r\n        self.getLayer().then(commit);\r\n    }\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.setFeatureVisibility = function (feature, visible) {\r\n    var self = this;\r\n\r\n    var fillOptions = {\r\n        color: 'rgba(0, 0, 0, 0)'\r\n    };\r\n    var strokeOptions = {\r\n        color: 'rgba(0, 0, 0, 0)'\r\n    };\r\n    var displayNoneStyle = new ol.style.Style({\r\n        image: new ol.style.Circle({\r\n            radius: 0,\r\n            fill: new ol.style.Fill(fillOptions),\r\n            stroke: new ol.style.Stroke(strokeOptions)\r\n        }),\r\n        fill: new ol.style.Fill(fillOptions),\r\n        stroke: new ol.style.Stroke(strokeOptions)\r\n    });\r\n    var idx = self.parent.features.indexOf(feature);\r\n    if (idx >= 0) {\r\n        var olFeat = feature.wrap.feature;\r\n        self.getLayer().then(function (olLayer) {\r\n            if (visible && olFeat._originalStyle) {\r\n                olFeat.setStyle(olFeat._originalStyle);\r\n            }\r\n            else {\r\n                olFeat._originalStyle = olFeat.getStyle() || olLayer.getStyle();\r\n                olFeat.setStyle(displayNoneStyle);\r\n            }\r\n            self.parent.map.trigger(TC.Consts.event.VECTORUPDATE, {\r\n                layer: self.parent\r\n            });\r\n        });\r\n    }\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.getRGBA = function (color, opacity) {\r\n    return getRGBA(color, opacity);\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.findFeature = function (_values) {\r\n    // TODO: añadir ol.animation.zoom\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.getGetFeatureUrl = function () {\r\n    return this._requestUrl;\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.sendTransaction = function (inserts, updates, deletes) {\r\n    const self = this;\r\n    const getNativeFeature = function (feat) {\r\n        return feat.wrap.feature;\r\n    };\r\n    return new Promise(function (resolve, reject) {\r\n        const olInserts = inserts.map(getNativeFeature);\r\n        const olUpdates = updates.map(getNativeFeature);\r\n        const olDeletes = deletes.map(getNativeFeature);\r\n        if (inserts.length || updates.length || deletes.length) {\r\n            self.getLayer().then(function () {\r\n                var format = new ol.format.WFS();\r\n                var options = self.parent.options;\r\n                var transaction = format.writeTransaction(olInserts, olUpdates, olDeletes, {\r\n                    featurePrefix: options.featurePrefix,\r\n                    featureNS: options.featureNS,\r\n                    featureType: options.featureType[0]\r\n                });\r\n                var ajaxOptions = {\r\n                    url: self.parent.url,\r\n                    method: 'POST',\r\n                    contentType: TC.Consts.mimeType.XML,\r\n                    responseType: TC.Consts.mimeType.XML,\r\n                    data: transaction.outerHTML\r\n                };\r\n                TC.ajax(ajaxOptions)\r\n                    .then(function (response) {\r\n                        const data = response.data;\r\n                        const ns = 'http://www.opengis.net/ows';\r\n                        var er = data.getElementsByTagNameNS(ns, 'ExceptionReport')[0];\r\n                        var errorObj = {\r\n                            reason: ''\r\n                        };\r\n                        if (er) {\r\n                            var e = er.getElementsByTagNameNS(ns, 'Exception')[0];\r\n                            if (e) {\r\n                                errorObj.code = e.getAttribute('exceptionCode');\r\n                                var texts = e.getElementsByTagNameNS(ns, 'ExceptionText');\r\n                                for (var i = 0, len = texts.length; i < len; i++) {\r\n                                    errorObj.reason += '\\n' + texts[i].innerHTML;\r\n                                }\r\n                            }\r\n                            reject(errorObj);\r\n                        }\r\n                        else {\r\n                            var transactionResponse = format.readTransactionResponse(data);\r\n                            resolve(transactionResponse);\r\n                        }\r\n                    })\r\n                    .catch(function (err) {\r\n                        const errObj = {\r\n                            code: err.status || '',\r\n                            reason: err.msg || 'unknown'\r\n                        };\r\n                        reject(errObj);\r\n                    });\r\n            });\r\n        }\r\n        else {\r\n            resolve(self.parent);\r\n        }\r\n    });\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.setDraggable = function (draggable, onend, onstart) {\r\n    var self = this;\r\n\r\n    //tiene que estar a nivel de control para poder retirarla después\r\n    //var interaction;\r\n    Promise.all([self.parent.map.wrap.getMap(), self.getLayer()]).then(function (olObjects) {\r\n        const olMap = olObjects[0];\r\n        const olLayer = olObjects[1];\r\n        if (draggable) {\r\n            var interactionOptions = {\r\n                layers: [olLayer],\r\n                features: new ol.Collection(olLayer.getSource().getFeatures())\r\n            };\r\n            self.interaction = new ol.interaction.Translate(interactionOptions);\r\n            if (TC.Util.isFunction(onend)) {\r\n                self.interaction.on('translateend', function (e) {\r\n                    if (e.features.getLength()) {\r\n                        onend(e.features.item(0)._wrap.parent);\r\n                    }\r\n                });\r\n            }\r\n            if (TC.Util.isFunction(onstart)) {\r\n                self.interaction.on('translatestart', function (e) {\r\n                    if (e.features.getLength()) {\r\n                        onstart(e.features.item(0)._wrap.parent);\r\n                    }\r\n                });\r\n            }\r\n            olMap.addInteraction(self.interaction);\r\n        }\r\n        else if (self.interaction) {\r\n            olMap.removeInteraction(self.interaction);\r\n\r\n            // GLS: En IE no muestra la manita en el over sobre marcadores trasladables.\r\n            if (TC.Util.detectIE() && self._handlerDraggablePointerMove && TC.Util.isFunction(self._handlerDraggablePointerMove)) {\r\n                olMap.un('pointermove', self._handlerDraggablePointerMove);\r\n                delete self._handlerDraggablePointerMove;\r\n            }\r\n        }\r\n    });\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.getFeaturesInExtent = function (extent, tolerance) {\r\n    var self = this;\r\n    var features = this.layer.getSource().getFeatures();\r\n    var featuresInExtent = [];\r\n\r\n    if (tolerance) {\r\n        var leftCorner = self.parent.map.getPixelFromCoordinate([extent[0], extent[1]]);\r\n        var rightCorner = self.parent.map.getPixelFromCoordinate([extent[2], extent[3]]);\r\n        leftCorner[0] -= tolerance[0] / 2;\r\n        leftCorner[1] += tolerance[1];\r\n        rightCorner[0] += tolerance[0] / 2;\r\n        extent = self.parent.map.getCoordinateFromPixel(leftCorner).concat(self.parent.map.getCoordinateFromPixel(rightCorner));\r\n    }\r\n\r\n    for (var i = 0; i < features.length; i++) {\r\n        var feat = features[i];\r\n\r\n        var geometry = feat.getGeometry();\r\n        var coordinate = geometry.getCoordinates();\r\n\r\n        if (ol.extent.containsCoordinate(extent, coordinate)) {\r\n            featuresInExtent.push(feat._wrap.parent);\r\n        }\r\n    }\r\n\r\n    return featuresInExtent;\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.getAttribution = function () {\r\n    return null;\r\n};\r\nTC.wrap.layer.Vector.prototype.getGetMapUrl = function () {\r\n    var result = null;\r\n    var self = this;\r\n    switch (self.getServiceType()) {\r\n        case TC.Consts.layerType.WFS:\r\n            try {\r\n                result = self.parent.capabilities.Operations.GetFeature.DCP.HTTP.Get.href;\r\n            }\r\n            catch (ex) {\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    const fragment = document.createDocumentFragment();\r\n    const textarea = document.createElement('textarea');\r\n    fragment.appendChild(textarea);\r\n    textarea.innerHTML = result;\r\n    result = textarea.textContent;\r\n    return result;\r\n};\r\n\r\nTC.wrap.layer.Vector.prototype.getServiceType = function () {\r\n    var result = null;\r\n    //URI: Si se tiene capabilities se supone que es un servicio WFS\r\n    if (this.parent.capabilities) {\r\n        result = TC.Consts.layerType.WFS;\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.control.Click.prototype.register = function (map) {\r\n    var self = this;\r\n\r\n    self._trigger = function (e) {\r\n        if (map.view === TC.Consts.view.PRINTING) {\r\n            return;\r\n        }\r\n        var featureCount = 0;\r\n        map.wrap.map.forEachFeatureAtPixel(e.pixel,\r\n            function (feature, _layer) {\r\n                if (feature._wrap && feature._wrap.parent.showsPopup) {\r\n                    featureCount++;\r\n                }\r\n            },\r\n            {\r\n                hitTolerance: hitTolerance\r\n            });\r\n        if (!featureCount) {\r\n            // GLS: lanzo el evento click, para que los controles que no pueden heredar de click y definir un callback pueda suscribirse al evento\r\n            self.parent.map.trigger(TC.Consts.event.CLICK, {\r\n                coordinate: e.coordinate, pixel: e.pixel\r\n            });\r\n            self.parent.callback(e.coordinate, e.pixel);\r\n        }\r\n        // Seguimos adelante si no se han pinchado featuers\r\n        return featureCount === 0;\r\n    };\r\n};\r\n\r\nTC.wrap.control.Click.prototype.activate = function () {\r\n    var self = this;\r\n\r\n    self.parent.map.wrap.getMap().then(function (olMap) {\r\n        olMap.on(SINGLECLICK, self._trigger);\r\n    });\r\n};\r\n\r\nTC.wrap.control.Click.prototype.deactivate = function () {\r\n    var self = this;\r\n\r\n    self.parent.map.wrap.getMap().then(function (olMap) {\r\n        olMap.un(SINGLECLICK, self._trigger);\r\n    });\r\n};\r\n\r\nTC.wrap.control.ScaleBar.prototype.render = function () {\r\n    var self = this;\r\n    if (!self.ctl) {\r\n        self.ctl = new ol.control.ScaleLine({\r\n            target: self.parent.div\r\n        });\r\n    }\r\n    else {\r\n        self.ctl.updateElement_();\r\n    }\r\n};\r\n\r\nTC.wrap.control.ScaleBar.prototype.getText = function () {\r\n    var self = this;\r\n    if (self.ctl) {\r\n        return self.ctl.renderedHTML_;\r\n    }\r\n};\r\n\r\nTC.wrap.control.NavBar.prototype.register = function (map) {\r\n    var self = this;\r\n    map.wrap.getMap().then(function (olMap) {\r\n        const div = self.parent.div;\r\n        self.zCtl = new ol.control.Zoom({\r\n            target: div\r\n        });\r\n        // Ponemos para render una función modificada, para evitar que en los pinch zoom haya errores de este tipo:\r\n        // AssertionError: Assertion failed: calculated value (1.002067782531452) ouside allowed range (0-1)\r\n\r\n        self.zsCtl = new ol.control.ZoomSlider({\r\n            render: function (e) {\r\n                if (!e.frameState || !e.frameState.viewState || olMap.getView().getMinResolution() <= e.frameState.viewState.resolution) {\r\n                    // GLS: para evitar que el slider se configure en horizontal\r\n                    var render = function () {\r\n                        if (this.element.offsetWidth > this.element.offsetHeight) {\r\n                            if (!self.requestSliderSize) {\r\n                                self.requestSliderSize = window.requestAnimationFrame(render.bind(this));\r\n                            }\r\n\r\n                            window.requestAnimationFrame(render.bind(this));\r\n                        } else if (this.element.offsetWidth < this.element.offsetHeight) {\r\n                            if (self.requestSliderSize) {\r\n                                window.cancelAnimationFrame(self.requestSliderSize);\r\n                                delete self.requestSliderSize;\r\n                            }\r\n                            ol.control.ZoomSlider.prototype.render.call(this, e);\r\n                        }\r\n                    };\r\n                    render.call(this);\r\n                }\r\n            }\r\n        });\r\n        self.zsCtl.setTarget(div);\r\n\r\n        olMap.addControl(self.zsCtl);\r\n        olMap.addControl(self.zCtl);\r\n\r\n        div.querySelectorAll('button').forEach(function (button) {\r\n            button.classList.add('tc-ctl-btn', 'tc-float-btn', self.parent.CLASS + '-btn');\r\n            button.style.display = 'block';\r\n            button.innerHTML = '';\r\n            if (button.matches('.ol-zoom-in')) {\r\n                button.classList.add(self.parent.CLASS + '-btn-zoomin');\r\n                button.setAttribute('title', self.parent.getLocaleString('zoomIn'));\r\n            }\r\n            if (button.matches('.ol-zoom-out')) {\r\n                button.classList.add(self.parent.CLASS + '-btn-zoomout');\r\n                button.setAttribute('title', self.parent.getLocaleString('zoomOut'));\r\n            }\r\n        });\r\n\r\n        const zoomSlider = div.querySelector('.ol-zoomslider');\r\n        zoomSlider.classList.add(self.parent.CLASS + '-bar');\r\n        zoomSlider.querySelector('.ol-zoomslider-thumb').classList.add(self.parent.CLASS + '-slider');\r\n\r\n        map.on(TC.Consts.event.BASELAYERCHANGE, self.refresh.bind(self));\r\n    });\r\n};\r\n\r\nTC.wrap.control.NavBar.prototype.refresh = function () {\r\n    /*\r\n    var map = this.parent.map;\r\n    var olMap = map.wrap.map;\r\n\r\n    olMap.removeControl(self.zsCtl);\r\n    var res = map.getResolutions();\r\n    self.zsCtl = new ol.control.ZoomSlider(\r\n        {\r\n            target: this.parent.div,\r\n            \"maxResolution\": res[0],\r\n            \"minResolution\": res[res.length - 1]\r\n        });\r\n\r\n    olMap.addControl(self.zsCtl);\r\n    $(map.div).find('.ol-zoomslider').addClass(self.parent.CLASS + '-bar').find('.ol-zoomslider-thumb').addClass(self.parent.CLASS + '-slider');\r\n    */\r\n    var self = this;\r\n    var map = self.parent.map.wrap.map;\r\n    // Puede ser que se llame a refresh antes de que esté inicializado ol.control.ZoomSlider. En ese caso llamamos a render que lo inicializa.\r\n    // Como render necesita un ol.MapEvent, esperamos al evento POSTRENDER.\r\n\r\n    self.parent.renderPromise().then(function () {\r\n        if (self.zsCtl.sliderInitialized_) {\r\n            var res = map.getView().getResolution();\r\n            self.zsCtl.setThumbPosition_(res);\r\n        }\r\n        else {\r\n            map.once(POSTRENDER, function (e) {\r\n                self.zsCtl.render(e);\r\n            });\r\n        }\r\n    });\r\n};\r\n\r\nTC.wrap.control.NavBarHome.prototype.register = function (map) {\r\n    var self = this;\r\n    map.wrap.getMap().then(function (olMap) {\r\n        const div = self.parent.div;\r\n\r\n        self.z2eCtl = new ol.control.ZoomToExtent({\r\n            target: div, extent: map.initialExtent, tipLabel: ''\r\n        });\r\n\r\n        olMap.addControl(self.z2eCtl);\r\n\r\n        div.querySelectorAll('button').forEach(function (button) {\r\n            button.style.display = 'block';\r\n            button.innerHTML = '';\r\n        });\r\n        const homeBtn = div.querySelector('.ol-zoom-extent button');\r\n        homeBtn.classList.add('tc-ctl-btn', 'tc-float-btn', self.parent.CLASS + '-btn');\r\n        homeBtn.setAttribute('title', self.parent.getLocaleString('zoomToInitialExtent'));\r\n    });\r\n};\r\n\r\nTC.wrap.control.NavBarHome.prototype.setInitialExtent = function (extent) {\r\n    this.z2eCtl.extent = extent;\r\n};\r\n\r\nTC.wrap.control.Coordinates.prototype.register = function (map) {\r\n    const self = this;\r\n    self.map = map;\r\n\r\n    return new Promise(function (resolve, _reject) {\r\n\r\n        self._coordsTrigger = function (e) {\r\n            self.parent.coordsToClick(e);\r\n        };\r\n\r\n        map.wrap.getMap().then(function (olMap) {\r\n            self.olMap = olMap;\r\n\r\n            if (!self.parent.map.on3DView) {\r\n                var projection = olMap.getView().getProjection();\r\n                self.parent.crs = projection.getCode();\r\n                self.parent.units = projection.getUnits();\r\n            } else {\r\n                self.parent.crs = self.parent.map.view3D.crs;\r\n                self.parent.units = TC.Consts.units.DEGREES;\r\n            }\r\n\r\n            self.parent.isGeo = self.parent.units === ol.proj.Units.DEGREES;\r\n\r\n            //$(olMap.getViewport()).add(self.parent.div);\r\n            resolve();\r\n        });\r\n    });\r\n};\r\n\r\nTC.wrap.control.Coordinates.prototype.onMouseMove = function (e) {\r\n    var self = this;\r\n    if (self.map.wrap.map) {\r\n        var coords = self.map.wrap.map.getEventCoordinate(e);\r\n        if (coords) {\r\n            if (self.parent.isGeo) {\r\n                self.parent.latLon = coords.reverse();\r\n            } else {\r\n                self.parent.xy = coords;\r\n            }\r\n\r\n            self.parent.update.apply(self.parent, arguments);\r\n        }\r\n    }\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.register = function (map) {\r\n    var self = this;\r\n    self.map = map;\r\n\r\n    self._snapTrigger = function (e) {\r\n        if (e.dragging) {\r\n            return;\r\n        }\r\n        self.initSnap(self.olMap.getEventCoordinate(e.originalEvent), e.pixel);\r\n    };\r\n\r\n    self._postrenderTrigger = function (e) {\r\n        self.duringTrackSnap(e);\r\n    };\r\n\r\n    map.wrap.getMap().then(function (olMap) {\r\n        self.olMap = olMap;\r\n    });\r\n};\r\n\r\nvar getTrackingLine = function () {\r\n    var self = this;\r\n\r\n    return self.parent.layerTracking.features.filter(function (f) {\r\n        return f instanceof TC.feature.Polyline;\r\n    })[0];\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.hasCoordinates = function () {\r\n    var self = this;\r\n\r\n    return self.parent.layerTracking.features.length > 0 && self.parent.layerTracking.features[0].geometry.length >= 1;\r\n};\r\n\r\n//var getTime = function (timeFrom, timeTo) {\r\n//    var diff = timeTo - timeFrom;\r\n//    var d = {\r\n//        s: Math.floor((diff / 1000) % 60),\r\n//        m: Math.floor(((diff / (1000 * 60)) % 60)),\r\n//        h: Math.floor(((diff / (1000 * 60 * 60)) % 24))\r\n//    };\r\n\r\n//    return TC.Util.extend({}, d, { toString: (\"00000\" + d.h).slice(-2) + ':' + (\"00000\" + d.m).slice(-2) + ':' + (\"00000\" + d.s).slice(-2) });\r\n//};\r\n\r\nTC.wrap.control.Geolocation.prototype.addWaypoint = function (position, properties) {\r\n    var self = this;\r\n\r\n    var waypoint = new ol.Feature({\r\n        geometry: new ol.geom.Point([position[0], position[1], properties.ele, properties.time], 'XYZM')\r\n    });\r\n    waypoint.setProperties(properties);\r\n\r\n    self.parent.layerTracking.wrap.layer.getSource().addFeature(waypoint);\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.addPosition = function (position, heading, m, speed, _accuracy, _altitudeAccuracy, altitude) {\r\n    var self = this;\r\n\r\n    var x = position[0];\r\n    var y = position[1];\r\n\r\n    var line = getTrackingLine.call(this);\r\n    if (self.parent.layerTracking.features && line) {\r\n        var last = line.geometry.length > 0 && line.geometry[line.geometry.length - 1];\r\n        if (last && last.length === 0) {\r\n            self.parent.layerTracking.features[0].geometry.push([x, y, altitude, m]);\r\n            line.wrap.feature.getGeometry().appendCoordinate([x, y, altitude, m]);\r\n        }\r\n        else {\r\n            var lx = last[0];\r\n            var ly = last[1];\r\n\r\n            if (x !== lx || y !== ly) {\r\n                self.parent.layerTracking.features[0].geometry.push([x, y, altitude, m]);\r\n                line.wrap.feature.getGeometry().appendCoordinate([x, y, altitude, m]);\r\n            }\r\n        }\r\n\r\n        TC.Util.storage.setSessionLocalValue(self.parent.Const.LocalStorageKey.TRACKINGTEMP, self.formattedToStorage(self.parent.layerTracking).features);\r\n    }\r\n\r\n    self.parent.trigger(self.parent.Const.Event.STATEUPDATED, {\r\n        moving: (heading != undefined && speed != undefined && speed > 0 && heading > 0)\r\n    });\r\n};\r\nTC.wrap.control.Geolocation.prototype.roundCoordinates = function (obj, precision) {\r\n    const countDecimals = function (number) {\r\n\r\n        if (Math.floor(number) === number) return 0;\r\n\r\n        var str = number.toString();\r\n        return str.length - str.lastIndexOf(\".\") - 1;\r\n    }\r\n    const numDecimals = Math.min(countDecimals(obj), precision);\r\n    return Math.round(obj * Math.pow(10, numDecimals)) / Math.pow(10, numDecimals);\r\n};\r\n\r\n\r\nTC.wrap.control.Geolocation.prototype.positionChangehandler = function (geoposition) {\r\n    const self = this;\r\n    var accuracy, heading, speed, altitude, altitudeAccuracy;\r\n\r\n    if (!getTrackingLine.call(this)) {\r\n        self.parent.setTracking(false);\r\n    }\r\n\r\n    return new Promise(function (resolve, _reject) {\r\n        if (geoposition && geoposition.coords) {\r\n            self.parent.layerGPS.clearFeatures();\r\n\r\n            accuracy = geoposition.coords.accuracy / self.parent.map.getMetersPerUnit() || 0;\r\n            heading = geoposition.coords.heading || geoposition[2] || 0;\r\n            speed = geoposition.coords.speed ? geoposition.coords.speed * 3.6 : 0;\r\n            altitude = geoposition.coords.altitude || 0;\r\n            altitudeAccuracy = geoposition.coords.altitudeAccuracy || 0;\r\n\r\n            if (self.parent.layerTracking) {\r\n                var position_ = [geoposition.coords && geoposition.coords.longitude || geoposition[0], geoposition.coords && geoposition.coords.latitude || geoposition[1]];\r\n                if (!position_.every((c) => c)) { // al menos desde las herramientas de desarrollo puede llegar con lat/lon a undefined lo que provoca un error de OL: TypeError: coordinates must be finite numbers\r\n                    resolve(null);\r\n                }\r\n                var projectedPosition = TC.Util.reproject(position_, 'EPSG:4326', self.parent.map.crs);\r\n\r\n                projectedPosition[0] = self.roundCoordinates(projectedPosition[0], self.map.wrap.isGeo() ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION);\r\n                projectedPosition[1] = self.roundCoordinates(projectedPosition[1], self.map.wrap.isGeo() ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION);\r\n\r\n                self.addPosition(projectedPosition, heading, new Date().getTime(), speed, accuracy, altitudeAccuracy, altitude);\r\n\r\n                var coords = getTrackingLine.call(self).geometry;\r\n                var len = coords.length;\r\n                if (len >= 2) {\r\n                    self.parent.deltaMean = (coords[len - 1][3] - coords[0][3]) / (len - 1);\r\n                }\r\n\r\n                self.parent.trigger(self.parent.Const.Event.POSITIONCHANGE, {\r\n                    pd: {\r\n                        \"position\": projectedPosition,\r\n                        \"altitude\": altitude,\r\n                        \"accuracy\": accuracy,\r\n                        \"heading\": TC.Util.radToDeg(heading),\r\n                        \"speed\": speed\r\n                    }\r\n                });\r\n\r\n                Promise.all([self.parent.layerGPS.addPoint(projectedPosition, {\r\n                    radius: 6,\r\n                    fillColor: '#00CED1',\r\n                    fillOpacity: 1,\r\n                    strokeColor: '#ffffff',\r\n                    strokeWidth: 2,\r\n                    showsPopup: false\r\n                }), self.parent.layerGPS.addCircle([projectedPosition, accuracy], {\r\n                    strokeColor: '#ffffff',\r\n                    strokeWidth: 1,\r\n                    fillColor: '#00CED1',\r\n                    fillOpacity: 0.3,\r\n                    showsPopup: false\r\n                })]).then(function (features) {\r\n                    const marker = features[0];\r\n                    const accuracyCircle = features[1];\r\n                    self.parent.geopositionTracking = true;\r\n\r\n                    if (self.parent.firstPosition == false) {\r\n                        self.parent.firstPosition = true;\r\n\r\n                        if (!self.parent.trackCenterButton) {\r\n                            self.parent.trackCenterButton = self.parent.div.querySelector('.' + self.parent.CLASS + '-track-center');\r\n                            self.parent.trackCenterButton.querySelector('button').addEventListener('click', function () {\r\n                                if (!this.classList.contains(TC.Consts.classes.UNPLUGGED)) {\r\n                                    self.parent.setFollowing(false);\r\n                                    return;\r\n                                }\r\n                                self.parent.setFollowing(true);\r\n                                self.parent.Move(self.parent.layerGPS.features[0].geometry);\r\n                                //self.parent.Move(self.parent.layerGPS.features);                                \r\n                                /*self.parent.layerGPS.map.setCenter(self.parent.layerGPS.features[0].geometry, { animate: false }).then(function () {\r\n                                    setTimeout(function () {\r\n                                        self.parent.setFollowing(true)\r\n                                    },300);\r\n                                });*/\r\n\r\n                                self.parent.getTrackInfoPanel().then(function (infoPanel) {\r\n                                    if (!infoPanel.isVisible()) {\r\n                                        infoPanel.doVisible();\r\n                                    }\r\n\r\n                                    if (infoPanel.isMinimized()) {\r\n                                        infoPanel.maximize();\r\n                                    }\r\n                                });\r\n                            });\r\n\r\n                            var controlContainer = self.parent.map.getControlsByClass('TC.control.ControlContainer')[0];\r\n                            if (controlContainer) {\r\n                                self.parent.trackCenterButton = controlContainer.addElement({ position: controlContainer.POSITION.LEFT, htmlElement: self.parent.trackCenterButton });\r\n                            } else {\r\n                                self.parent.map.div.appendChild(self.parent.trackCenterButton);\r\n                            }\r\n\r\n                        }\r\n                        self.parent.trackCenterButton.classList.remove(TC.Consts.classes.HIDDEN);\r\n                        self.parent.setFollowing(true);\r\n                        self.parent.Move(self.parent.layerGPS.features);\r\n                        //self.parent.layerGPS.map.zoomToFeatures(self.parent.layerGPS.features);\r\n                    }\r\n\r\n                    resolve({\r\n                        marker: marker, accuracy: accuracyCircle\r\n                    });\r\n                });\r\n\r\n            } else { resolve(null); }\r\n        } else {\r\n            resolve(null);\r\n        }\r\n    });\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.setTracking = function (tracking) {\r\n    var self = this;\r\n\r\n    if (tracking) {\r\n        self.parent.firstPosition = false;\r\n        var sessionwaypoint = [];\r\n\r\n        var nativeTrackingFeature;\r\n\r\n        if (self.parent.sessionTracking) {\r\n\r\n            var JSONParser = new TC.wrap.parser.JSON();\r\n            var features = JSONParser.parser.readFeatures(self.parent.sessionTracking);\r\n            if (features && self.parent.storageCRS !== self.parent.map.crs) {\r\n                features = features.map(function (feature) {\r\n                    var clone = feature.clone();\r\n                    clone.getGeometry().transform(self.parent.storageCRS, self.parent.map.crs);\r\n                    return clone;\r\n                });\r\n            }\r\n\r\n            var coordinates = features.filter(function (feature) {\r\n                var type = feature.getGeometry().getType().toLowerCase();\r\n                if (type === 'point') { sessionwaypoint.push(feature); }\r\n                return type === 'linestring' || type === 'multilinestring';\r\n            })[0].getGeometry().getCoordinates();\r\n\r\n            nativeTrackingFeature = new ol.Feature({\r\n                geometry: new ol.geom.LineString(coordinates, 'XYZM'),\r\n                tracking: true\r\n            });\r\n\r\n        } else {\r\n            nativeTrackingFeature = new ol.Feature({\r\n                geometry: new ol.geom.LineString([], 'XYZM'),\r\n                tracking: true\r\n            });\r\n        }\r\n\r\n        if (nativeTrackingFeature) {\r\n\r\n            TC.wrap.Feature.createFeature(nativeTrackingFeature).then(function (tcFeature) {\r\n                self.parent.layerTracking.addFeature(tcFeature);\r\n\r\n                if (tcFeature.geometry.length > 1) {\r\n                    self.parent.map.zoomToFeatures(self.parent.layerTracking.features);\r\n                }\r\n\r\n                if (sessionwaypoint.length > 0) {\r\n                    Promise.all(sessionwaypoint.map(function (waypoint) {\r\n                        return TC.wrap.Feature.createFeature(waypoint);\r\n                    })).then(function (features) {\r\n                        if (features) {\r\n                            features.forEach(function (feature) {\r\n                                self.parent.layerTracking.addFeature(feature);\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n\r\n                self.parent.currentPositionWaiting = self.parent.getLoadingIndicator().addWait();\r\n\r\n                if (!self.currentPositionTrk) {\r\n                    self.currentPositionTrk = [];\r\n                }\r\n\r\n                var getCurrentPositionInterval;\r\n                var getCurrentPositionRequest = 0;\r\n                var errorTimeout = 0;\r\n                var toast = false;\r\n                var options = {\r\n                    enableHighAccuracy: true, timeout: 600000\r\n                };\r\n\r\n                function getCurrentPosition(errorCallback) {\r\n                    var id = getCurrentPositionRequest++;\r\n                    navigator.geolocation.getCurrentPosition(\r\n                        function (data) {\r\n                            clearInterval(getCurrentPositionInterval);\r\n                            self.parent.getLoadingIndicator().removeWait(self.parent.currentPositionWaiting);\r\n                            self.positionChangehandler(data).then(function (obj) {\r\n                                if (self.parent.geopositionTracking == true && obj && obj.marker && obj.accuracy) {\r\n                                    self.currentPositionTrk.push(navigator.geolocation.watchPosition(self.positionChangehandler.bind(self), self.parent.onGeolocateError.bind(self.parent), options));\r\n                                }\r\n                            });\r\n                        },\r\n                        errorCallback ? errorCallback :\r\n                            function (error) {\r\n                                switch (error.code) {\r\n                                    case error.TIMEOUT:\r\n                                        if (errorTimeout > 10) {\r\n                                            clearInterval(getCurrentPositionInterval);\r\n                                            self.parent.onGeolocateError.call(self.parent, error);\r\n                                        } else {\r\n                                            errorTimeout++;\r\n                                            getCurrentPosition(function () {\r\n                                                clearInterval(getCurrentPositionInterval);\r\n                                                if (!toast) {\r\n                                                    toast = true;\r\n                                                    self.parent.onGeolocateError.call(self.parent, error);\r\n                                                }\r\n                                            });\r\n                                        }\r\n                                        break;\r\n                                    default:\r\n                                        clearInterval(getCurrentPositionInterval);\r\n                                        self.parent.onGeolocateError.call(self.parent, error);\r\n                                }\r\n                            }, {\r\n                        timeout: 5000 + id,\r\n                        maximumAge: 10,\r\n                        enableHighAccuracy: true\r\n                    }\r\n                    );\r\n                }\r\n                getCurrentPositionInterval = setInterval(getCurrentPosition, 1000);\r\n\r\n                setTimeout(function () {\r\n                    if (self.parent.layerTracking && self.parent.layerTracking.features && self.parent.layerTracking.features.length > 0 && self.parent.layerTracking.features[0].geometry.length == 0) {\r\n                        clearInterval(getCurrentPositionInterval);\r\n\r\n                        self.parent.getLoadingIndicator().removeWait(self.parent.currentPositionWaiting);\r\n                        self.map.toast(self.parent.getLocaleString(\"geo.error.permission_denied\"), {\r\n                            type: TC.Consts.msgType.WARNING\r\n                        });\r\n                        self.parent.track.activateButton.classList.remove(TC.Consts.classes.HIDDEN);\r\n                        self.parent.track.deactivateButton.classList.add(TC.Consts.classes.HIDDEN);\r\n                    }\r\n                }, options.timeout + 1000); // Wait extra second\r\n\r\n            });\r\n        }\r\n    } else {\r\n        self.parent.firstPosition = false;\r\n\r\n        if (self.currentPositionTrk) {\r\n            self.currentPositionTrk = self.currentPositionTrk instanceof Array ? self.currentPositionTrk : [self.currentPositionTrk];\r\n\r\n            self.currentPositionTrk.forEach(function (watch) {\r\n                navigator.geolocation.clearWatch(watch);\r\n            });\r\n\r\n            self.currentPositionTrk = [];\r\n        }\r\n\r\n        if (self.parent.trackCenterButton)\r\n            self.parent.trackCenterButton.classList.add(TC.Consts.classes.HIDDEN);\r\n    }\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.activateSnapping = function () {\r\n    var self = this;\r\n\r\n    if (!TC.Util.detectMobile()) {\r\n        self.olMap.on([POINTERMOVE, SINGLECLICK], self._snapTrigger);\r\n        self.parent.layerTrack.wrap.layer.on(POSTRENDER, self._postrenderTrigger);\r\n    }\r\n};\r\nTC.wrap.control.Geolocation.prototype.deactivateSnapping = function () {\r\n    var self = this;\r\n\r\n    self.parent.map.wrap.getMap().then(function (olMap) {\r\n        if (!TC.Util.detectMobile()) {\r\n            olMap.un([POINTERMOVE, SINGLECLICK], self._snapTrigger);\r\n            self.parent.layerTrack.wrap.layer.un(POSTRENDER, self._postrenderTrigger);\r\n        }\r\n\r\n        if (self.snapInfo) {\r\n            olMap.removeOverlay(self.snapInfo);\r\n        }\r\n\r\n        if (self.snapInfoElement) {\r\n            self.snapInfoElement.style.display = 'none';\r\n        }\r\n\r\n        if (self.snapLine) {\r\n            delete self.snapLine;\r\n            olMap.render();\r\n        }\r\n    });\r\n};\r\nTC.wrap.control.Geolocation.prototype.clear = function (layer) {\r\n    var self = this;\r\n\r\n    if (layer) {\r\n        layer.clearFeatures();\r\n    }\r\n\r\n    self.deactivateSnapping.call(self);\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.duringTrackSnap = function (e) {\r\n    var self = this;\r\n\r\n    const vectorContext = ol.render.getVectorContext(e);\r\n\r\n    if (vectorContext && self.snapLine) {\r\n        if (typeof vectorContext.setFillStrokeStyle === 'function') {\r\n            vectorContext.setFillStrokeStyle(null, new ol.style.Stroke({\r\n                color: 'rgba(197, 39, 55, 1)',\r\n                width: 1\r\n            }));\r\n        }\r\n\r\n        if (typeof vectorContext.drawGeometry === 'function') {\r\n            vectorContext.drawGeometry(self.snapLine.wrap.feature.getGeometry());\r\n        }\r\n    }\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.endSnap = function () {\r\n    var self = this;\r\n\r\n    self.parent.map.wrap.getMap().then(function (olMap) {\r\n        /* cartel */\r\n        if (self.snapInfo) {\r\n            olMap.removeOverlay(self.snapInfo);\r\n        }\r\n        if (self.snapInfoElement) {\r\n            self.snapInfoElement.style.display = 'none';\r\n        }\r\n        /* línea */\r\n        if (self.snapLine) {\r\n            delete self.snapLine;\r\n        }\r\n    });\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.initSnap = function (coordinate, eventPixel) {\r\n    var self = this;\r\n\r\n    if (self.parent.layerTrack) {\r\n        var vectorSource = self.parent.layerTrack.wrap.layer.getSource();\r\n        var closestFeature = vectorSource.getClosestFeatureToCoordinate(coordinate);\r\n\r\n        if (closestFeature !== null) {\r\n            var geometry = closestFeature.getGeometry();\r\n            var closestPoint = geometry.getClosestPoint(coordinate);\r\n\r\n            // preparamos las Z del MDT si hay datos del MDT\r\n            if (self.parent.elevationChartData &&\r\n                Array.isArray(self.parent.elevationChartData.secondaryElevationProfileChartData) &&\r\n                self.parent.elevationChartData.secondaryElevationProfileChartData.length > 0 &&\r\n                self.parent.elevationChartData.secondaryElevationProfileChartData[0]) {\r\n                let profileChartData = self.parent.elevationChartData.secondaryElevationProfileChartData[0];\r\n                if (Object.prototype.hasOwnProperty.call(profileChartData, \"ele\") &&\r\n                    Array.isArray(profileChartData.ele) &&\r\n                    !Object.prototype.hasOwnProperty.call(profileChartData, \"eleCoordinates\")) {\r\n                    let coords = [...closestFeature.getGeometry().getCoordinates()];\r\n\r\n                    if (Array.isArray(coords) && Array.isArray(coords[0])) {\r\n                        coords.forEach((c, i) => {\r\n                            c.splice(2, 1, self.parent.elevationChartData.secondaryElevationProfileChartData[0].ele[i]);\r\n                        });\r\n\r\n                        self.parent.elevationChartData.secondaryElevationProfileChartData[0].eleCoordinates = coords;\r\n                    }\r\n                }\r\n            }\r\n\r\n            const pixel = self.parent.map.getPixelFromCoordinate(closestPoint);\r\n            const distance = Math.sqrt(\r\n                Math.pow(eventPixel[0] - pixel[0], 2) +\r\n                Math.pow(eventPixel[1] - pixel[1], 2));\r\n\r\n            if (distance > self.parent.snappingTolerance) {\r\n                self.endSnap();\r\n            } else {\r\n                var coordinates = [coordinate, [closestPoint[0], closestPoint[1]]];\r\n\r\n                if (!self.snapLine) self.snapLine = new TC.feature.Polyline(coordinates, {});\r\n                else self.snapLine.wrap.feature.getGeometry().setCoordinates(coordinates);\r\n\r\n                // información del punto\r\n                if (!self.snapInfoElement)\r\n                    self.snapInfoElement = document.getElementsByClassName('tc-ctl-geolocation-track-snap-info')[0];\r\n\r\n                self.snapInfoElement.style.display = 'block';\r\n\r\n                if (!self.snapInfo) {\r\n                    self.snapInfo = new ol.Overlay({\r\n                        element: self.snapInfoElement,\r\n                        offset: [5, 18]\r\n                    });\r\n\r\n                    self.olMap.addOverlay(self.snapInfo);\r\n                }\r\n\r\n                if (self.snapInfo.getMap() == undefined)\r\n                    self.snapInfo.setMap(self.olMap);\r\n\r\n                self.snapInfo.setPosition(coordinate);\r\n\r\n                var data = {};\r\n                if (closestFeature.getGeometry().getType() != \"LineString\") {\r\n                    if (closestFeature.getKeys().indexOf('name') > -1)\r\n                        data.n = closestFeature.get('name');\r\n                }\r\n\r\n                var locale = self.parent.map.options.locale && self.parent.map.options.locale.replace('_', '-') || undefined;\r\n                data.x = self.map.wrap.isGeo() ? closestPoint[0].toLocaleString(locale, { minimumFractionDigits: 5 }) : Math.round(closestPoint[0]).toLocaleString(locale);\r\n                data.y = self.map.wrap.isGeo() ? closestPoint[1].toLocaleString(locale, { minimumFractionDigits: 5 }) : Math.round(closestPoint[1]).toLocaleString(locale);\r\n\r\n                if (self.map.wrap.isGeo()) {\r\n                    data.isGeo = true;\r\n                }\r\n\r\n                var getZ = function (position) {\r\n                    return closestPoint[position] ? (Math.round(closestPoint[position] * 100) / 100).toLocaleString(locale) : undefined;\r\n                };\r\n                var getM = function (position) {\r\n                    return closestPoint[position] > 0 ? new Date(closestPoint[position]).toLocaleString(locale) : undefined;\r\n                };\r\n\r\n                if (closestFeature.getGeometry().getLayout() === ol.geom.GeometryLayout.XYZM) {\r\n                    data.z = getZ(2);\r\n                    data.m = getM(3);\r\n                } else if (closestFeature.getGeometry().getLayout() === ol.geom.GeometryLayout.XYZ) {\r\n                    data.z = getZ(2);\r\n                } else if (closestFeature.getGeometry().getLayout() === ol.geom.GeometryLayout.XYM) {\r\n                    data.m = getM(2);\r\n                }\r\n\r\n                if (data) {\r\n                    // Z del MDT si hay datos del MDT\r\n                    if (self.parent.elevationChartData && self.parent.elevationChartData.secondaryElevationProfileChartData[0] &&\r\n                        self.parent.elevationChartData.secondaryElevationProfileChartData[0].eleCoordinates) {\r\n                        let mdtClosestPoint = TC.wrap.Geometry.getNearest(coordinate, self.parent.elevationChartData.secondaryElevationProfileChartData[0].eleCoordinates);\r\n                        let mdtZ = (Math.round(mdtClosestPoint[2] * 100) / 100).toLocaleString(locale);\r\n                        data.mdtz = mdtZ;\r\n                    }\r\n\r\n                    self.parent.getRenderedHtml(self.parent.CLASS + '-track-snapping-node', data, function (html) {\r\n                        self.snapInfoElement.innerHTML = html;\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    self.olMap.render();\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.drawTrackingData = function (track) {\r\n    const self = this;\r\n\r\n    return new Promise(function (resolve, _reject) {\r\n        const featurePromises = [];\r\n\r\n        const JSONParser = new TC.wrap.parser.JSON();\r\n        const features = JSONParser.parser.readFeatures(track.data);\r\n\r\n        features.filter(function (feature) {\r\n            return feature.getGeometry().getType().toLowerCase() === 'linestring' || feature.getGeometry().getType().toLowerCase() === 'multilinestring';\r\n        }).forEach(function (feature) {\r\n            feature.getGeometry().setCoordinates(feature.getGeometry().getCoordinates(), track.layout);\r\n        });\r\n\r\n        self.activateSnapping.call(self);\r\n\r\n        for (var i = 0, len = features.length; i < len; i++) {\r\n            featurePromises.push(TC.wrap.Feature.createFeature(features[i]));\r\n        }\r\n\r\n        Promise.all(featurePromises).then(function (feats) {\r\n            feats.forEach(function (feat) {\r\n                if (feat) {\r\n                    self.parent.layerTrack.addFeature(feat);\r\n                }\r\n            });\r\n            if (!self.parent.toShare || self.parent.toShare && self.parent.toShare.doZoom) {\r\n                self.parent.map.zoomToFeatures(self.parent.layerTrack.features);\r\n            }\r\n\r\n            resolve();\r\n        });\r\n    });\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.formattedFromStorage = function (storageData) {\r\n    const self = this;\r\n\r\n    if (self.parent.storageCRS !== self.parent.map.crs) {\r\n        var features = new ol.format.GeoJSON().readFeatures(storageData);\r\n        if (features) {\r\n            features = features.map(function (feature) {\r\n                var clone = feature.clone();\r\n                clone.getGeometry().transform(self.parent.storageCRS, self.parent.map.crs);\r\n                clone.setId(feature.getId());\r\n                return clone;\r\n            });\r\n\r\n            return new ol.format.GeoJSON().writeFeatures(features);\r\n        }\r\n    }\r\n\r\n    return storageData;\r\n};\r\nTC.wrap.control.Geolocation.prototype.formattedToStorage = function (layer, removeTrackingProperty, notReproject) {\r\n    var self = this;\r\n\r\n    var parser = new TC.wrap.parser.JSON();\r\n    parser = parser.parser;\r\n\r\n    var features = layer.wrap.layer.getSource().getFeatures();\r\n    var layout;\r\n\r\n    features = features.map(function (feature) {\r\n        if (feature.getGeometry() instanceof ol.geom.LineString) {\r\n            layout = feature.getGeometry().getLayout();\r\n        }\r\n\r\n        if (removeTrackingProperty && feature.getProperties().tracking) {\r\n            feature.unset(\"tracking\");\r\n        }\r\n\r\n        if (!notReproject && self.parent.map.crs !== self.parent.storageCRS) {\r\n            var clone = feature.clone();\r\n            clone.getGeometry().transform(self.parent.map.crs, self.parent.storageCRS);\r\n            clone.setId(feature.getId());\r\n\r\n            return clone;\r\n        }\r\n\r\n        return feature;\r\n    }).sort(function (a, b) {\r\n\r\n        if (a.getGeometry() instanceof ol.geom.Point &&\r\n            !(b.getGeometry() instanceof ol.geom.Point)) {\r\n            return -1;\r\n        }\r\n\r\n        if (b.getGeometry() instanceof ol.geom.Point &&\r\n            !(a.getGeometry() instanceof ol.geom.Point)) {\r\n            return 2;\r\n        }\r\n\r\n        if (a.getProperties().name < b.getProperties().name) { return -1; }\r\n        if (a.getProperties().name > b.getProperties().name) { return 1; }\r\n\r\n        return 0;\r\n    });\r\n\r\n    return {\r\n        features: parser.writeFeatures(features), layout: layout\r\n    };\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.export = function (li) {\r\n    const self = this;\r\n    return new Promise(function (resolve, reject) {\r\n\r\n        self.parent.getTrackingData(li).then(function (data) {\r\n            if (data) {\r\n\r\n                var olFeatures = new ol.format.GeoJSON().readFeatures(data.data);\r\n\r\n                if (olFeatures.length === 0) {\r\n                    var geoJSON = self.parent.getTrackingData(li);\r\n                    olFeatures = new ol.format.GeoJSON().readFeatures(geoJSON);\r\n                }\r\n\r\n                Promise.all(olFeatures.map(function (feature) {\r\n                    return TC.wrap.Feature.createFeature(feature);\r\n                })).then((features) => {\r\n                    resolve(features);\r\n                });\r\n            } else {\r\n                reject();\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\nvar segmentsUnion = function (lineStrings) {\r\n    var mergedIndex = [];\r\n    var coords = [];\r\n    if (lineStrings.length > 1) {\r\n\r\n        if (lineStrings[0].length === 4) {\r\n            lineStrings = lineStrings.sort(function (a, b) {\r\n                if (a[0][3] == b[0][3])\r\n                    return 0;\r\n                else if (a[0][3] < b[0][3])\r\n                    return -1;\r\n                else return 1;\r\n            });\r\n        }\r\n\r\n        for (var ls = 0; ls < lineStrings.length; ls++) {\r\n            var lineString = lineStrings[ls];\r\n            var nextLineIndex = -1;\r\n            var distance = Infinity;\r\n\r\n            var last = lineString.getLastCoordinate();\r\n            for (var nls = ls + 1; nls < lineStrings.length; nls++) {\r\n                var first = lineStrings[nls].getFirstCoordinate();\r\n                var d = Math.hypot(last[0] - first[0], last[1] - first[1]);\r\n                if (d < distance) {\r\n                    nextLineIndex = nls;\r\n                    distance = d;\r\n                }\r\n            }\r\n\r\n            if (mergedIndex.length < lineStrings.length) {\r\n                if (mergedIndex.indexOf(ls) === -1) {\r\n                    mergedIndex.push(ls);\r\n                    coords = coords.concat(lineString.getCoordinates());\r\n                }\r\n                if (mergedIndex.indexOf(nextLineIndex) === -1) {\r\n                    mergedIndex.push(nextLineIndex);\r\n                    coords = coords.concat(lineStrings[nextLineIndex].getCoordinates());\r\n                }\r\n            }\r\n        }\r\n\r\n        //self.map.toast(self.parent.getLocaleString(\"geo.trk.simulateWarning\"), { type: TC.Consts.msgType.WARNING });\r\n\r\n        return coords;\r\n    }\r\n\r\n    return lineStrings[0].getCoordinates();\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.processImportedFeatures = function (options) {\r\n    var self = this;\r\n\r\n    var source = self.parent.layerTrack.wrap.layer.getSource();\r\n    var fileName = self.parent.importedFileName;\r\n    var names = [];\r\n    var toAdd = [];\r\n    var toRemove = [];\r\n    var maybeRemove = [];\r\n    var features = source.getFeatures();\r\n\r\n    var segments = [];\r\n    var coord = [];\r\n\r\n    var getName = function (feature) {\r\n        const properties = feature.getProperties();\r\n        if (Object.prototype.hasOwnProperty.call(properties, \"name\")) {\r\n            if (properties.name.trim().length > 0) {\r\n                names.push(properties.name);\r\n            }\r\n            else {\r\n                names.push(fileName);\r\n            }\r\n        }\r\n        else {\r\n            names.push(fileName);\r\n        }\r\n    };\r\n\r\n    for (var f = 0; f < features.length; f++) {\r\n        var feature = features[f];\r\n\r\n        if (feature instanceof TC.Feature)\r\n            feature = features[f].wrap.feature;\r\n\r\n        if (feature.getGeometry() instanceof ol.geom.Point) {\r\n            coord.push(feature.getGeometry().getCoordinates());\r\n            maybeRemove.push(feature);\r\n        }\r\n        else if (feature.getGeometry() instanceof ol.geom.LineString) {\r\n            // GLS: 31/01/2018 Routes (<rte>) are converted into LineString geometries, and tracks (<trk>) into MultiLineString, por tanto, las líneas las cargamos como N Rutas, no las unimos como hasta ahora: // segments.push(feature.getGeometry());                \r\n            getName(feature);\r\n            const newFeature = new ol.Feature({\r\n                geometry: new ol.geom.LineString(feature.getGeometry().getCoordinates(), feature.getGeometry().getLayout())\r\n            });\r\n            newFeature.setId(feature.getId() || TC.getUID());\r\n            toAdd.push(newFeature);\r\n            toRemove.push(feature);\r\n        }\r\n        else if (feature.getGeometry() instanceof ol.geom.MultiLineString) {\r\n            var clone = feature.clone();\r\n            getName(clone);\r\n\r\n            var ls = clone.getGeometry().getLineStrings();\r\n\r\n            const coords = segmentsUnion(ls);\r\n            const newFeature = new ol.Feature({\r\n                geometry: new ol.geom.LineString(coords, feature.getGeometry().getLayout())\r\n            });\r\n            newFeature.setId(feature.getId() || TC.getUID());\r\n            toAdd.push(newFeature);\r\n            toRemove.push(feature);\r\n        }\r\n    }\r\n\r\n    if (segments.length > 0) {\r\n        const coords = segmentsUnion(segments);\r\n        toAdd.push(new ol.Feature({\r\n            geometry: new ol.geom.LineString(coords)\r\n        }));\r\n    }\r\n\r\n    if (coord.length > 0 && maybeRemove.length == features.length) {\r\n        toAdd.push(new ol.Feature({\r\n            geometry: new ol.geom.LineString(coord)\r\n        }));\r\n    }\r\n\r\n    if (toRemove.length > 0) {\r\n        for (var i = 0; i < toRemove.length; i++) {\r\n            source.removeFeature(toRemove[i]);\r\n        }\r\n    }\r\n\r\n    if (toAdd.length > 0) {\r\n        var sameName = function (array, element) {\r\n            var indices = [];\r\n            var idx = array.indexOf(element);\r\n            while (idx !== -1) {\r\n                indices.push(idx);\r\n                idx = array.indexOf(element, idx + 1);\r\n\r\n                if (indices.length > 1)\r\n                    return true;\r\n            }\r\n\r\n            return indices.length > 1 ? true : false;\r\n        };\r\n\r\n        var featureToAdd;\r\n        var index = 0;\r\n        var processAdd = function () {\r\n            const promises = toAdd.map(function (_ta, idx) {\r\n                return new Promise(function (resolve, _reject) {\r\n                    if (featureToAdd) {\r\n                        source.removeFeature(featureToAdd);\r\n                    }\r\n\r\n                    var name;\r\n                    if (names.length > idx) {\r\n                        name = names[idx];\r\n                        if (sameName(names, name)) {\r\n                            name = '[' + (idx + 1) + ']' + ' ' + name;\r\n                        }\r\n                    }\r\n\r\n                    self.parent.importedFileName = name ? name : fileName;\r\n\r\n                    featureToAdd = toAdd[idx];\r\n                    source.addFeature(featureToAdd);\r\n\r\n                    self.parent.saveTrack({\r\n                        message: self.parent.getLocaleString('geo.trk.upload.ok', { trackName: name ? name : fileName }),\r\n                        importedFileName: name ? name : fileName,\r\n                        notReproject: options.notReproject,\r\n                        fileHandle: options.fileHandle\r\n                    }).then(function (importedIndex) {\r\n                        if (idx === 0) {\r\n                            index = importedIndex;\r\n                        }\r\n                        resolve();\r\n                    });\r\n                });\r\n            });\r\n            return Promise.all(promises);\r\n        };\r\n        processAdd().then(function () {\r\n\r\n            self.parent.layerTrack.setVisibility(false);\r\n            // la siguiente instrucción hace que se elimine del array de ids la línea y después no funciona la descarga de la feature.\r\n            // 13/11/2020 recupero la instrucción: sin el borrado de features al compartir un track se queda la importada en 4326 y \r\n            // la nueva ya gestionada, con lo que el zoom a la feature no funciona como debe. Después de todos los cambios en la gestión de \r\n            // IDs de las features de los track no he conseguido reproducir el problema del anterior comentario.\r\n            self.parent.layerTrack.clearFeatures();\r\n\r\n            self.parent.trigger(self.parent.Const.Event.IMPORTEDTRACK, { index: index });\r\n\r\n            delete self.parent.importedFileName;\r\n            self.parent.getLoadingIndicator().removeWait(options.wait);\r\n        });\r\n    } else {\r\n\r\n        if (self.parent.layerTrack) {\r\n            self.parent.map.removeLayer(self.parent.layerTrack);\r\n            self.parent.layerTrack = undefined;\r\n        }\r\n\r\n        delete self.parent.importedFileName;\r\n        self.parent.getLoadingIndicator().removeWait(options.wait);\r\n        TC.alert(self.parent.getLocaleString(\"geo.trk.upload.error4\"));\r\n    }\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.import = function (wait, data, type) {\r\n    var self = this;\r\n    var vectorSource;\r\n    var listenerKey;\r\n\r\n    if (data && data.text) {\r\n\r\n        var layerOptions = self.parent.layerTrack.wrap.createVectorSource({\r\n            data: data.text,\r\n            type: type\r\n        });\r\n        vectorSource = layerOptions.source;\r\n\r\n        listenerKey = vectorSource.on('change', function (_e) {\r\n            if (vectorSource.getState() === 'ready') {\r\n                ol.Observable.unByKey(listenerKey);\r\n                self.processImportedFeatures(wait);\r\n            }\r\n        });\r\n\r\n        var olLayer = self.parent.layerTrack.wrap.layer;\r\n        olLayer.setSource(vectorSource);\r\n\r\n    } else {\r\n\r\n        if (self.parent.layerTrack) {\r\n            self.parent.map.removeLayer(self.parent.layerTrack);\r\n            self.parent.layerTrack = undefined;\r\n        }\r\n\r\n        delete self.parent.importedFileName;\r\n        self.parent.getLoadingIndicator().removeWait(wait);\r\n        TC.alert(self.parent.getLocaleString(\"geo.trk.upload.error4\"));\r\n    }\r\n};\r\n\r\nvar idRequestAnimationFrame;\r\nTC.wrap.control.Geolocation.prototype.simulateTrackEnd = function (resized) {\r\n    var self = this;\r\n\r\n    if (!resized) {\r\n        // revertimos: establecemos a false para que no muestra el progreso en el perfil ya que siempre será elevación 0\r\n        self.hasElevation = true;\r\n    }\r\n\r\n    self.parent.chartProgressClear();\r\n\r\n    if (self.simulateMarker) {\r\n        window.cancelAnimationFrame(idRequestAnimationFrame);\r\n        if (self.simulateMarker.layer.wrap.layer.getSource().getFeatures().length > 0)\r\n            self.simulateMarker.layer.removeFeature(self.simulateMarker);\r\n\r\n        delete self.simulateMarker;\r\n    }\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.simulateTrack = function () {\r\n    var self = this;\r\n\r\n    var coordinates;\r\n    var features = self.parent.layerTrack.wrap.layer.getSource().getFeatures();\r\n    for (var ls = 0; ls < features.length; ls++) {\r\n        if (features[ls].getGeometry() instanceof ol.geom.LineString) {\r\n            coordinates = features[ls].getGeometry().getCoordinates();\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (coordinates && coordinates.length > 0) {\r\n        var first = coordinates[0];\r\n\r\n        var setSimulateMarker = function () {\r\n            return new Promise(function (resolve, _reject) {\r\n                if (!self.simulateMarker) {\r\n                    self.parent.layerTrack.addPoint(first.slice(0, 2), {\r\n                        radius: 7,\r\n                        fillColor: '#ff0000',\r\n                        fillOpacity: 0.5,\r\n                        strokeColor: '#ffffff',\r\n                        strokeWidth: 2\r\n                    }).then(function (f) {\r\n                        resolve(f);\r\n                    });\r\n                } else {\r\n                    self.simulateMarker.setCoords(first.slice(0, 2));\r\n                    resolve(self.simulateMarker);\r\n                }\r\n            });\r\n        };\r\n        setSimulateMarker().then(function (f) {\r\n            self.simulateMarker = f;\r\n\r\n            var animationFrameFraction = function () {\r\n                var start;\r\n                var fraction;\r\n                var hasTime = false;\r\n\r\n                const toLength = function (coords) {\r\n                    if (self.parent.map.crs !== self.parent.map.options.utmCrs) {\r\n                        return TC.Util.reproject(coords, self.parent.map.crs, self.parent.map.options.utmCrs);\r\n                    }\r\n\r\n                    return coords;\r\n                };\r\n\r\n                var arCoordinates = coordinates;\r\n                if (arCoordinates[0].length === 4 && arCoordinates[0][3] > 0) {\r\n                    start = arCoordinates[0][3];\r\n                    hasTime = true;\r\n                } else {\r\n                    arCoordinates[0][3] = Date.now();\r\n\r\n                    for (var i = 1; i < arCoordinates.length; i++) {\r\n                        let done;\r\n                        arCoordinates[i][3] = 0;\r\n\r\n                        if (i + 1 < arCoordinates.length) {\r\n                            done = new ol.geom.LineString(toLength(arCoordinates.slice(i - 1, i + 1))).getLength();\r\n                        } else {\r\n                            done = new ol.geom.LineString(toLength(arCoordinates.slice(i - 1))).getLength();\r\n                        }\r\n\r\n                        arCoordinates[i][3] = arCoordinates[i - 1][3] + 3600000 * done / self.parent.walkingSpeed;\r\n                    }\r\n\r\n                    start = arCoordinates[0][3];\r\n                }\r\n\r\n                var trackFilm = new ol.geom.LineString(arCoordinates);\r\n                var timestamp = start;\r\n                var distance = 0;\r\n\r\n                if (self.parent.map.crs !== self.parent.map.options.utmCrs) {\r\n                    distance = new ol.geom.LineString(toLength(JSON.parse(JSON.stringify(arCoordinates)))).getLength();\r\n                } else {\r\n                    distance = trackFilm.getLength();\r\n                }\r\n\r\n                var getDoneAtM = function (m) {\r\n                    for (var i = 0; i < arCoordinates.length; i++) {\r\n                        if (arCoordinates[i][3] > m)\r\n                            return {\r\n                                d: new ol.geom.LineString(toLength(arCoordinates.slice(0, i))).getLength(),\r\n                                p: arCoordinates[i - 1].slice(0, 2)\r\n                            };\r\n                    }\r\n                };\r\n\r\n                var loopAtFraction = function () {\r\n\r\n                    if (!self.parent.simulate_paused) {\r\n                        var position = trackFilm.getCoordinateAtM(timestamp);\r\n                        var d = getDoneAtM(timestamp);\r\n\r\n                        if (fraction >= 1 || !position || !d) {\r\n                            var li = self.parent.getSelectedTrack();\r\n                            if (li)\r\n                                self.parent.uiSimulate(false, li);\r\n\r\n                            if (self.parent.hasElevation) {\r\n                                self.parent.chartProgressClear();\r\n                            }\r\n\r\n                            self.simulateTrackEnd();\r\n\r\n                            return;\r\n                        } else {\r\n\r\n                            if (self.parent.hasElevation) {\r\n                                self.parent.chartSetProgress(d, position, distance, hasTime ? self.parent._getTime(arCoordinates[0][3], position[3]) : false);\r\n                            }\r\n\r\n                            if (self.simulateMarker) {\r\n                                //var from = self.simulateMarker.getCoords();\r\n                                //var to = position;\r\n                                //var rotation = Math.atan2(to[1] - from[1], to[0] - from[0]) * 180 / Math.PI;\r\n\r\n                                self.simulateMarker.setCoords(position);\r\n                                //self.simulateMarker.setStyle({ angle: rotation });\r\n                            }\r\n\r\n                            if (self.parent.simulate_speed !== 1) {\r\n                                timestamp = timestamp + self.parent.delta * self.parent.simulate_speed;\r\n                            }\r\n                            else {\r\n                                timestamp = timestamp + self.parent.delta;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    idRequestAnimationFrame = requestAnimationFrame(loopAtFraction);\r\n                };\r\n                idRequestAnimationFrame = requestAnimationFrame(loopAtFraction);\r\n\r\n            };\r\n\r\n            const hasD3 = new Promise(function (resolve, _reject) {\r\n                if (window.d3) {\r\n                    resolve();\r\n                }\r\n                else {\r\n                    TC.loadJS(!window.d3, [TC.Consts.url.D3C3], function () {\r\n                        resolve();\r\n                    });\r\n                }\r\n            });\r\n            hasD3.then(function () {\r\n                idRequestAnimationFrame = requestAnimationFrame(animationFrameFraction);\r\n            });\r\n        });\r\n    }\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.headingChangehandler = function (evt) {\r\n    var self = this;\r\n    if (!self.parent.track.infoOnMap) {\r\n        self.parent.track.infoOnMap = document.createElement('div');\r\n        const iomStyle = self.parent.track.infoOnMap.style;\r\n        iomStyle.overFlowY = 'scroll';\r\n        iomStyle.height = '200px';\r\n        iomStyle.width = '200px';\r\n        iomStyle.top = '0';\r\n        iomStyle.left = '100px';\r\n        iomStyle.backgroundColor = 'fuchsia';\r\n        iomStyle.position = 'absolute';\r\n        self.parent.map.div.appendChild(self.parent.track.infoOnMap);\r\n    }\r\n\r\n    self.parent.track.infoOnMap.style.display = '';\r\n\r\n    self.heading = evt.target.getHeading();\r\n\r\n    self.parent.track.infoOnMap.innerHTML = self.parent.track.infoOnMap.innerHTML +\r\n        '<br> <p> salta headingChangehandler </p> <br> <p> evt.target.getHeading(): ' + self.heading + ' </p>';\r\n\r\n\r\n\r\n    self.map.wrap.getMap().then(function (map) {\r\n        map.getView().setRotation(-self.heading);\r\n    });\r\n\r\n    self.parent.trigger(self.parent.Const.Event.STATEUPDATED, {\r\n        moving: (self.heading != undefined && self.heading > 0)\r\n    });\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.orientationChangehandler = function (event) {\r\n    var self = this;\r\n\r\n    var view = self.map.wrap.map.getView();\r\n    var center = view.getCenter();\r\n    var resolution = view.getResolution();\r\n    var beta = event.target.getBeta() || 0;\r\n    var gamma = event.target.getGamma() || 0;\r\n\r\n    center[0] -= resolution * gamma * 25;\r\n    center[1] += resolution * beta * 25;\r\n\r\n    view.setCenter(view.constrainCenter(center));\r\n\r\n    self.parent.trigger(self.parent.Const.Event.STATEUPDATED, {\r\n        moving: (self.heading != undefined && self.heading > 0)\r\n    });\r\n};\r\n\r\nTC.wrap.control.Geolocation.prototype.pulsate = function (circle) {\r\n    var self = this;\r\n\r\n    self.pulsated = true;\r\n\r\n    var radius = circle.wrap.feature.getGeometry().getRadius();\r\n    var start = new Date().getTime();\r\n\r\n    var duration = 500;\r\n    var listenerKey;\r\n\r\n    var getRadius = function (elapsed) {\r\n        switch (true) {\r\n            case elapsed <= 50:\r\n                return radius;\r\n            case elapsed > 50 && elapsed <= 100:\r\n                return radius * 1.02;\r\n            case elapsed > 100 && elapsed <= 150:\r\n                return radius * 1.05;\r\n            case elapsed > 150 && elapsed <= 200:\r\n                return radius * 1.02;\r\n            case elapsed > 200 && elapsed <= 300:\r\n                return radius;\r\n            case elapsed > 300 && elapsed <= 350:\r\n                return radius * 1.02;\r\n            case elapsed > 350 && elapsed <= 400:\r\n                return radius * 1.05;\r\n            case elapsed > 400 && elapsed <= 450:\r\n                return radius * 1.02;\r\n            case elapsed > 450 && elapsed <= 500:\r\n                return radius * 1;\r\n            default:\r\n                return radius;\r\n        }\r\n    };\r\n    listenerKey = self.olMap.on(POSTRENDER, function (event) {\r\n        var vectorContext = event.vectorContext;\r\n        var frameState = event.frameState;\r\n\r\n        var elapsed = frameState.time - start;\r\n\r\n        var f = circle.wrap.feature.getGeometry().clone();\r\n        var r = getRadius(elapsed);\r\n        f.setRadius(r);\r\n\r\n        vectorContext.setFillStrokeStyle(\r\n            new ol.style.Fill({\r\n                color: 'rgba(0, 0, 0, 0.1)'\r\n            }),\r\n            new ol.style.Stroke({\r\n                color: 'rgba(255, 0, 0, .8)', width: 1\r\n            })\r\n        );\r\n        vectorContext.drawCircleGeometry(f);\r\n\r\n        if (elapsed > duration) {\r\n            ol.Observable.unByKey(listenerKey);\r\n            return;\r\n        }\r\n\r\n        frameState.animate = true;\r\n    });\r\n};\r\n\r\nTC.wrap.control.ResultsPanel.prototype.register = function (map) {\r\n    const self = this;\r\n    self.map = map;\r\n\r\n    map.wrap.getMap().then(function (olMap) {\r\n        self.olMap = olMap;\r\n    });\r\n};\r\n\r\nTC.wrap.control.ResultsPanel.prototype.showElevationMarker = function (options) {\r\n    const self = this;\r\n    options = options || {};\r\n    const data = options.data;\r\n    const layer = options.layer;\r\n    const coords = options.coords;\r\n\r\n    if (!self.elevationMarker) {\r\n        const elm = document.createElement('div');\r\n        elm.style.display = 'none';\r\n        elm.classList.add(self.parent.CLASS + '-overlay', 'elevation');\r\n        self.elevationMarker = new ol.Overlay({\r\n            id: 'ovElevationMarker',\r\n            element: elm,\r\n            offset: [0, 0],\r\n            positioning: ol.OverlayPositioning.CENTER_CENTER,\r\n            stopEvent: false\r\n        });\r\n    }\r\n\r\n    // GLS: si la capa del track está visible mostramos marcamos punto del gráfico en el mapa\r\n    if (!layer || layer.getVisibility() && layer.getOpacity() > 0) {\r\n        let position = coords[data[0].index];\r\n        if (self.parent.map.crs !== self.parent.map.options.utmCrs) {\r\n            position = TC.Util.reproject(position, self.map.options.utmCrs, self.map.crs);\r\n        }\r\n        self.elevationMarker.getElement().style.display = '';\r\n        if (!self.olMap.getOverlayById(self.elevationMarker.getId())) {\r\n            self.olMap.addOverlay(self.elevationMarker);\r\n            if (self.map.on3DView) {\r\n                self.map.view3D.addElevationMarker(position, self.parent);\r\n            }\r\n        }\r\n        self.elevationMarker.setPosition(position);\r\n        if (self.map.on3DView) {\r\n            self.map.view3D.setElevationMarker(position, self.parent);\r\n        }\r\n    }\r\n};\r\n\r\nTC.wrap.control.ResultsPanel.prototype.hideElevationMarker = function () {\r\n    const self = this;\r\n    if (self.elevationMarker) {\r\n        self.elevationMarker.getElement().style.display = 'none';\r\n\r\n        if (self.map.on3DView) {\r\n            self.map.view3D.hideElevationMarker(self.parent);\r\n        }\r\n    }\r\n};\r\n\r\nTC.wrap.control.Coordinates.prototype.coordsActivate = function () {\r\n    var self = this;\r\n\r\n    self.olMap.on(CLICK, self._coordsTrigger);\r\n};\r\n\r\nTC.wrap.control.Coordinates.prototype.coordsDeactivate = function () {\r\n    var self = this;\r\n\r\n    self.olMap.un(CLICK, self._coordsTrigger);\r\n};\r\n\r\nTC.wrap.Parser = function () {\r\n};\r\n\r\nTC.wrap.Parser.prototype.read = function (data) {\r\n    var result = [];\r\n    var self = this;\r\n    if (self.parser) {\r\n        result = self.parser.readFeatures(data).map(function (feat) {\r\n            return new TC.Feature(null, {\r\n                id: feat.getId(), data: feat.getProperties()\r\n            });\r\n        });\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.Parser.prototype.readFeatures = function (data) {\r\n    var result = [];\r\n    var self = this;\r\n    if (self.parser) {\r\n        result = self.parser.readFeatures(data).map(function (feat) {\r\n            let coordinates = feat.getGeometry().getCoordinates();\r\n            const featureOptions = {};\r\n            let geometry;\r\n            switch (feat.getGeometry().getType()) {\r\n                case \"LineString\":\r\n                    geometry = new TC.feature.Polyline(coordinates, featureOptions);\r\n                    break;\r\n                case \"Polygon\":\r\n                    geometry = new TC.feature.Polygon(coordinates, featureOptions);\r\n                    break;\r\n                case \"MultiPoint\":\r\n                    geometry = new TC.feature.MultiPoint(coordinates, featureOptions);\r\n                    break;\r\n                case \"MultiLineString\":\r\n                    geometry = new TC.feature.MultiPolyline(coordinates, featureOptions);\r\n                    break;\r\n                case \"MultiPolygon\":\r\n                    geometry = new TC.feature.MultiPolygon(coordinates, featureOptions);\r\n                    break;\r\n                case \"Point\":\r\n                default:\r\n                    geometry = new TC.feature.Point(coordinates, featureOptions);\r\n                    break;\r\n            }\r\n            return geometry;\r\n        });\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.parser = {\r\n    WFS: function (options) {\r\n        this.parser = new ol.format.WFS(options);\r\n    },\r\n    JSON: function (options) {\r\n        this.parser = new ol.format.GeoJSON(options);\r\n    }\r\n};\r\nTC.inherit(TC.wrap.parser.WFS, TC.wrap.Parser);\r\nTC.inherit(TC.wrap.parser.JSON, TC.wrap.Parser);\r\n\r\nTC.wrap.control.OverviewMap.prototype.register = function (map) {\r\n    var self = this;\r\n\r\n    self.parent.layer.wrap.getLayer().then(function setOVMap(olLayer) {\r\n        self.ovMap = new ol.control.OverviewMap({\r\n            target: self.parent.div,\r\n            collapsed: false,\r\n            collapsible: false,\r\n            className: self.parent.CLASS + ' ol-overviewmap',\r\n            layers: [olLayer]\r\n        });\r\n        self.ovMap._wrap = self;\r\n\r\n        /* 08/02/2019 GLS: \r\n            Establecemos el pixelRatio siempre a uno (aunque el control instancie un olMap internamente no admite el paso de la opción pixelRatio,\r\n            imposible de entender, por eso lo hago directamente), porque OL sólo atiende al valor al principio,\r\n            si después se hace zoom in/out del navegador, OL no atiende el cambio lo que provoca que el mapa se vea borroso, click se sitúa mal,\r\n            popup se sitúa entre otros efectos.\r\n            Lo gestionamos nosotros hasta que lo soporten del todo. Relacionado con las tareas/bugs:\r\n                Bug 25976:Mapa situación en blanco\r\n                Bug 25954:Canvas en blanco con zoom mayor al 100%\r\n                Bug 23855:Mapa de situación se muestra en blanco\r\n        */\r\n        self.ovMap.getOverviewMap().pixelRatio_ = 1;\r\n\r\n        // Quitamos el drag&drop añadido en OL 4.1.0 machacando el overlay\r\n        self.ovMap.ovmap_.removeOverlay(self.ovMap.boxOverlay_);\r\n        var box = document.createElement('DIV');\r\n        box.className = 'ol-overviewmap-box';\r\n        box.style.boxSizing = 'border-box';\r\n        self.ovMap.boxOverlay_ = new ol.Overlay({\r\n            position: [0, 0],\r\n            positioning: ol.OverlayPositioning.CENTER_CENTER,\r\n            element: box\r\n        });\r\n        self.ovMap.ovmap_.addOverlay(self.ovMap.boxOverlay_);\r\n\r\n        // mantenemos el ancho y alto del canvas en números enteros\r\n        self.manageSize.call(self.ovMap.ovmap_);\r\n\r\n        self._boxElm = self.ovMap.boxOverlay_.getElement();\r\n\r\n        TC.loadJS(\r\n            !window.Draggabilly,\r\n            [TC.apiLocation + TC.Consts.url.DRAGGABILLY],\r\n            function () {\r\n                var ovmMap = self.ovMap.ovmap_;\r\n                const drag = new Draggabilly(self._boxElm);\r\n                // Parcheamos Draggabilly para que respete las otras transformaciones, por ejemplo rotación.\r\n                drag.positionDrag = function () {\r\n                    const style = this.element.style;\r\n                    const newTransform = 'translate3d( ' + this.dragPoint.x +\r\n                        'px, ' + this.dragPoint.y + 'px, 0)';\r\n                    if (style.transform.length) {\r\n                        const idxStart = style.transform.indexOf('translate3d');\r\n                        if (idxStart >= 0) {\r\n                            const idxEnd = style.transform.indexOf(')', idxStart);\r\n                            style.transform = style.transform.replace(style.transform.substring(idxStart, idxEnd + 1), newTransform);\r\n                        }\r\n                        else {\r\n                            style.transform = newTransform + ' ' + style.transform;\r\n                        }\r\n                    }\r\n                    else {\r\n                        style.transform = newTransform;\r\n                    }\r\n                };\r\n                drag.on('pointerDown', function (_e) {\r\n                    drag.dragged = self._boxElm.cloneNode();\r\n                    drag.dragged.classList.add(TC.Consts.classes.ACTIVE);\r\n                    drag.dragged.style.position = 'absolute';\r\n                    self._boxElm.insertAdjacentElement('beforebegin', drag.dragged);\r\n                    if (map.maxExtent) {\r\n                        var bottomLeft = ovmMap.getPixelFromCoordinate([map.maxExtent[0], map.maxExtent[1]]);\r\n                        var topRight = ovmMap.getPixelFromCoordinate([map.maxExtent[2], map.maxExtent[3]]);\r\n                        var mapSize = ovmMap.getSize();\r\n                        const container = document.createElement('div');\r\n                        container.style.position = 'absolute';\r\n                        container.style.bottom = Math.round(mapSize[1] - bottomLeft[1]) + 'px';\r\n                        container.style.left = Math.round(bottomLeft[0]) + 'px';\r\n                        container.style.top = Math.round(topRight[1]) + 'px';\r\n                        container.style.right = Math.round(mapSize[0] - topRight[0]) + 'px';\r\n                        const viewport = ovmMap.getViewport();\r\n                        viewport.insertBefore(container, viewport.firstElementChild);\r\n                        drag.options.containment = container;\r\n                    }\r\n                });\r\n                drag.on('pointerUp', function (_e) {\r\n                    drag.dragged.parentElement.removeChild(drag.dragged);\r\n                    if (map.maxExtent) {\r\n                        ovmMap.getViewport().removeChild(drag.options.containment);\r\n                        drag.options.containment = null;\r\n                    }\r\n                });\r\n                drag.on('dragMove', function (_e, _pointer, moveVector) {\r\n                    drag._delta = moveVector;\r\n                });\r\n                drag.on('dragEnd', function (_e, _pointer) {\r\n                    var olMap = self.ovMap.getMap();\r\n                    var view = olMap.getView();\r\n                    var centerPixel = ovmMap.getPixelFromCoordinate(view.getCenter());\r\n                    var newCenter = ovmMap.getCoordinateFromPixel([centerPixel[0] + drag._delta.x, centerPixel[1] + drag._delta.y]);\r\n                    var extent = map.getExtent();\r\n                    var halfWidth = (extent[2] - extent[0]) / 2;\r\n                    var halfHeight = (extent[3] - extent[1]) / 2;\r\n\r\n                    if (newCenter[0] + halfWidth > map.maxExtent[2]) {\r\n                        newCenter[0] = map.maxExtent[2] - halfWidth;\r\n                    }\r\n                    else if (newCenter[0] - halfWidth < map.maxExtent[0]) {\r\n                        newCenter[0] = map.maxExtent[0] + halfWidth;\r\n                    }\r\n                    if (newCenter[1] + halfHeight > map.maxExtent[3]) {\r\n                        newCenter[1] = map.maxExtent[3] - halfHeight;\r\n                    }\r\n                    else if (newCenter[1] - halfHeight < map.maxExtent[1]) {\r\n                        newCenter[1] = map.maxExtent[1] + halfHeight;\r\n                    }\r\n\r\n                    drag.setPosition(0, 0);\r\n                    delete drag._delta;\r\n                    map.setCenter(newCenter, { animate: true });\r\n                });\r\n            });\r\n\r\n        map.wrap.getMap().then(function (olMap) {\r\n\r\n            // Modificamos mapa para que tenga la proyección correcta\r\n            self.reset();\r\n\r\n            const load = self.parent.div.querySelector('.' + self.parent.CLASS + '-load');\r\n            olLayer._wrap.$events.on(TC.Consts.event.BEFORETILELOAD, function () {\r\n                load.classList.remove(TC.Consts.classes.HIDDEN);\r\n                load.classList.add(TC.Consts.classes.VISIBLE);\r\n            });\r\n            olLayer._wrap.$events.on(TC.Consts.event.TILELOAD, function () {\r\n                load.classList.remove(TC.Consts.classes.VISIBLE);\r\n                load.classList.add(TC.Consts.classes.HIDDEN);\r\n            });\r\n\r\n            olMap.addControl(self.ovMap);\r\n\r\n            self.parent.isLoaded = true;\r\n            self.parent.trigger(TC.Consts.event.MAPLOAD);\r\n        });\r\n    });\r\n};\r\n\r\nTC.wrap.control.OverviewMap.prototype.reset = function (options) {\r\n    const self = this;\r\n    return new Promise(function (resolve, _reject) {\r\n        const setLayer = function (layer, crs) {\r\n            if (layer.type === TC.Consts.layerType.WMTS) {\r\n                var layerProjectionOptions = { crs: crs || self.parent.map.crs, oldCrs: layer.wrap.layer.getSource().getProjection().getCode() }; // , allowFallbackLayer: true\r\n\r\n                if (layerProjectionOptions.oldCrs !== layerProjectionOptions.crs) {\r\n                    layer.setProjection(layerProjectionOptions);\r\n                }\r\n            }\r\n\r\n            layer.wrap.getLayer().then(function (olLayer) {\r\n\r\n                var olView = new ol.View(getResolutionOptions(self.parent.map.wrap, olLayer._wrap.parent));\r\n\r\n                if (olView.getResolutions()) {\r\n                    olView.setResolution(olView.getResolutions().filter(function (res) {\r\n                        return res > olView.getResolutionForExtent(self.parent.map.getExtent(), olMap.getSize());\r\n                    }).reverse()[0]);\r\n\r\n                    olMap.setView(olView);\r\n                } else if (olView.getProjection().getCode() !== olMap.getView().getProjection().getCode()) {\r\n                    olMap.setView(olView);\r\n                }\r\n\r\n                // para controlar el mapa en blanco en IE en la carga inicial\r\n                olLayer._wrap.$events.one(TC.Consts.event.TILELOAD, function () {\r\n                    olMap.getLayers().getArray()[0].getSource().refresh();\r\n                });\r\n\r\n                if (layer !== self.parent.layer || olMap.getLayers().getArray().indexOf(layer) === -1) {\r\n\r\n                    self.parent.map.trigger(TC.Consts.event.OVERVIEWBASELAYERCHANGE, { oldLayer: layer !== self.parent.layer ? self.parent.layer : null, newLayer: layer });\r\n                    olMap.getLayers().forEach(function (l) {\r\n                        if (l instanceof ol.layer.Image || l instanceof ol.layer.Tile) {\r\n                            olMap.removeLayer(l);\r\n                        }\r\n                    });\r\n\r\n                    const load = self.parent.div.querySelector('.' + self.parent.CLASS + '-load');\r\n                    olLayer._wrap.$events.on(TC.Consts.event.BEFORETILELOAD, function () {\r\n                        load.classList.remove(TC.Consts.classes.HIDDEN);\r\n                        load.classList.add(TC.Consts.classes.VISIBLE);\r\n                    });\r\n                    olLayer._wrap.$events.on(TC.Consts.event.TILELOAD, function () {\r\n                        load.classList.remove(TC.Consts.classes.VISIBLE);\r\n                        load.classList.add(TC.Consts.classes.HIDDEN);\r\n                    });\r\n\r\n                    olMap.getLayers().insertAt(0, olLayer); // GLS: no usamos .addLayer(olLayer) para asegurar que la capa a añadir quede como fondo.\r\n                }\r\n\r\n                resolve(layer);\r\n            });\r\n        };\r\n\r\n        options = options || {};\r\n        var layer = options.layer || self.parent.layer;\r\n        if (self.parent.map && layer && self.ovMap) {\r\n            var olMap = self.ovMap.ovmap_;\r\n\r\n            layer.getCapabilitiesPromise().then(function () {\r\n\r\n                var originalLayer = layer;\r\n\r\n                if (!layer.isCompatible(self.parent.map.crs) && layer.wrap.getCompatibleMatrixSets(self.parent.map.crs).length === 0) {\r\n                    layer = layer.getFallbackLayer() || self.parent.defaultLayer;\r\n\r\n                    layer.getCapabilitiesPromise().then(function () {\r\n                        if (self.parent.map.on3DView && !layer.isCompatible(self.parent.map.crs)) {\r\n                            self.parent.map.loadProjections({\r\n                                crsList: originalLayer.getCompatibleCRS(),\r\n                                orderBy: 'name'\r\n                            }).then(function (projList) {\r\n                                setLayer(originalLayer, projList[0].code);\r\n                            });\r\n                        } else if (layer.isCompatible(self.parent.map.crs)) {\r\n                            setLayer(layer);\r\n                        }\r\n                    });\r\n                } else {\r\n                    setLayer(layer);\r\n                }\r\n            });\r\n        }\r\n    });\r\n};\r\n\r\nTC.wrap.control.OverviewMap.prototype.get3DCameraLayer = function () {\r\n    var self = this;\r\n    var result = null;\r\n    var camLayerId = '3DCamera';\r\n    var ovMap;\r\n\r\n    if (self.ovMap) {\r\n        ovMap = self.ovMap.getOverviewMap();\r\n        ovMap.getLayers().forEach(function (elm) {\r\n            if (elm.get('id') === camLayerId) {\r\n                result = elm;\r\n            }\r\n        });\r\n\r\n        if (!result) {\r\n            var fovStyle = createNativeStyle({});\r\n            // Ponemos los cuadriláteros de fov sin relleno (por legibilidad)\r\n            fovStyle[0].getFill().setColor([0, 0, 0, 0]);\r\n            result = new ol.layer.Vector({\r\n                id: camLayerId,\r\n                source: new ol.source.Vector(),\r\n                style: fovStyle\r\n            });\r\n            ovMap.addLayer(result);\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.control.OverviewMap.prototype.draw3DCamera = function (options) {\r\n    var self = this;\r\n\r\n    if (this.parent.map.isLoaded) {\r\n        self.is3D = !!options;\r\n        var camLayer = self.get3DCameraLayer();\r\n        if (camLayer) {\r\n            var feature;\r\n            options = options || {};\r\n            var fov = options.fov;\r\n            var source = camLayer.getSource();\r\n            if (!fov || !fov.length) { // no vemos terreno o no estamos en vista 3D\r\n                source.clear();\r\n            }\r\n            else {\r\n                var features = source.getFeatures();\r\n                if (!features.length) {\r\n                    feature = new ol.Feature();\r\n                    source.addFeature(feature);\r\n                }\r\n                else {\r\n                    feature = features[0];\r\n                }\r\n                feature.setGeometry(new ol.geom.Polygon([fov]));\r\n            }\r\n            var heading = typeof options.heading === 'number' ? options.heading : 0;\r\n            self._boxElm.style.transform = 'rotate(' + heading + 'rad)';\r\n        }\r\n    }\r\n};\r\n\r\nTC.wrap.control.OverviewMap.prototype.enable = function () {\r\n    var self = this;\r\n    if (self.parent.layer && self.parent.layer.setVisibility) {\r\n        self.parent.layer.setVisibility(true);\r\n\r\n        /* GLS: bug 23855: mapa de situación se muestra en blanco\r\n            En el resize se valida el alto y el ancho y como el div padre (id = \"ovmap\") tiene display: none, \r\n            el ancho y el alto devuelven cero y por ello se muestra en blanco. \r\n            No vale con lanzar .trigger('resize') porque no utiliza los valores actuales del div, \r\n            sino los almacenados, por eso llamamos a updateSize que actualiza dichos valores.\r\n            https://tfsapp.tracasa.es:8088/tfs/web/wi.aspx?pcguid=4819cc6e-400e-4f70-ba7c-c18a830405aa&id=23855                \r\n        */\r\n        self.parent.wrap.ovMap.ovmap_.updateSize();\r\n\r\n        // Lo siguiente es para actualizar mapa de situación\r\n        const resizeEvent = document.createEvent('HTMLEvents');\r\n        resizeEvent.initEvent('resize', false, false);\r\n        self.parent.map.div.dispatchEvent(resizeEvent);\r\n    }\r\n};\r\n\r\nTC.wrap.control.OverviewMap.prototype.disable = function () {\r\n    var self = this;\r\n    if (self.parent.layer && self.parent.layer.setVisibility) {\r\n        self.parent.layer.setVisibility(false);\r\n    }\r\n};\r\n\r\nTC.wrap.control.OverviewMap.prototype.manageSize = function () {\r\n    const self = this;\r\n\r\n    TC.wrap.Map.prototype.manageSize.call(self);\r\n};\r\n\r\nTC.wrap.control.FeatureInfo.prototype.register = function (map) {\r\n    var self = this;\r\n    map.wrap.getMap().then(function (_olMap) {\r\n        TC.wrap.control.Click.prototype.register.call(self, map);\r\n        var _clickTrigger = self._trigger;\r\n        self._trigger = function (e) {\r\n            var result = _clickTrigger.call(self, e);\r\n            if (result) {\r\n                self.parent.beforeRequest({ xy: e.pixel });\r\n            }\r\n            else {\r\n                map.trigger(TC.Consts.event.NOFEATUREINFO, { control: self.parent });\r\n            }\r\n            return result;\r\n        };\r\n    });\r\n};\r\n\r\nvar bufferElm;\r\nvar getElementText = function (elm) {\r\n    var text = elm.innerHTML || elm.textContent;\r\n    bufferElm = bufferElm || document.createElement(\"textarea\");\r\n    bufferElm.innerHTML = text;\r\n    return bufferElm.value;\r\n};\r\n\r\nvar esriXmlParser = {\r\n    readFeatures: function (text) {\r\n        var result = [];\r\n        var dom = (new DOMParser()).parseFromString(text, 'text/xml');\r\n        if (dom.documentElement.tagName === 'FeatureInfoResponse') {\r\n            var fiCollections = dom.documentElement.getElementsByTagName('FeatureInfoCollection');\r\n            for (var i = 0, len = fiCollections.length; i < len; i++) {\r\n                var fic = fiCollections[i];\r\n                var layerName = fic.getAttribute('layername');\r\n                var fInfos = fic.getElementsByTagName('FeatureInfo');\r\n                for (var j = 0, lenj = fInfos.length; j < lenj; j++) {\r\n                    var fields = fInfos[j].getElementsByTagName('Field');\r\n                    var attributes = {\r\n                    };\r\n                    for (var k = 0, lenk = fields.length; k < lenk; k++) {\r\n                        var field = fields[k];\r\n                        attributes[getElementText(field.getElementsByTagName('FieldName')[0])] = getElementText(field.getElementsByTagName('FieldValue')[0]);\r\n                    }\r\n                    var feature = new ol.Feature(attributes);\r\n                    feature.setId(layerName + '.' + TC.getUID());\r\n                    result.push(feature);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};\r\n\r\nvar addLayerToService = function (service, layer, name) {\r\n    var path = layer.getPath(name);\r\n    service.layers.push({\r\n        name: name,\r\n        title: path[path.length - 1],\r\n        path: path.slice(1),\r\n        features: [],\r\n        filter: layer.filter\r\n    });\r\n};\r\n\r\nTC.wrap.control.FeatureInfo.prototype.getFeatureInfo = function (coords, resolution, options) {\r\n    var self = this;\r\n    var opts = options || {};\r\n    var map = self.parent.map;\r\n    return new Promise(function (resolve, _reject) {\r\n        map.wrap.getMap().then(function (olMap) {\r\n            var targetServices = {};\r\n            var auxInfo = {};\r\n            const requestPromises = [];\r\n            const requestDataArray = [];\r\n            var featurePromises = [];\r\n            var services = [];\r\n\r\n            //var infoFormats = [];\r\n            var layers = olMap.getLayers().getArray();\r\n\r\n            // GLS: filtro el array de capas para quedarnos con las capas que son raster y visibles.\r\n            layers = layers.filter(function (elem) { return elem instanceof ol.layer.Image && elem.getVisible(); });\r\n\r\n            for (var j = 0; j < layers.length; j++) {\r\n                var olLayer = layers[j];\r\n                var layer = olLayer._wrap.parent;\r\n                const source = olLayer.getSource();\r\n                //console.log(\"Source: \" + layer.layerNames.join(\",\"));\r\n                //Por qué en workLayers están el vectorial de medición, y cosas así?\r\n                if (source.getFeatureInfoUrl && map.workLayers.indexOf(layer) >= 0 && layer.names.length > 0\r\n                    && (!opts.serviceUrl || opts.serviceUrl === layer.url)) { // Mirar si en las opciones pone que solo busque en un servicio\r\n\r\n                    //\r\n                    let targetService;\r\n                    if (!targetServices[layer.url]) {\r\n                        targetService = {\r\n                            url: layer.url,\r\n                            layers: [],\r\n                            mapLayers: [],\r\n                            title: layer.title,\r\n                            request: null\r\n                        };\r\n                        targetServices[layer.url] = targetService;\r\n                        auxInfo[layer.url] = {\r\n                            source: TC.Util.extend(true, {}, source),\r\n                            layers: []\r\n                        };\r\n                    }\r\n                    else {\r\n\r\n                        targetService = targetServices[layer.url];\r\n                        auxInfo[layer.url].source.updateParams(TC.Util.extend(auxInfo[layer.url].source.getParams(), source.getParams()));\r\n                    }\r\n                    targetService.mapLayers.push(layer);\r\n\r\n                    //var targetService = {\r\n                    //    layers: [], mapLayers: [layer]\r\n                    //};\r\n                    var disgregatedNames = layer.getDisgregatedLayerNames();\r\n                    if (opts.layerName) { // Mirar si en las opciones pone que solo busque en una capa\r\n                        if (disgregatedNames.indexOf(opts.layerName) >= 0 && olLayer._wrap.getInfo(opts.layerName).queryable) {\r\n                            addLayerToService(targetService, layer, opts.layerName);\r\n                            auxInfo[layer.url].layers.push(opts.layerName);\r\n                        }\r\n                    }\r\n                    else {\r\n                        for (var i = 0; i < disgregatedNames.length; i++) {\r\n                            var name = disgregatedNames[i];\r\n                            if (olLayer._wrap.getInfo(name).queryable) {\r\n                                addLayerToService(targetService, layer, name);\r\n                            }\r\n                            else {\r\n                                TC.Util.consoleRegister('Capa \"' + disgregatedNames[i] + '\" no queryable, la eliminamos de la petición GFI');\r\n                                disgregatedNames.splice(i, 1);\r\n                                i = i - 1;\r\n                            }\r\n\r\n                        }\r\n\r\n                        // GLS: validamos si nos queda alguna capa a la cual consultar\r\n                        if (disgregatedNames.length > 0) {\r\n                            auxInfo[layer.url].layers = auxInfo[layer.url].layers.concat(disgregatedNames);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            const _isGMLFilter = function (filter) {\r\n                return filter && (/<ogc:Filter.*<\\/ogc:Filter>/.test(filter) || filter instanceof TC.filter.Filter);\r\n            };\r\n            for (var serviceUrl in targetServices) {\r\n                services.push(targetServices[serviceUrl]);\r\n                const targetService = targetServices[serviceUrl];\r\n                const source = auxInfo[serviceUrl].source;\r\n                const serviceLayers = auxInfo[serviceUrl].layers;\r\n\r\n                // GLS: validamos si hay capas a las cuales consultar, si no hay continuamos con el siguiente servicio\r\n                if (!serviceLayers || serviceLayers.length === 0) {\r\n                    continue;\r\n                }\r\n\r\n                var params = source.getParams();\r\n                if (params.filter) params.filter = targetService.layers.map(function (i) { return \"(\" + (!_isGMLFilter(i.filter) ? \"\" : i.filter instanceof TC.filter.Filter ? i.filter.getText() : i.filter) + \")\"; }).join(\"\");\r\n                if (params.cql_filter) params.cql_filter = targetService.layers.map(function (i) { return !i.filter || _isGMLFilter(i.filter) ? \"INCLUDE\" : i.filter; }).join(\";\");\r\n                source.params_.LAYERS = serviceLayers.join(',');\r\n                var gfiURL = source.getFeatureInfoUrl(coords, resolution, map.crs, {\r\n                    'QUERY_LAYERS': serviceLayers.join(','),\r\n                    'INFO_FORMAT': params.INFO_FORMAT,\r\n                    'FEATURE_COUNT': 1000,\r\n                    'radius': map.options.pixelTolerance,\r\n                    'buffer': map.options.pixelTolerance\r\n                });\r\n\r\n                gfiURL = gfiURL.replace(/sld_body=[a-zA-Z%0-9._]*/); // Quitamos el parámetro sld_body\r\n\r\n\r\n                var expUrl = gfiURL;\r\n                const requestData = {\r\n                    serviceUrl: serviceUrl,\r\n                    requestedFormat: params.INFO_FORMAT,\r\n                    expandUrl: expUrl\r\n                };\r\n                requestDataArray.push(requestData);\r\n                requestPromises.push(new Promise(function (resolve, reject) {\r\n                    const mapLayer = targetService.mapLayers[0];\r\n                    mapLayer.toolProxification.fetch(gfiURL)\r\n                        .then(function (data) {\r\n                            mapLayer.toolProxification.cacheHost.getAction(requestData.expandUrl).then(function (cache) {\r\n                                requestData.originalUrl = cache.action.call(mapLayer.toolProxification, requestData.expandUrl);\r\n                                resolve(TC.Util.extend({}, data, requestData));\r\n                            });\r\n                        })\r\n                        .catch(function (error) {\r\n                            reject(Error(error));\r\n                        });\r\n                }));\r\n                TC.Util.consoleRegister(\"Lanzamos GFI\");\r\n            }\r\n\r\n            if (requestPromises.length > 0) {\r\n                Promise.all(requestPromises).then(function (responses) {\r\n                    var someSuccess = false;\r\n                    var featureCount = 0;\r\n                    var featureInsertionPoints = [];\r\n                    for (var i = 0; i < responses.length; i++) {\r\n                        var featureInfo = responses[i];\r\n                        var service = targetServices[requestDataArray[i].serviceUrl];\r\n                        someSuccess = true;\r\n                        service.text = featureInfo.responseText;\r\n                        var format;\r\n                        var iFormat = featureInfo.contentType;\r\n                        if (iFormat && iFormat.indexOf(\";\") > -1)\r\n                            iFormat = iFormat.substr(0, iFormat.indexOf(\";\")).trim();\r\n\r\n                        if (!iFormat) iFormat = featureInfo.requestedFormat;\r\n\r\n                        if (iFormat === featureInfo.requestedFormat) {\r\n                            switch (iFormat) {\r\n                                case 'application/json':\r\n                                    format = new ol.format.GeoJSON();\r\n                                    break;\r\n                                case 'application/vnd.ogc.gml':\r\n                                    if (featureInfo.responseText.indexOf(\"FeatureCollection\") > -1) {\r\n                                        format = new ol.format.WFS({\r\n                                            gmlFormat: new ol.format.GML2({\r\n                                                srsName: map.crs\r\n                                            })\r\n                                        });\r\n                                    }\r\n                                    else {\r\n                                        format = new ol.format.WMSGetFeatureInfo();\r\n                                    }\r\n                                    break;\r\n                                case 'application/vnd.ogc.gml/3.1.1':\r\n                                    format = new ol.format.GML3({\r\n                                        srsName: map.crs\r\n                                    });\r\n                                    break;\r\n                                case 'application/vnd.esri.wms_featureinfo_xml':\r\n                                    format = esriXmlParser;\r\n                                    break;\r\n                                default:\r\n                                    format = null;\r\n                                    break;\r\n                            }\r\n\r\n                            if (format) {\r\n                                var features;\r\n                                try {\r\n                                    features = format.readFeatures(featureInfo.responseText, {\r\n                                        featureProjection: ol.proj.get(map.crs)\r\n                                    });\r\n                                }\r\n                                catch (e) {\r\n                                    TC.error(self.parent.getLocaleString('featureInfo.error.badResponse', { url: featureInfo.serviceUrl }) + ': ' + e.message);\r\n                                    features = [];\r\n                                    continue;\r\n                                }\r\n                                featureCount = featureCount + features.length;\r\n                                var isParentOrSame = function (layer, na, nb) {\r\n                                    var result = false;\r\n                                    if (na === nb) {\r\n                                        result = true;\r\n                                    }\r\n                                    else {\r\n                                        var pa = layer.getNodePath(na);\r\n                                        var pb = layer.getNodePath(nb);\r\n                                        if (pa.length > 0 && pb.length >= pa.length) {\r\n                                            result = true;\r\n                                            for (var i = 0; i < pa.length; i++) {\r\n                                                if (layer.wrap.getName(pa[i]) !== layer.wrap.getName(pb[i])) {\r\n                                                    result = false;\r\n                                                    break;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    return result;\r\n                                };\r\n\r\n                                var fakeLayers = {\r\n                                };\r\n\r\n                                for (var j = 0; j < features.length; j++) {\r\n                                    var feature = features[j];\r\n                                    if (feature instanceof ol.Feature) {\r\n                                        var fid = feature.getId() || TC.getUID();\r\n                                        var found = false;\r\n                                        var layerName = fid.substr(0, fid.lastIndexOf('.'));\r\n                                        for (var k = 0; k < service.layers.length; k++) {\r\n                                            var l = service.layers[k];\r\n                                            var lName = l.name.substr(l.name.indexOf(':') + 1);\r\n                                            if (service.mapLayers.some(mapLayer => isParentOrSame(mapLayer, lName, layerName))) {\r\n                                                found = true;\r\n                                                if (!opts.featureId || feature.getId() === opts.featureId) { // Mirar si en las opciones pone que solo busque una feature\r\n                                                    featurePromises.push(TC.wrap.Feature.createFeature(feature, { showsPopup: false }));\r\n                                                    featureInsertionPoints.push(l.features);\r\n                                                }\r\n                                                break;\r\n                                            }\r\n                                        }\r\n\r\n                                        //si llegamos aquí y no he encontrado su layer, es que no cuadraba el prefijo del fid con el id del layer\r\n                                        //esto pasa, p.ej, en cartociudad\r\n                                        if (!found) {\r\n                                            //así que creo un layer de palo para la respuesta del featInfo\r\n                                            var fakeLayer;\r\n                                            if (fakeLayers[layerName]) fakeLayer = fakeLayers[layerName];\r\n                                            else {\r\n                                                fakeLayer = {\r\n                                                    name: layerName, title: layerName, path: [layerName], features: []\r\n                                                };\r\n                                                fakeLayers[layerName] = fakeLayer;\r\n                                                service.layers.push(fakeLayer);\r\n                                            }\r\n\r\n                                            if (!opts.featureId || feature.getId() === opts.featureId) { // Mirar si en las opciones pone que solo busque una feature\r\n                                                featurePromises.push(TC.wrap.Feature.createFeature(feature, { showsPopup: false }));\r\n                                                featureInsertionPoints.push(fakeLayer.features);\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }//iteración sobre las features de esta respuesta\r\n\r\n\r\n                            }\r\n                            else {\r\n                                //si no hay formato reconocido y parseable, metemos un iframe con la respuesta\r\n                                //y prau\r\n                                //para eso, creo una falsa entrada de tipo feature, con un campo especial rawUrl o rawContent\r\n\r\n                                const compoundLayer = {\r\n                                    name: 'layer' + TC.getUID(), title: 'Datos en el punto', features: [{\r\n                                        rawUrl: featureInfo.originalUrl, expandUrl: featureInfo.expandUrl, rawContent: featureInfo.responseText, rawFormat: iFormat\r\n                                    }]\r\n                                };\r\n\r\n                                service.layers.push(compoundLayer);\r\n                                featureCount = featureCount + 1;\r\n                            }\r\n                        }\r\n                        else { // iFormat !== featureInfo.requestedFormat\r\n\r\n                            // GLS:\r\n                            TC.Util.consoleRegister(\"Respuesta GFI: lo más probable es que el servidor esté devolviendo una excepción\");\r\n                            TC.Util.consoleRegister(\"Lanzamos los eventos que corresponde y mostramos tostada\");\r\n\r\n                            // En este caso lo más probable es que el servidor esté devolviendo una excepción\r\n                            self.parent.responseError({\r\n                                message: featureInfo.responseText,\r\n                                status: featureInfo.status\r\n                            });\r\n                            // GLS: misma gestión de error que en ol.js - > function (a, b, c) { // error...\r\n                            map.toast(self.parent.getLocaleString('featureInfo.error'), {\r\n                                type: TC.Consts.msgType.ERROR\r\n                            });\r\n                        }\r\n\r\n                    }\r\n                    if (someSuccess) {\r\n                        Promise.all(featurePromises).then(function afterFeatureInfoPromises(features) {\r\n                            var defaultFeature;\r\n                            features.forEach(function (feat, idx) {\r\n                                feat.attributes = [];\r\n                                for (var key in feat.data) {\r\n                                    var value = feat.data[key];\r\n                                    if (typeof value !== 'object') {\r\n                                        feat.attributes.push({\r\n                                            name: key,\r\n                                            value: typeof value === \"number\" ? value.toLocaleString(TC.Util.getMapLocale(self.parent.map)) : value\r\n                                        });\r\n                                    }\r\n                                    else {\r\n                                        feat.attributes.push({\r\n                                            name: key,\r\n                                            value: value//\"objeto complejo\"\r\n                                        });\r\n                                    }\r\n                                }\r\n                                if (!defaultFeature && TC.Geometry.isInside(coords, feat.geometry)) {\r\n                                    defaultFeature = feat;\r\n                                }\r\n                                const featureInsertionPoint = featureInsertionPoints[idx];\r\n                                // Añadimos la feature si no ha sido ya añadida (por ejemplo porque hay dos capas en el \r\n                                // mapa que tienen features coincidentes)\r\n                                if (!featureInsertionPoint.some(f => f.id === feat.id)) {\r\n                                    featureInsertionPoint.push(feat);\r\n                                }\r\n                            });\r\n\r\n                            var services = [];\r\n                            for (let serviceUrl in targetServices) {\r\n                                if (Object.prototype.hasOwnProperty.call(targetServices, serviceUrl)) {\r\n                                    services.push(targetServices[serviceUrl]);\r\n                                }\r\n                            }\r\n\r\n                            self.parent.responseCallback({\r\n                                coords: coords,\r\n                                resolution: resolution,\r\n                                services: services,\r\n                                featureCount: featureCount,\r\n                                defaultFeature: defaultFeature\r\n                            });\r\n                            resolve();\r\n                        });\r\n                    }\r\n                    else {\r\n                        resolve();\r\n                    }\r\n                },\r\n                    function (_a, _b, _c) { // error\r\n                        if (services && services.length === 0) {\r\n                            for (let serviceUrl in targetServices) {\r\n                                services.push(targetServices[serviceUrl]);\r\n                            }\r\n                        }\r\n\r\n                        self.parent.responseCallback({\r\n                            coords: coords, resolution: resolution, services: services, featureCount: 0\r\n                        });\r\n                        map.toast(self.parent.getLocaleString('featureInfo.error'), {\r\n                            type: TC.Consts.msgType.ERROR\r\n                        });\r\n                        resolve();\r\n                    });\r\n            }\r\n            else {\r\n\r\n                if (map.workLayers.filter(function (layer) {\r\n                    return layer instanceof TC.layer.Raster;\r\n                }).length > 0) {\r\n                    map.toast(self.parent.getLocaleString('featureInfo.notQueryableLayers'), {\r\n                        type: TC.Consts.msgType.INFO\r\n                    });\r\n                }\r\n\r\n                if (services && services.length === 0) {\r\n                    for (let serviceUrl in targetServices) {\r\n                        services.push(targetServices[serviceUrl]);\r\n                    }\r\n                }\r\n\r\n                // GLS: nos suscribimos TC.Consts.event.BEFOREFEATUREINFO y lanzamos el mismo evento de zero resultados ya que puede darse que la resolución se lance antes del before.\r\n                map.on(TC.Consts.event.BEFOREFEATUREINFO, function () {\r\n                    self.parent.responseCallback({\r\n                        coords: coords, resolution: resolution, services: services, featureCount: 0\r\n                    });\r\n                });\r\n\r\n                self.parent.responseCallback({\r\n                    coords: coords, resolution: resolution, services: services, featureCount: 0\r\n                });\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\nTC.wrap.control.GeometryFeatureInfo.prototype.register = function (map) {\r\n    var self = this;\r\n    map.wrap.getMap().then(function (_olMap) {\r\n        TC.wrap.control.Click.prototype.register.call(self, map);\r\n        var _clickTrigger = self._trigger;\r\n        self._trigger = function (e) {\r\n            self.hasSuitableLayers().then(function (hasLayers) {\r\n                if (hasLayers) {\r\n                    if (!self.parent._isSearching) {\r\n                        if (e.type === SINGLECLICK && !self.parent._isDrawing && !self.parent._isSearching) {\r\n                            _clickTrigger.call(self, e);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        };\r\n\r\n    });\r\n};\r\n\r\nTC.wrap.control.GeometryFeatureInfo.prototype.hasSuitableLayers = function () {\r\n    const self = this;\r\n    return new Promise(function (resolve, _reject) {\r\n        const map = self.parent.map;\r\n        var ret = false;\r\n        map.wrap.getMap().then(function (olMap) {\r\n            olMap.getLayers().forEach(function (olLayer) {\r\n                var layer = olLayer._wrap.parent;\r\n                var source = olLayer.getSource();\r\n                //Por qué en workLayers están el vectorial de medición, y cosas así?\r\n                if (source.getFeatureInfoUrl && map.workLayers.indexOf(layer) >= 0) {\r\n                    ret = true;\r\n                    return false;   //break del foreach\r\n                }\r\n            });\r\n            resolve(ret);\r\n        });\r\n    });\r\n};\r\n\r\nTC.wrap.control.GeometryFeatureInfo.prototype.beginDraw = function (options) {\r\n    var self = this;\r\n    options = options || {};\r\n    var xy = options.xy;\r\n    var layer = options.layer || self.parent.filterLayer;\r\n    var callback = options.callback;\r\n    var geometryType = options.geometryType;\r\n    var semaforo = false;\r\n    if (!self.drawCtrl) {\r\n        layer.wrap.getLayer().then(function (olLayer) {\r\n            var olGeometryType;\r\n            switch (geometryType) {\r\n                case TC.Consts.geom.POLYLINE:\r\n                    olGeometryType = ol.geom.GeometryType.LINE_STRING;\r\n                    break;\r\n                default:\r\n                    olGeometryType = ol.geom.GeometryType.POLYGON;\r\n                    break;\r\n            }\r\n            const layerStyle = olLayer.getStyle();\r\n            // Si la geometría es del tipo correcto, cogemos el estilo de la capa\r\n            const styleFunction = function (olFeature) {\r\n                if (olFeature && olFeature.getGeometry().getType() === olGeometryType) {\r\n                    if (TC.Util.isFunction(layerStyle)) {\r\n                        return layerStyle(olFeature);\r\n                    }\r\n                    return layerStyle;\r\n                }\r\n                return null;\r\n            };\r\n            self.drawCtrl = new ol.interaction.Draw({\r\n                source: olLayer.getSource(),\r\n                type: olGeometryType,\r\n                style: styleFunction\r\n            });\r\n            var setShowsPopup = function (wrap) {\r\n                wrap.parent.showsPopup = false;\r\n            };\r\n            olLayer.getSource().on(ADDFEATURE, function (event) {\r\n                const olFeat = event.feature;\r\n                if (olFeat._wrap) {\r\n                    setShowsPopup(olFeat._wrap);\r\n                }\r\n                else {\r\n                    TC.wrap.Feature.createFeature(olFeat).then(f => setShowsPopup(f.wrap));\r\n                }\r\n            });\r\n            self.drawCtrl.handleEvent = function (event) {\r\n                //esta ñapa para solucionar cuando haces un primer punto y acontinuación otro muy rápido\r\n                if (event.type === SINGLECLICK) {\r\n                    var points = olGeometryType === ol.geom.GeometryType.POLYGON ? this.sketchCoords_[0] : this.sketchCoords_;\r\n                    if (semaforo && points.length === 2 && this.sketchFeature_ !== null) {// GLS: Añado la misma validación (this.sketchFeature_ !== null) que tiene el código de OL antes de invocar addToDrawing_ \r\n                        this.addToDrawing_(event);\r\n                    }\r\n                    else {\r\n                        semaforo = true;\r\n                    }\r\n                }\r\n                return ol.interaction.Draw.prototype.handleEvent.call(this, event);\r\n            };\r\n            const map = self.parent.map;\r\n            const olMap = map.wrap.map;\r\n            olMap.addInteraction(self.drawCtrl);\r\n            self.drawCtrl.on('drawstart', function (_event) {\r\n                self.parent._isDrawing = true;\r\n                olMap.getInteractions().forEach(function (item, _i) {\r\n                    if (item instanceof ol.interaction.DoubleClickZoom) {\r\n                        item.setActive(false);\r\n                    }\r\n                });\r\n            });\r\n            self.drawCtrl.startDrawing_(xy);\r\n            self.drawCtrl.on('drawend', function (event) {\r\n                self.parent._isDrawing = false;\r\n                olMap.getInteractions().forEach(function (item, _i) {\r\n                    if (item instanceof ol.interaction.DoubleClickZoom) {\r\n                        item.setActive(false);\r\n                    }\r\n                });\r\n                olMap.removeInteraction(self.drawCtrl);\r\n                this.setActive(false);\r\n                self.drawCtrl = null;\r\n                olLayer.getSource().clear();\r\n                self.parent._drawToken = true;\r\n                setTimeout(function () {\r\n                    self.parent._drawToken = false;\r\n                }, 500);\r\n                event.feature.setId(self.parent.getUID());\r\n\r\n                TC.wrap.Feature.createFeature(event.feature, { showsPopup: false }).then(function (feat) {\r\n                    self.parent.filterFeature = feat;\r\n                    feat.layer = self.parent.filterLayer;\r\n                    if (callback) {\r\n                        callback(feat);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n\r\n    }\r\n    else {\r\n        self.drawCtrl.setActive(true);\r\n        self.drawCtrl.startDrawing_(xy);\r\n    }\r\n};\r\n\r\nTC.wrap.control.GeometryFeatureInfo.prototype.cancelDraw = function (_xy, _layer, _callback) {\r\n    var self = this;\r\n    if (self.drawCtrl && self.parent._isDrawing) {\r\n        self.parent._isDrawing = false;\r\n        self.drawCtrl.setActive(false);\r\n        self.drawCtrl.source_.clear();\r\n\r\n    }\r\n};\r\n\r\nvar readFeaturesFromResponse = function (map, data, contentType) {\r\n    var format;\r\n    var iFormat = contentType;\r\n    if (iFormat && iFormat.indexOf(\";\") > -1)\r\n        iFormat = iFormat.substr(0, iFormat.indexOf(\";\")).trim();\r\n\r\n    if (!iFormat) iFormat = data.requestedFormat;\r\n    switch (iFormat) {\r\n        case 'application/json':\r\n            format = new ol.format.GeoJSON();\r\n            break;\r\n        case 'application/vnd.ogc.gml':\r\n            if (data.responseText.indexOf(\"FeatureCollection\") > -1)\r\n                format = new ol.format.WFS({\r\n                    gmlFormat: new ol.format.GML2({\r\n                        srsName: map.crs\r\n                    })\r\n                });\r\n            else\r\n                format = new ol.format.WMSGetFeatureInfo();\r\n            break;\r\n        case 'application/vnd.ogc.gml/3.1.1':\r\n            format = new ol.format.GML3({\r\n                srsName: map.crs\r\n            });\r\n            break;\r\n        case \"text/xml\":\r\n        case \"application/xml\": {\r\n            //posible error\r\n            const exception = data.querySelector(\"ServiceException\");\r\n            if (exception)\r\n                TC.error(exception);\r\n            format = null;\r\n            break;\r\n        }\r\n        default:\r\n            format = null;\r\n            break;\r\n    }\r\n    if (format) {\r\n        return format.readFeatures(data, {\r\n            featureProjection: ol.proj.get(map.crs)\r\n        });\r\n    }\r\n    else {\r\n        return null;\r\n        ////si no hay formato reconocido y parseable, metemos un iframe con la respuesta\r\n        ////y prau\r\n        ////para eso, creo una falsa entrada de tipo feature, con un campo especial rawUrl o rawContent\r\n        //var l = service.layers[0];\r\n        //l.features.push({\r\n        //    error: response.responseText\r\n        //});\r\n    }\r\n};\r\nvar featureToServiceDistributor = function (features, service) {\r\n    var featurePromises = [];\r\n    var featureInsertionPoints = [];\r\n    var isParentOrSame = function (layer, na, nb) {\r\n        var result = false;\r\n        if (na === nb || na.indexOf(nb) === 0) {\r\n            result = true;\r\n        }\r\n        else {\r\n            var pa = layer.getPath(na);\r\n            var pb = layer.getPath(nb);\r\n            if (pa.length > 0 && pb.length >= pa.length) {\r\n                result = true;\r\n                for (var i = 0; i < pa.length; i++) {\r\n                    if (pa[i] !== pb[i]) {\r\n                        result = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var fakeLayers = {};\r\n    for (var j = 0; j < features.length; j++) {\r\n        var feature = features[j];\r\n        if (feature instanceof ol.Feature) {\r\n            var fid = feature.getId() || TC.getUID();\r\n            var found = false;\r\n            var layerName = fid.substr(0, fid.lastIndexOf('.'));\r\n            for (var k = 0; k < service.layers.length; k++) {\r\n                var l = service.layers[k];\r\n                var lName = l.name.substr(l.name.indexOf(':') + 1);\r\n                if (service.mapLayers.some(mapLayer => isParentOrSame(mapLayer, lName, layerName))) {\r\n                    found = true;\r\n                    featurePromises.push(TC.wrap.Feature.createFeature(feature));\r\n\r\n                    featureInsertionPoints[feature.id_] = l.features;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            //si llegamos aqu\\u00ed y no he encontrado su layer, es que no cuadraba el prefijo del fid con el id del layer\r\n            //esto pasa, p.ej, en cartociudad\r\n            if (!found) {\r\n                //as\\u00ed que creo un layer de palo para la respuesta del featInfo\r\n                var fakeLayer;\r\n                if (fakeLayers[layerName]) fakeLayer = fakeLayers[layerName];\r\n                else {\r\n                    fakeLayer = {\r\n                        name: layerName, title: layerName, features: []\r\n                    };\r\n                    fakeLayers[layerName] = fakeLayer;\r\n                    service.layers.push(fakeLayer);\r\n                }\r\n\r\n                featurePromises.push(TC.wrap.Feature.createFeature(feature));\r\n                featureInsertionPoints.push(feature.id_);\r\n            }\r\n        }\r\n    }//iteraci\\u00f3n sobre las features de esta respuesta\r\n\r\n    return new Promise(function (resolve, _reject) {\r\n        Promise.all(featurePromises).then(function (features) {\r\n            features.forEach(function (feat) {\r\n                feat.attributes = [];\r\n                //feat.showsPopup = false;\r\n                for (var key in feat.data) {\r\n                    var value = feat.data[key];\r\n                    if (typeof value !== 'object') {\r\n                        feat.attributes.push({\r\n                            name: key, value: value\r\n                        });\r\n                    }\r\n                    else {\r\n                        feat.attributes.push({\r\n                            name: key,\r\n                            value: value//\"objeto complejo\"\r\n                        });\r\n                    }\r\n                }\r\n                featureInsertionPoints[feat.id].push(feat);\r\n            });\r\n            resolve({\r\n                service: service\r\n            });\r\n        });\r\n    });\r\n};\r\n\r\nTC.wrap.control.GeometryFeatureInfo.prototype.getFeaturesByGeometry = function (feature, xy) {\r\n\r\n    var self = this;\r\n    return new Promise(function (resolve, _reject) {\r\n        var map = self.parent.map;\r\n\r\n        map.wrap.getMap().then(function (olMap) {\r\n\r\n            var olGeometry = feature.wrap.feature.getGeometry();\r\n            var stride = olGeometry.stride;\r\n            var flatCoordinates = olGeometry.getFlatCoordinates();\r\n            //calcular el punto mas alto\r\n            if (!xy) {\r\n                var bestPoint = null;\r\n                for (var i = 1, len = flatCoordinates.length; i < len; i += stride) {\r\n                    if (!bestPoint || bestPoint[1] < flatCoordinates[i]) {\r\n                        bestPoint = [flatCoordinates[i - 1], flatCoordinates[i]];\r\n                    }\r\n                }\r\n                xy = olMap.getPixelFromCoordinate(new ol.geom.Point(bestPoint).getCoordinates());\r\n            }\r\n\r\n            self.parent.beforeRequest({ xy: xy });\r\n\r\n            var arrRequests = map.extractFeatures({ filter: new TC.filter.intersects(feature, map.crs), outputFormat: TC.Consts.format.JSON });\r\n\r\n            const arrPromises = [];\r\n            Promise.all(arrRequests).then(function (responses) {\r\n                var targetServices = [];\r\n                var featureCount = 0;\r\n\r\n                for (var i = 0; i < responses.length; i++) {\r\n                    const responseObj = responses[i];\r\n                    if (!responseObj) continue;\r\n                    arrPromises.push(new Promise(function (res, _rej) {\r\n                        if (responseObj.errors && responseObj.errors.length) {\r\n                            for (var j = 0; j < responseObj.errors.length; j++) {\r\n                                var errorMsg, errorType = TC.Consts.msgType.WARNING;\r\n                                var error = responseObj.errors[j];\r\n                                switch (error.key) {\r\n                                    case TC.Consts.WFSErrors.MAX_NUM_FEATURES:\r\n                                        errorMsg = self.parent.getLocaleString(\"wfs.tooManyFeatures\", error.params);\r\n                                        break;\r\n                                    /*case TC.Consts.WFSErrors.NO_LAYERS:\r\n                                        errorMsg = self.parent.getLocaleString('noLayersLoaded');\r\n                                    break;*/\r\n                                    case TC.Consts.WFSErrors.GETCAPABILITIES:\r\n                                        errorMsg = self.parent.getLocaleString('wfsGFI.inValidService', error.params);\r\n                                        break;\r\n                                    case TC.Consts.WFSErrors.NO_FEATURES:\r\n                                        //si no hay features nos callamos. Quizas en un futuro se muestre una alerta\r\n                                        continue;\r\n                                        break;\r\n                                    case TC.Consts.WFSErrors.INDETERMINATE:\r\n                                        errorMsg = self.parent.getLocaleString(\"wfs.IndeterminateError\");\r\n                                        TC.error(\"Error:{error} \\r\\n Descripcion:{descripcion} \\r\\n Servicio:{serviceName}\".format({ error: error.params.err, descripcion: error.params.errorThrown, serviceName: error.params.serviceTitle }), TC.Consts.msgErrorMode.CONSOLE);\r\n                                        errorType = TC.Consts.msgType.ERROR;\r\n                                        break;\r\n                                    default:\r\n                                        errorMsg = self.parent.getLocaleString(\"wfsGFI.\" + error.key, error.params);\r\n                                        break;\r\n                                }\r\n\r\n                                map.toast(errorMsg, { type: errorType });\r\n                            }\r\n                            if (!responseObj.response) {\r\n                                res();\r\n                            }\r\n                        }\r\n                    }));\r\n\r\n                    // Puede no haber response porque la URL no es correcta, metemos un condicional\r\n                    var featuresFound = responseObj.response ? readFeaturesFromResponse(map, responseObj.response.responseText, responseObj.response.contentType) : [];\r\n                    //ahora se distribuye la features por servicio y capa\r\n                    arrPromises[arrPromises.length - 1] = featureToServiceDistributor(featuresFound, responseObj.service);\r\n                    if (responseObj.service) {\r\n                        targetServices.push(responseObj.service);\r\n                    }\r\n                    featureCount = featureCount + featuresFound.length;\r\n                }\r\n                Promise.all(arrPromises).then(function () {\r\n                    self.parent.responseCallback({\r\n                        xy: xy || null, services: targetServices, featureCount: featureCount\r\n                    });\r\n                    resolve();\r\n                });\r\n            }, function (_e) {\r\n                self.parent.responseCallback({});\r\n                resolve();\r\n            });\r\n        });\r\n    });\r\n};\r\n\r\nTC.wrap.control.Popup.prototype = function () {\r\n    this.popup = null;\r\n};\r\n\r\nTC.Consts.event.PANANIMATIONSTART = 'pananimationstart.tc';\r\nTC.Consts.event.PANANIMATIONEND = 'pananimationend.tc';\r\nTC.wrap.control.Popup.prototype.fitToView = function () {\r\n    //return;//SILME MV 20211029\r\n    var self = this;\r\n    var map = self.parent.map;\r\n    var olMap = self.parent.map.wrap.map;\r\n\r\n    var popupBoundingRect = self.parent.popupDiv.getBoundingClientRect();\r\n    var mapBoundingRect = map.div.getBoundingClientRect();\r\n\r\n    var topLeft = olMap.getCoordinateFromPixel([popupBoundingRect.left - mapBoundingRect.left, popupBoundingRect.top - mapBoundingRect.top]);\r\n    var bottomRight = olMap.getCoordinateFromPixel([popupBoundingRect.right - mapBoundingRect.left, popupBoundingRect.bottom - mapBoundingRect.top]);\r\n    var west = topLeft[0];\r\n    var north = topLeft[1];\r\n    var east = bottomRight[0];\r\n    var south = bottomRight[1];\r\n\r\n    var popupExt = [west, south, east, north];\r\n    var mapExt = map.getExtent();\r\n    // MV SILME 20231211\r\n    mapExt[2] = (map.getExtent()[2]) - ((map.getExtent()[2] - map.getExtent()[0]) * (silmeMap.parent.div.querySelector('.panel-content').clientWidth / silmeMap.parent.div.clientWidth));//Silme\r\n\r\n    var newPos = self.popup.getPosition();\r\n    if (document.querySelector(\".left-collapsed\"))\r\n        newPos[0] = mapExt[0] + ((mapExt[2] - mapExt[0]) / 100 * 12);\r\n    else\r\n        newPos[0] = mapExt[0] + ((mapExt[2] - mapExt[0]) / 100 * 25);\r\n    newPos[1] = mapExt[1] + ((mapExt[3] - mapExt[1]) / 100 * 88) - (popupExt[3] - popupExt[1]);\r\n    var newPixelPos = olMap.getPixelFromCoordinate(newPos);\r\n    newPixelPos[1] = olMap.getSize()[1] - newPixelPos[1];\r\n    self.parent._previousContainerPosition = newPixelPos;\r\n    (self.popup._oldUpdatePixelPosition || self.popup.updatePixelPosition).call(self.popup, newPos);\r\n    return;\r\n    // END MV SILME 20231211\r\n\r\n    if (!ol.extent.containsExtent(mapExt, popupExt)) {\r\n        var overflows = {\r\n            left: Math.max(mapExt[0] - popupExt[0], 0),\r\n            bottom: Math.max(mapExt[1] - popupExt[1], 0),\r\n            right: Math.max(popupExt[2] - mapExt[2], 0),\r\n            top: Math.max(popupExt[3] - mapExt[3], 0)\r\n        };\r\n\r\n        //silme - colocam es popup a n'es centre\r\n        if (overflows.left != 0) overflows.left += ((mapExt[2] - mapExt[0]) / 2 - (popupExt[2] - popupExt[0]) / 2);\r\n        if (overflows.bottom != 0) overflows.bottom += ((mapExt[3] - mapExt[1]) / 2 - (popupExt[2] - popupExt[0]) / 2);\r\n        if (overflows.right != 0) overflows.right += ((mapExt[2] - mapExt[0]) / 2 - (popupExt[2] - popupExt[0]) / 2);\r\n        if (overflows.top != 0) overflows.top += ((mapExt[3] - mapExt[1]) / 2 - (popupExt[2] - popupExt[0]) / 2);\r\n        //end silme\r\n\r\n        if (self.parent.dragged) {\r\n            // Movemos el popup\r\n            var newPos = self.popup.getPosition();\r\n            if (overflows.right) {\r\n                newPos[0] = newPos[0] - overflows.right;\r\n            }\r\n            else if (overflows.left) {\r\n                newPos[0] = newPos[0] + overflows.left;\r\n            }\r\n            if (overflows.top) {\r\n                newPos[1] = newPos[1] - overflows.top;\r\n            }\r\n            else if (overflows.bottom) {\r\n                newPos[1] = newPos[1] + overflows.bottom;\r\n            }\r\n\r\n            var newPixelPos = olMap.getPixelFromCoordinate(newPos);\r\n            newPixelPos[1] = olMap.getSize()[1] - newPixelPos[1];\r\n            self.parent._previousContainerPosition = newPixelPos;\r\n            (self.popup._oldUpdatePixelPosition || self.popup.updatePixelPosition).call(self.popup, newPos);\r\n        }\r\n        else {\r\n            if (self.parent.isVisible()) {\r\n                // Movemos el mapa\r\n                var view = olMap.getView();\r\n                var ct = view.getCenter().slice();\r\n\r\n                if (overflows.top) ct[1] += overflows.top;\r\n                else if (overflows.bottom) ct[1] -= overflows.bottom;\r\n                if (overflows.right) ct[0] += overflows.right;\r\n                else if (overflows.left) ct[0] -= overflows.left;\r\n\r\n                view.animate({\r\n                    center: ct, easing: function (percent) {\r\n                        if (percent === 0) self.parent.map.trigger(TC.Consts.event.PANANIMATIONSTART);\r\n                        if (percent === 1) self.parent.map.trigger(TC.Consts.event.PANANIMATIONEND);\r\n                        return percent;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nTC.wrap.control.Popup.prototype.setDragged = function (dragged) {\r\n    const self = this;\r\n    var popup = self.popup;\r\n    //var view = popup.getMap().getView();\r\n    //var onViewChange = function () {\r\n    //    console.log(this.getCenter());\r\n    //};\r\n    if (dragged) {\r\n        // Parcheamos funciones para que el popup no se mueva cuando cambiamos el extent del mapa\r\n        if (!popup._oldUpdatePixelPosition) {\r\n            popup._oldUpdatePixelPosition = popup.updatePixelPosition;\r\n            popup.updatePixelPosition = function () {\r\n            };\r\n        }\r\n        if (!popup._newHandleOffsetChanged) {\r\n            popup._newHandleOffsetChanged = function () {\r\n                popup._oldUpdatePixelPosition();\r\n            };\r\n            if (self._offsetChangeListenerKey) {\r\n                ol.events.unlistenByKey(self._offsetChangeListenerKey);\r\n            }\r\n            self._offsetChangeListenerKey = ol.events.listen(\r\n                popup, 'change:offset',\r\n                popup._newHandleOffsetChanged, popup);\r\n        }\r\n        //view.on(['change:center','change:resolution'], onViewChange);\r\n    }\r\n    else {\r\n        // Redefinimos las propiedades de posicionamiento porque al arrastrarlo, las hemos modificado.\r\n        const containerStyle = popup.getElement().parentElement.style;\r\n        // Estas dos líneas siguientes se aplicaban con la versión 6.12 de ol.Overlay.prototype.updateRenderedPosition\r\n        //containerStyle.removeProperty('left');\r\n        //containerStyle.removeProperty('top');\r\n        // Estas cuatro líneas siguientes se aplican con la versión 5.33 de ol.Overlay.prototype.updateRenderedPosition\r\n        containerStyle.setProperty('top', popup.rendered.top_);\r\n        containerStyle.setProperty('bottom', popup.rendered.bottom_);\r\n        containerStyle.setProperty('left', popup.rendered.left_);\r\n        containerStyle.setProperty('right', popup.rendered.right_);\r\n\r\n        delete self.parent._previousContainerPosition;\r\n        // Deshacemos parcheo\r\n        if (popup._oldUpdatePixelPosition) {\r\n            popup.updatePixelPosition = popup._oldUpdatePixelPosition;\r\n            delete popup._oldUpdatePixelPosition;\r\n        }\r\n        if (popup._newHandleOffsetChanged) {\r\n            if (self._offsetChangeListenerKey) {\r\n                ol.events.unlistenByKey(self._offsetChangeListenerKey);\r\n            }\r\n            self._offsetChangeListenerKey = ol.events.listen(\r\n                popup, 'change:offset',\r\n                popup.handleOffsetChanged, popup);\r\n            delete popup._newHandleOffsetChanged;\r\n        }\r\n        //view.un(['change:center', 'change:resolution'], onViewChange);\r\n    }\r\n};\r\n\r\nTC.wrap.Feature.prototype.getLegend = function () {\r\n    var self = this;\r\n    var result = {\r\n    };\r\n    var style = getNativeFeatureStyle(self.feature, true);\r\n    if (style) {\r\n        var image = style.getImage();\r\n        if (image) {\r\n            if (image instanceof ol.style.Icon) {\r\n                result.src = image.getSrc();\r\n                var scale = image.getScale();\r\n                var img = image.getImage();\r\n                if (scale) {\r\n                    if (img.width) {\r\n                        result.width = img.width * scale;\r\n                        result.height = img.height * scale;\r\n                    }\r\n                    else {\r\n                        result.scale = scale;\r\n                    }\r\n                }\r\n                else {\r\n                    if (img.width) {\r\n                        result.width = img.width;\r\n                        result.height = img.height;\r\n                    }\r\n                }\r\n            }\r\n            else if (image instanceof ol.style.Circle) {\r\n                result.src = image.getImage().toDataURL();\r\n            }\r\n            if (self.parent.options.radius) {\r\n                result.height = result.width = self.parent.options.radius * 2;\r\n            }\r\n            else {\r\n                result.width = result.width || self.parent.options.width;\r\n                result.height = result.height || self.parent.options.height;\r\n            }\r\n        }\r\n        else {\r\n            let geometryType;\r\n            switch (self.feature.getGeometry().getType()) {\r\n                case ol.geom.GeometryType.MULTI_POLYGON:\r\n                case ol.geom.GeometryType.POLYGON:\r\n                    geometryType = TC.Consts.geom.POLYGON;\r\n                    break;\r\n                case ol.geom.GeometryType.MULTI_LINE_STRING:\r\n                case ol.geom.GeometryType.LINE_STRING:\r\n                    geometryType = TC.Consts.geom.POLYLINE;\r\n                    break;\r\n                default:\r\n                    geometryType = TC.Consts.geom.POINT;\r\n                    break;\r\n            }\r\n\r\n            result.src = TC.Util.getLegendImageFromStyle(getStyleFromNative(style), { geometryType: geometryType });\r\n            // No image, find stroke and fill\r\n            //var stroke = style.getStroke();\r\n            //var fill = style.getFill();\r\n            //if (stroke) {\r\n            //    var strokeColor = stroke.getColor();\r\n            //    if (strokeColor) {\r\n            //        result.strokeColor = ol.color.asString(strokeColor);\r\n            //    }\r\n            //    var strokeWidth = stroke.getWidth();\r\n            //    if (strokeWidth) {\r\n            //        result.strokeWidth = strokeWidth;\r\n            //    }\r\n            //}\r\n            //if (fill) {\r\n            //    var fillColor = fill.getColor();\r\n            //    if (fillColor) {\r\n            //        result.fillColor = ol.color.asString(fillColor);\r\n            //    }\r\n            //}\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nconst createFeatureBasics = function (coords, options) {\r\n    const self = this;\r\n    self.feature = new ol.Feature();\r\n    if (self.parent.id) {\r\n        self.feature.setId(self.parent.id);\r\n    }\r\n    if (options.geometryName) {\r\n        self.feature.setGeometryName(options.geometryName);\r\n    }\r\n    self.feature._wrap = self;\r\n    self.parent.setCoords(coords);\r\n    self.parent.setData(self.parent.data);\r\n};\r\n\r\nTC.wrap.Feature.prototype.createPoint = function (coords, options) {\r\n    const self = this;\r\n    options = options || {};\r\n    createFeatureBasics.call(self, coords, options);\r\n    if (TC.Util.hasStyleOptions(options)) {\r\n        self.feature.setStyle(createNativeStyle({ styles: { point: options } }, self.feature));\r\n    }\r\n};\r\n\r\nTC.wrap.Feature.prototype.createMultiPoint = function (coords, options) {\r\n    const self = this;\r\n    options = options || {};\r\n    createFeatureBasics.call(self, coords, options);\r\n    if (TC.Util.hasStyleOptions(options)) {\r\n        self.feature.setStyle(createNativeStyle({ styles: { point: options } }, self.feature));\r\n    }\r\n};\r\n\r\nTC.wrap.Feature.prototype.createMarker = function (coords, options) {\r\n    const self = this;\r\n    options = options || {};\r\n    var iconUrl = TC.Util.getPointIconUrl(options);\r\n    if (iconUrl) {\r\n        options.url = iconUrl;\r\n        createFeatureBasics.call(self, coords, options);\r\n        if (TC.Util.hasStyleOptions(options)) {\r\n            self.feature.setStyle(createNativeStyle({ styles: { marker: options } }, self.feature));\r\n        }\r\n    }\r\n    else {\r\n        self.createPoint(coords, options);\r\n    }\r\n};\r\n\r\nTC.wrap.Feature.prototype.createMultiMarker = function (coords, options) {\r\n    const self = this;\r\n    options = options || {};\r\n    var iconUrl = TC.Util.getPointIconUrl(options);\r\n    if (iconUrl) {\r\n        options.url = iconUrl;\r\n        createFeatureBasics.call(self, coords, options);\r\n        if (TC.Util.hasStyleOptions(options)) {\r\n            self.feature.setStyle(createNativeStyle({ styles: { marker: options } }, self.feature));\r\n        }\r\n    }\r\n    else {\r\n        self.createMultiPoint(coords, options);\r\n    }\r\n};\r\n\r\nTC.wrap.Feature.prototype.createPolyline = function (coords, options) {\r\n    const self = this;\r\n    options = options || {};\r\n    createFeatureBasics.call(self, coords, options);\r\n    if (TC.Util.hasStyleOptions(options)) {\r\n        self.feature.setStyle(createNativeStyle({ styles: { line: options } }, self.feature));\r\n    }\r\n};\r\n\r\nTC.wrap.Feature.prototype.createPolygon = function (coords, options) {\r\n    const self = this;\r\n    options = options || {};\r\n    createFeatureBasics.call(self, coords, options);\r\n    if (TC.Util.hasStyleOptions(options)) {\r\n        self.feature.setStyle(createNativeStyle({ styles: { polygon: options } }, self.feature));\r\n    }\r\n};\r\n\r\n\r\nTC.wrap.Feature.prototype.createMultiPolyline = function (coords, options) {\r\n    const self = this;\r\n    options = options || {};\r\n    createFeatureBasics.call(self, coords, options);\r\n    if (TC.Util.hasStyleOptions(options)) {\r\n        self.feature.setStyle(createNativeStyle({ styles: { line: options } }, self.feature));\r\n    }\r\n};\r\n\r\nTC.wrap.Feature.prototype.createMultiPolygon = function (coords, options) {\r\n    const self = this;\r\n    options = options || {};\r\n    createFeatureBasics.call(self, coords, options);\r\n    if (TC.Util.hasStyleOptions(options)) {\r\n        self.feature.setStyle(createNativeStyle({ styles: { polygon: options } }, self.feature));\r\n    }\r\n};\r\n\r\nTC.wrap.Feature.prototype.createCircle = function (coords, options) {\r\n    const self = this;\r\n    options = options || {};\r\n    createFeatureBasics.call(self, coords, options);\r\n    if (options) {\r\n        self.feature.setStyle(\r\n            new ol.style.Style({\r\n                stroke: new ol.style.Stroke({\r\n                    color: options.strokeColor,\r\n                    width: options.strokeWidth,\r\n                    lineDash: options.lineDash\r\n                }),\r\n                fill: new ol.style.Fill({\r\n                    color: getRGBA(options.fillColor, options.fillOpacity)\r\n                })\r\n            })\r\n        );\r\n    }\r\n};\r\n\r\nTC.wrap.Feature.createFeature = function (olFeat, options) {\r\n    if (!olFeat._featurePromise) {\r\n        olFeat._featurePromise = new Promise(function (resolve, _reject) {\r\n            var olGeometry = olFeat.getGeometry();\r\n            options = options || {};\r\n            options.id = olFeat.getId();\r\n            let olStyle = olFeat.getStyle();\r\n            if (olStyle) {\r\n                TC.Util.extend(options, getStyleFromNative(olStyle, olFeat));\r\n            }\r\n            // geometría\r\n            let geomStr;\r\n            switch (true) {\r\n                case olGeometry instanceof ol.geom.Point:\r\n                case olGeometry instanceof ol.geom.MultiPoint:\r\n                    if (TC.Util.isFunction(olStyle)) {\r\n                        olStyle = olStyle(olFeat);\r\n                    }\r\n                    var olStyles = olStyle ?\r\n                        Array.isArray(olStyle) ? olStyle : [olStyle] :\r\n                        [];\r\n                    for (var i = 0, len = olStyles.length; i < len; i++) {\r\n                        olStyle = olStyles[i];\r\n                        if (olStyle.getImage() instanceof ol.style.Icon) {\r\n                            geomStr = 'Marker';\r\n                            break;\r\n                        }\r\n                    }\r\n                    geomStr = geomStr || 'Point';\r\n                    if (olGeometry instanceof ol.geom.MultiPoint) {\r\n                        if (geomStr === 'Point') {\r\n                            geomStr = 'MultiPoint';\r\n                        }\r\n                        if (geomStr === 'Marker') {\r\n                            geomStr = 'MultiMarker';\r\n                        }\r\n                    }\r\n                    break;\r\n                case olGeometry instanceof ol.geom.LineString:\r\n                    geomStr = 'Polyline';\r\n                    break;\r\n                case olGeometry instanceof ol.geom.Polygon:\r\n                    geomStr = 'Polygon';\r\n                    break;\r\n                case olGeometry instanceof ol.geom.MultiLineString:\r\n                    geomStr = 'MultiPolyline';\r\n                    break;\r\n                case olGeometry instanceof ol.geom.MultiPolygon:\r\n                    geomStr = 'MultiPolygon';\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            let feat;\r\n            if (geomStr) {\r\n                feat = new TC.feature[geomStr](olFeat, options);\r\n            }\r\n            else {\r\n                feat = new TC.Feature(olFeat, options);\r\n            }\r\n            feat.data = feat.wrap.getData();\r\n            resolve(feat);\r\n        });\r\n    }\r\n    return olFeat._featurePromise;\r\n};\r\n\r\nTC.wrap.Feature.prototype.cloneFeature = function () {\r\n    return this.feature.clone();\r\n};\r\n\r\nTC.wrap.Feature.prototype.getStyle = function () {\r\n    var self = this;\r\n    var result = {};\r\n    var olStyle = self.feature.getStyle();\r\n    if (TC.Util.isFunction(olStyle)) {\r\n        olStyle = olStyle(self.feature);\r\n    }\r\n    var olStyles = olStyle ?\r\n        Array.isArray(olStyle) ? olStyle : [olStyle] :\r\n        [];\r\n\r\n    const getFill = function (style, obj) {\r\n        if (style) {\r\n            const fill = style.getFill();\r\n            if (fill) {\r\n                obj.fillColor = fill.getColor();\r\n                if (Array.isArray(obj.fillColor)) {\r\n                    obj.fillOpacity = obj.fillColor[3];\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const getStroke = function (style, obj) {\r\n        if (style) {\r\n            const stroke = style.getStroke();\r\n            if (stroke) {\r\n                obj.strokeColor = stroke.getColor();\r\n                obj.strokeWidth = stroke.getWidth();\r\n            }\r\n        }\r\n    };\r\n\r\n    for (var i = 0, len = olStyles.length; i < len; i++) {\r\n        olStyle = olStyles[i];\r\n        getFill(olStyle, result);\r\n        getStroke(olStyle, result);\r\n        const image = olStyle.getImage();\r\n        if (image instanceof ol.style.Icon) {\r\n            result.url = image.getSrc();\r\n            const size = image.getSize();\r\n            const scale = image.getScale() || 1;\r\n            if (size) {\r\n                result.width = size[0] * scale;\r\n                result.height = size[1] * scale;\r\n            }\r\n            //10/11/2021 URI: ncluir la rotacion de los icono que venga presumiblemente de un KML\r\n            //pasamos la rotacion a grados para que sea mas escueta que en radianes\r\n            const rotation = image.getRotation();\r\n\r\n            if (rotation) {\r\n                result.rotation = 180 * rotation / Math.PI;\r\n            }\r\n            var anchor = image.getAnchor();\r\n            if (anchor) {\r\n                result.anchor = [anchor[0] * scale, anchor[1] * scale];\r\n                if (size) {\r\n                    // getAnchor devuelve los valores en pixels, hay que transformar a fracción\r\n                    result.anchor[0] = result.anchor[0] / result.width;\r\n                    result.anchor[1] = result.anchor[1] / result.height;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            getFill(image, result);\r\n            getStroke(image, result);\r\n        }\r\n        var text = olStyle.getText();\r\n        if (text) {\r\n            result.label = text.getText();\r\n            var font = text.getFont();\r\n            if (font) {\r\n                // A 96dpi 3pt = 4px\r\n                result.fontSize = parseInt(font.match(/\\d+pt/)) || parseInt(font.match(/\\d+px/)) * 0.75;\r\n                result.font = font;\r\n            }\r\n            var rotation = text.getRotation();\r\n            if (rotation) {\r\n                result.angle = -180 * rotation / Math.PI;\r\n            }\r\n            //09/11/2021 URI: No se está replicando la escala de los labels\r\n            var textScale = text.getScale();\r\n            if (textScale) {\r\n                result.textScale = textScale;\r\n            }\r\n            //09/11/2021 URI: No se está replicando la alineacion de los labels\r\n            var textAlign = text.getTextAlign();\r\n            if (textAlign) {\r\n                result.textAlign = textAlign;\r\n            }\r\n            result.labelOffset = [text.getOffsetX(), text.getOffsetY()];\r\n            var fill = text.getFill();\r\n            if (fill) {\r\n                result.fontColor = fill.getColor();\r\n            }\r\n            var stroke = text.getStroke();\r\n            if (stroke) {\r\n                result.labelOutlineColor = stroke.getColor();\r\n                result.labelOutlineWidth = stroke.getWidth();\r\n            }\r\n        }\r\n        //09/11/2021 URI: Añadimos el estilo de los globos de aquella features que vengan de un KML \r\n        if (olStyle._balloon && olStyle._balloon.getText())\r\n            result.balloon = olStyle._balloon.getText();\r\n    }\r\n    TC.Util.extend(self.parent.options, result);\r\n    return result;\r\n};\r\n\r\nTC.wrap.Feature.prototype.getGeometry = function () {\r\n    var result;\r\n    var self = this;\r\n    if (self.feature && self.feature.getGeometry) {\r\n        var geom = self.feature.getGeometry();\r\n        if (geom) {\r\n            if (geom.getCoordinates) {\r\n                result = geom.getCoordinates();\r\n            }\r\n            else if (geom instanceof ol.geom.Circle) {\r\n                result = [geom.getCenter(), geom.getRadius()];\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.Feature.prototype.setGeometry = function (geometry) {\r\n    const self = this;\r\n    if (self.feature && self.feature.getGeometry) {\r\n        var geom = self.feature.getGeometry();\r\n        var ctor;\r\n        var point,\r\n            points,\r\n            ringsOrPolylines,\r\n            polygons,\r\n            isMultiPolygon,\r\n            isPolygonOrMultiLineString,\r\n            isLineString;\r\n        // punto: array de números\r\n        // línea o anillo: array de puntos\r\n        // multilínea o polígono: array de líneas o anillos\r\n        // multipolígono: array de polígonos\r\n        // Por tanto podemos recorrer los tipos en un switch sin breaks\r\n        switch (true) {\r\n            case TC.feature.MultiPolygon && self.parent instanceof TC.feature.MultiPolygon:\r\n                isMultiPolygon = true;\r\n                ctor = ol.geom.MultiPolygon;\r\n                polygons = geometry;\r\n                if (Array.isArray(polygons)) {\r\n                    ringsOrPolylines = geometry[0];\r\n                }\r\n            case TC.feature.Polygon && self.parent instanceof TC.feature.Polygon || TC.feature.MultiPolyline && self.parent instanceof TC.feature.MultiPolyline:\r\n                isPolygonOrMultiLineString = true;\r\n                ctor = ctor || ((TC.feature.Polygon && self.parent instanceof TC.feature.Polygon) ? ol.geom.Polygon : ol.geom.MultiLineString);\r\n                ringsOrPolylines = isMultiPolygon ? ringsOrPolylines : geometry;\r\n                if (Array.isArray(ringsOrPolylines)) {\r\n                    points = ringsOrPolylines[0];\r\n                }\r\n            case TC.feature.Polyline && self.parent instanceof TC.feature.Polyline || TC.feature.MultiPoint && self.parent instanceof TC.feature.MultiPoint:\r\n                isLineString = true;\r\n                ctor = ctor || ((TC.feature.Polyline && self.parent instanceof TC.feature.Polyline) ? ol.geom.LineString : ol.geom.MultiPoint);\r\n                points = isPolygonOrMultiLineString ? points : geometry;\r\n                if (Array.isArray(points)) {\r\n                    point = points[0];\r\n                }\r\n            case TC.feature.Point && self.parent instanceof TC.feature.Point:\r\n                ctor = ctor || ol.geom.Point;\r\n                point = isLineString ? point : geometry;\r\n                if (Array.isArray(point) && typeof point[0] === 'number' && typeof point[1] === 'number') {\r\n                    let layout;\r\n                    switch (point.length) {\r\n                        case 3:\r\n                            layout = ol.geom.GeometryLayout.XYZ;\r\n                            break;\r\n                        case 4:\r\n                            layout = ol.geom.GeometryLayout.XYZM;\r\n                            break;\r\n                        default:\r\n                            layout = ol.geom.GeometryLayout.XY;\r\n                            break;\r\n                    }\r\n                    if (geom) {\r\n                        geom.setCoordinates(geometry, layout);\r\n                    }\r\n                    else {\r\n                        geom = new ctor(geometry, layout);\r\n                        self.feature.setGeometry(geom);\r\n                    }\r\n                }\r\n                break;\r\n            case TC.feature.Circle && self.parent instanceof TC.feature.Circle:\r\n                if (Array.isArray(geometry) &&\r\n                    Array.isArray(geometry[0])\r\n                    && typeof geometry[0][0] === 'number' && typeof geometry[0][1] === 'number'\r\n                    && typeof geometry[1] === 'number') {\r\n                    let layout;\r\n                    switch (geometry[0].length) {\r\n                        case 3:\r\n                            layout = ol.geom.GeometryLayout.XYZ;\r\n                            break;\r\n                        case 4:\r\n                            layout = ol.geom.GeometryLayout.XYZM;\r\n                            break;\r\n                        default:\r\n                            layout = ol.geom.GeometryLayout.XY;\r\n                            break;\r\n                    }\r\n                    if (geom) {\r\n                        geom.setCenterAndRadius(geometry[0], geometry[1], layout);\r\n                    }\r\n                    else {\r\n                        geom = new ol.geom.Circle(geometry[0], geometry[1], layout);\r\n                        self.feature.setGeometry(geom);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n};\r\n\r\nTC.wrap.Feature.prototype.getId = function () {\r\n    var result;\r\n    var self = this;\r\n    if (self.feature) {\r\n        result = self.feature.getId();\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.Feature.prototype.setId = function (id) {\r\n    var self = this;\r\n    if (self.feature) {\r\n        self.feature.setId(id);\r\n    }\r\n};\r\n\r\nconst getPolygonLength = function (polygon, options) {\r\n    const self = this;\r\n    var result = 0;\r\n    polygon.getLinearRings().forEach(function (ring) {\r\n        let coordinates = ring.getCoordinates();\r\n        if (options.crs) {\r\n            coordinates = TC.Util.reproject(coordinates, self.parent.layer.map.crs, options.crs);\r\n        }\r\n        const polygon = new ol.geom.Polygon([coordinates]);\r\n        const newRing = polygon.getLinearRing(0);\r\n        result = result + ol.geom.flat.linearRingLength(newRing.flatCoordinates, 0, newRing.flatCoordinates.length, newRing.stride);\r\n    });\r\n    return result;\r\n};\r\n\r\nconst getLineStringLength = function (lineString, options) {\r\n    const self = this;\r\n    let coordinates = lineString.getCoordinates();\r\n    if (options.crs) {\r\n        coordinates = TC.Util.reproject(coordinates, self.parent.layer.map.crs, options.crs);\r\n    }\r\n    const line = new ol.geom.LineString(coordinates);\r\n    return line.getLength();\r\n};\r\n\r\nTC.wrap.Feature.prototype.getLength = function (options) {\r\n    const self = this;\r\n    options = options || {};\r\n    var result = 0;\r\n\r\n    const geom = self.feature.getGeometry();\r\n    switch (true) {\r\n        case geom instanceof ol.geom.Polygon:\r\n            result = getPolygonLength.call(self, geom, options);\r\n            break;\r\n        case geom instanceof ol.geom.LineString:\r\n            result = getLineStringLength.call(self, geom, options);\r\n            break;\r\n        case geom instanceof ol.geom.MultiPolygon:\r\n            geom.getPolygons().forEach(function (polygon) {\r\n                result = result + getPolygonLength.call(self, polygon, options);\r\n            });\r\n            break;\r\n        case geom instanceof ol.geom.MultiLineString:\r\n            geom.getLineStrings().forEach(function (lineString) {\r\n                result = result + getLineStringLength.call(self, lineString, options);\r\n            });\r\n            break;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nTC.wrap.Feature.prototype.getArea = function (options) {\r\n    const self = this;\r\n    options = options || {};\r\n\r\n    const geom = self.feature.getGeometry();\r\n    var coordinates;\r\n    if (geom instanceof ol.geom.Polygon) {\r\n        coordinates = geom.getLinearRing(0).getCoordinates();\r\n        if (options.crs) {\r\n            coordinates = TC.Util.reproject(coordinates, self.parent.layer.map.crs, options.crs);\r\n        }\r\n        const polygon = new ol.geom.Polygon([coordinates]);\r\n        return polygon.getArea();\r\n    }\r\n};\r\n\r\nconst getNativeFeatureStyle = function (feature, readonly) {\r\n    var style = feature.getStyle();\r\n    if (TC.Util.isFunction(style)) {\r\n        style = style(feature);\r\n    }\r\n    if (Array.isArray(style)) {\r\n        style = style.reduce(function (extendedStyle, currentStyle) {\r\n            extendedStyle.fill_ = currentStyle.fill_ || extendedStyle.fill_;\r\n            extendedStyle.image_ = currentStyle.image_ || extendedStyle.image_;\r\n            extendedStyle.stroke_ = currentStyle.stroke_ || extendedStyle.stroke_;\r\n            extendedStyle.text_ = currentStyle.text_ || extendedStyle.text_;\r\n            return extendedStyle;\r\n        }, new ol.style.Style());\r\n    }\r\n    if (!style && !readonly) {\r\n        style = new ol.style.Style();\r\n        feature.setStyle(style);\r\n    }\r\n    return style;\r\n};\r\n\r\nconst getNativeLayerStyle = function (feature) {\r\n    var style = this.getStyle();\r\n    if (TC.Util.isFunction(style)) {\r\n        style = style(feature);\r\n    }\r\n    if (Array.isArray(style)) {\r\n        style = style[style.length - 1];\r\n    }\r\n    if (!style) {\r\n        style = new ol.style.Style();\r\n    }\r\n    return style;\r\n};\r\n\r\nTC.wrap.Feature.prototype.setStyle = function (options) {\r\n    const self = this;\r\n    const olFeat = self.feature;\r\n    if (options === null) {\r\n        olFeat.setStyle(null);\r\n        return;\r\n    }\r\n    const feature = self.parent;\r\n    const geom = olFeat.getGeometry();\r\n    let newStyle = olFeat.getStyle();\r\n    let layerStyle;\r\n    if (feature.layer) {\r\n        layerStyle = getNativeLayerStyle.call(feature.layer.wrap.layer, feature.wrap.feature);\r\n    }\r\n    if (!newStyle) {\r\n        if (layerStyle) {\r\n            newStyle = layerStyle.clone();\r\n        }\r\n        else {\r\n            newStyle = new ol.style.Style();\r\n        }\r\n    }\r\n    if (TC.Util.isFunction(newStyle)) {\r\n        newStyle = newStyle(olFeat);\r\n    }\r\n    if (!Array.isArray(newStyle)) {\r\n        newStyle = [newStyle];\r\n    }\r\n    let style = newStyle[newStyle.length - 1];\r\n    if (geom instanceof ol.geom.Point || geom instanceof ol.geom.MultiPoint) {\r\n\r\n        var imageStyle;\r\n        if (options.anchor || options.url || options.cssClass) { // Marcador\r\n            imageStyle = style.getImage();\r\n            const iconOptions = {};\r\n            if (imageStyle instanceof ol.style.Icon) {\r\n                iconOptions.src = options.url || TC.Util.getBackgroundUrlFromCss(options.cssClass) || imageStyle.getSrc();\r\n\r\n                if (options.width && options.height) {\r\n                    iconOptions.size = [getStyleValue(options.width, feature), getStyleValue(options.height, feature)];\r\n                }\r\n                else {\r\n                    iconOptions.size = imageStyle.getSize();\r\n                }\r\n                iconOptions.anchor = getStyleValue(options.anchor, feature);\r\n                if (!iconOptions.anchor) {\r\n                    const imgAnchor = imageStyle.getAnchor();\r\n                    if (Array.isArray(imgAnchor)) {\r\n                        iconOptions.anchor = imgAnchor.map(function (elm, idx) {\r\n                            return elm / iconOptions.size[idx];\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                iconOptions.src = TC.Util.getPointIconUrl(options);\r\n                iconOptions.anchor = getStyleValue(options.anchor, feature);\r\n                iconOptions.size = [getStyleValue(options.width, feature), getStyleValue(options.height, feature)];\r\n            }\r\n            if (options.angle) {\r\n                iconOptions.angle = options.angle;\r\n            }\r\n\r\n            imageStyle = new ol.style.Icon(iconOptions);\r\n        }\r\n        else if (!style.getImage() && style.getText()) { // Etiqueta\r\n\r\n            if (options.label !== undefined) {\r\n                if (options.label.length) {\r\n                    style.setText(createNativeTextStyle(options, feature));\r\n                }\r\n                else {\r\n                    style.setText();\r\n                }\r\n            } else {\r\n                style.setText();\r\n            }\r\n        }\r\n        else { // Punto sin icono\r\n            imageStyle = style.getImage();\r\n            if (!imageStyle) {\r\n                imageStyle = new ol.style.Circle();\r\n            }\r\n            const circleOptions = {\r\n                radius: getStyleValue(options.radius, feature) ||\r\n                    (getStyleValue(options.height, feature) + getStyleValue(options.width, feature)) / 4\r\n            };\r\n            if (isNaN(circleOptions.radius) && imageStyle.getRadius) {\r\n                circleOptions.radius = imageStyle.getRadius();\r\n            }\r\n            if (imageStyle.getFill) {\r\n                const fill = imageStyle.getFill();\r\n                const previousColor = fill.getColor();\r\n                const previousOpacity = Array.isArray(previousColor) ? previousColor[3] : 1;\r\n                fill.setColor(getRGBA(getStyleValue(options.fillColor || previousColor, feature), getStyleValue(options.fillOpacity || previousOpacity, feature)));\r\n                circleOptions.fill = fill;\r\n            }\r\n            circleOptions.stroke = imageStyle.getStroke ? imageStyle.getStroke() : new ol.style.Stroke();\r\n            const layerStroke = layerStyle && layerStyle.getStroke();\r\n            if (options.strokeColor || options.strokeWidth) {\r\n                if (!circleOptions.stroke) {\r\n                    circleOptions.stroke = new ol.style.Stroke();\r\n                }\r\n                if (options.strokeColor) {\r\n                    circleOptions.stroke.setColor(getStyleValue(options.strokeColor, feature));\r\n                }\r\n                else {\r\n                    const strokeColor = circleOptions.stroke.getColor() || (layerStroke && layerStroke.getColor() || TC.Cfg.styles.point.strokeColor);\r\n                    circleOptions.stroke.setColor(getStyleValue(strokeColor, feature));\r\n                }\r\n                if (options.strokeWidth) {\r\n                    circleOptions.stroke.setWidth(getStyleValue(options.strokeWidth, feature));\r\n                }\r\n                else {\r\n                    const strokeWidth = circleOptions.stroke.getWidth() || (layerStroke && layerStroke.getWidth() || TC.Cfg.styles.point.strokeWidth);\r\n                    circleOptions.stroke.setWidth(getStyleValue(strokeWidth, feature));\r\n                }\r\n            }\r\n            imageStyle = new ol.style.Circle(circleOptions);\r\n        }\r\n        style.setImage(imageStyle);\r\n    }\r\n    else {\r\n        var stroke = style.getStroke();\r\n        var strokeChanged = false;\r\n        if (!stroke) {\r\n            stroke = new ol.style.Stroke();\r\n        }\r\n        if (options.strokeColor) {\r\n            stroke.setColor(getStyleValue(options.strokeColor, feature));\r\n            strokeChanged = true;\r\n        }\r\n        if (options.strokeWidth) {\r\n            stroke.setWidth(getStyleValue(options.strokeWidth, feature));\r\n            strokeChanged = true;\r\n        }\r\n        if (options.lineDash) {\r\n            stroke.setLineDash(options.lineDash);\r\n            strokeChanged = true;\r\n        }\r\n        if (strokeChanged) {\r\n            style.setStroke(stroke);\r\n        }\r\n        if (geom instanceof ol.geom.Polygon || geom instanceof ol.geom.MultiPolygon) {\r\n            if (options.fillColor || options.fillOpacity) {\r\n                var fill = style.getFill() || new ol.style.Fill();\r\n                const previousColor = fill.getColor();\r\n                const previousOpacity = Array.isArray(previousColor) ? previousColor[3] : 1;\r\n                fill.setColor(getRGBA(getStyleValue(options.fillColor || previousColor, feature), getStyleValue(options.fillOpacity || previousOpacity, feature)));\r\n                style.setFill(fill);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (options.label !== undefined) {\r\n        if (options.label.length) {\r\n            style.setText(createNativeTextStyle(options, feature));\r\n        }\r\n        else {\r\n            style.setText();\r\n        }\r\n    }\r\n    olFeat.setStyle(newStyle);\r\n    olFeat.changed();\r\n};\r\n\r\nTC.wrap.Feature.prototype.toggleSelectedStyle = function (condition) {\r\n    const self = this;\r\n    const feature = self.feature;\r\n    const setStyle = condition === undefined ? !feature._originalStyle : condition;\r\n    if (setStyle) {\r\n        setSelectedStyle(feature);\r\n    }\r\n    else {\r\n        removeSelectedStyle(feature);\r\n    }\r\n};\r\n\r\nTC.wrap.Feature.prototype.getInnerPoint = function (options) {\r\n    var result;\r\n    var opts = options || {};\r\n    // Funciones para hacer clipping con el extent actual. Así nos aseguramos de que el popup sale en un punto visible actualmente.\r\n    var feature = this.feature;\r\n    var geometry = feature.getGeometry();\r\n\r\n    let coords;\r\n    let clipped = false;\r\n    result = geometry.getFirstCoordinate();\r\n    switch (geometry.getType()) {\r\n        case ol.geom.GeometryType.MULTI_POLYGON:\r\n            if (opts.clipBox) {\r\n                geometry = new ol.geom.MultiPolygon(geometry\r\n                    .getPolygons()\r\n                    .map(pol => TC.Geometry.clipPolygon(pol.getCoordinates(), opts.clipBox))\r\n                    .filter(pol => pol.length));\r\n                clipped = true;\r\n            }\r\n            var area = 0;\r\n            geometry = geometry.getPolygons().reduce(function (prev, cur) {\r\n                const curArea = cur.getArea();\r\n                const result = curArea > area ? cur : prev;\r\n                area = curArea;\r\n                return result;\r\n            });\r\n        case ol.geom.GeometryType.POLYGON:\r\n            coords = geometry.getCoordinates();\r\n            if (opts.clipBox && !clipped) {\r\n                coords = TC.Geometry.clipPolygon(coords, opts.clipBox);\r\n            }\r\n            geometry = new ol.geom.Polygon(coords);\r\n            result = geometry.getInteriorPoint().getCoordinates();\r\n            var rings = geometry.getLinearRings();\r\n            // Miramos si el punto está dentro de un agujero\r\n            for (var i = 1; i < rings.length; i++) {\r\n                if (TC.Geometry.isInside(result, rings[i].getCoordinates())) {\r\n                    result = geometry.getClosestPoint(result);\r\n                    break;\r\n                }\r\n            }\r\n            break;\r\n        case ol.geom.GeometryType.MULTI_LINE_STRING:\r\n            if (opts.clipBox) {\r\n                geometry = new ol.geom.MultiLineString(geometry\r\n                    .getLineStrings()\r\n                    .map(ls => TC.Geometry.clipPolyline(ls.getCoordinates(), opts.clipBox))\r\n                    .filter(ls => ls.length));\r\n                clipped = true;\r\n            }\r\n            var length = 0;\r\n            geometry = geometry.getLineStrings().reduce(function (prev, cur) {\r\n                const curLength = cur.getLength();\r\n                const result = curLength > length ? cur : prev;\r\n                length = curLength;\r\n                return result;\r\n            });\r\n        case ol.geom.GeometryType.LINE_STRING:\r\n            var centroid = [0, 0];\r\n            coords = geometry.getCoordinates();\r\n            if (opts.clipBox && !clipped) {\r\n                coords = TC.Geometry.clipPolyline(coords, opts.clipBox);\r\n            }\r\n            geometry = new ol.geom.LineString(coords);\r\n            for (var i = 0; i < coords.length; i++) {\r\n                centroid[0] += coords[i][0];\r\n                centroid[1] += coords[i][1];\r\n            }\r\n            centroid[0] /= coords.length;\r\n            centroid[1] /= coords.length;\r\n            result = geometry.getClosestPoint(centroid);\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.Feature.prototype.showPopup = function (options) {\r\n    const self = this;\r\n    options = options || {};\r\n    const popupCtl = options && options instanceof TC.Control ? options : options.control;\r\n    var map = popupCtl.map;\r\n    if (map) {\r\n        var feature = self.feature;\r\n        if (feature) {\r\n            map.currentFeature = self.parent;\r\n            var currentExtent = map.getExtent();\r\n\r\n            self._innerCentroid = self.getInnerPoint({ clipBox: currentExtent });\r\n\r\n            popupCtl.contentDiv.innerHTML = options.html || self.parent.getInfo({ locale: map.options.locale });\r\n\r\n            var parentOptions = self.parent.options;\r\n            if (TC.Util.isEmptyObject(parentOptions) && self.parent.layer &&\r\n                self.parent.layer.options && self.parent.layer.options.styles) {\r\n\r\n                switch (self.parent.CLASSNAME) {\r\n                    case \"TC.feature.Point\":\r\n                        parentOptions = self.parent.layer.options.styles.point;\r\n\r\n                        // 11/03/2019 Al crear las features del API desde las features nativas, \r\n                        // se valida si la feature tiene icono para definir si es punto o marcador\r\n                        // el problema viene cuando la feature no tiene estilo propio sino que lo obtiene de la capa,\r\n                        // en esos casos se define como punto lo que es un marcador y cuando llegamos aquí no se accede a las\r\n                        // opciones de marcador sino de punto.\r\n                        if (!parentOptions || TC.Util.isEmptyObject(parentOptions)) {\r\n                            parentOptions = self.parent.layer.options.styles.marker;\r\n                        }\r\n                        break;\r\n                    case \"TC.feature.Marker\":\r\n                        parentOptions = self.parent.layer.options.styles.marker;\r\n                        break;\r\n                    case \"TC.feature.Circle\":\r\n                        parentOptions = self.parent.layer.options.styles.circle;\r\n                        break;\r\n                    case \"TC.feature.MultiPolygon\":\r\n                    case \"TC.feature.Polygon\":\r\n                        parentOptions = self.parent.layer.options.styles.polygon;\r\n                        break;\r\n                    case \"TC.feature.MultiPolyline\":\r\n                    case \"TC.feature.Polyline\":\r\n                        parentOptions = self.parent.layer.options.styles.line;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Calcular anchor\r\n            var anchor;\r\n            if (parentOptions.anchor) {\r\n                anchor = getStyleValue(parentOptions.anchor, self.parent);\r\n            }\r\n            else {\r\n                var style;\r\n                var f = feature._wrap.parent;\r\n                for (var i = 0; i < map.workLayers.length; i++) {\r\n                    var layer = map.workLayers[i];\r\n                    if (!layer.isRaster()) {\r\n                        if (layer.features.indexOf(f) >= 0) {\r\n                            style = layer.wrap.styleFunction(feature);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (Array.isArray(style)) {\r\n                    const image = style[0].getImage();\r\n                    anchor = !image || image instanceof ol.style.Icon ? [0.5, 0] : [0.5, 0.5];\r\n                }\r\n            }\r\n            const offset = [0, 0];\r\n            if (anchor) {\r\n                if (parentOptions.height) {\r\n                    offset[1] = -(getStyleValue(parentOptions.height, self.parent) || 0) * anchor[1];\r\n                }\r\n                else {\r\n                    var fStyle = getNativeFeatureStyle(feature, true);\r\n                    if (fStyle) {\r\n                        const image = fStyle.getImage();\r\n                        if (image instanceof ol.style.Icon) {\r\n                            const size = image.getImageSize();\r\n                            if (size) {\r\n                                offset[1] = size[1] * -image.getScale();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            popupCtl.wrap.setDragged(false);\r\n            popupCtl.wrap.popup.setOffset(offset);\r\n            popupCtl.wrap.popup.setPosition(self._innerCentroid);\r\n            popupCtl.popupDiv.classList.add(TC.Consts.classes.VISIBLE);\r\n        } else {\r\n            map.wrap.hidePopup(popupCtl);\r\n        }\r\n    }\r\n};\r\n\r\nTC.wrap.Feature.prototype.isNative = function (feature) {\r\n    return feature instanceof ol.Feature;\r\n};\r\n\r\nTC.wrap.Feature.prototype.getPath = function () {\r\n    var result = [];\r\n    var self = this;\r\n    if (self.feature && self.feature._folders) {\r\n        result = self.feature._folders;\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.Feature.prototype.getBounds = function () {\r\n    var result = null;\r\n    var self = this;\r\n    if (self.feature) {\r\n        const geometry = self.feature.getGeometry();\r\n        if (!geometry) return null;\r\n        result = geometry.getExtent();\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.Feature.prototype.getTemplate = function () {\r\n    var result = null;\r\n    var self = this;\r\n    var style = self.feature.getStyle();\r\n    if (TC.Util.isFunction(style)) {\r\n        style = style(self.feature);\r\n    }\r\n    if (style) {\r\n        style = !Array.isArray(style) ? style : style.find(s => s._balloon);\r\n        if (style && style._balloon) {\r\n            result = style._balloon.getText();\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.Feature.prototype.getData = function () {\r\n    var self = this;\r\n    var result = self.feature.getProperties();\r\n    // En caso de clusters\r\n    if (Array.isArray(result.features)) {\r\n        if (result.features.length === 1) {\r\n            result = result.features[0].getProperties();\r\n        }\r\n        else {\r\n            result = result.features.length + ' elementos';\r\n        }\r\n    }\r\n    var geometryName = self.feature.getGeometryName();\r\n    if (result[geometryName]) {\r\n        delete result[geometryName];\r\n    }\r\n    //URI: A aplanamos las posibles geometrías secundarias que puedan tener las features de Inspire\r\n    for (var property in result) {\r\n        if (result[property] && result[property].getType) {\r\n            switch (result[property].getType()) {\r\n                case ol.geom.GeometryType.POINT:\r\n                case ol.geom.GeometryType.MULTI_POINT:\r\n                case ol.geom.GeometryType.POLYGON:\r\n                case ol.geom.GeometryType.MULTI_POLYGON:\r\n                case ol.geom.GeometryType.LINE_STRING:\r\n                case ol.geom.GeometryType.MULTI_LINE_STRING:\r\n                    result[property] = result[property].getCoordinates();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.Feature.prototype.setData = function (data) {\r\n    this.feature.setProperties(data);\r\n};\r\n\r\nTC.wrap.Feature.prototype.unsetData = function (key) {\r\n    const feature = this.feature;\r\n    feature.unset(key);\r\n};\r\n\r\nTC.wrap.Feature.prototype.clearData = function () {\r\n    const feature = this.feature;\r\n    const geometryName = feature.getGeometryName();\r\n    feature.getKeys().forEach(function (key) {\r\n        if (key !== geometryName) {\r\n            feature.unset(key);\r\n        }\r\n    });\r\n};\r\n\r\nTC.wrap.control.Draw.prototype.mouseMoveHandler = function (_evt) {\r\n    const self = this;\r\n    if (self.sketch) {\r\n        self.parent.trigger(TC.Consts.event.MEASUREPARTIAL, self.getMeasureData());\r\n    }\r\n};\r\n\r\nTC.wrap.control.Draw.prototype.mouseOverHandler = function (_evt) {\r\n    const self = this;\r\n    if (self.sketch && self.hoverCoordinate) {\r\n        self.pushCoordinate(self.hoverCoordinate);\r\n        self.hoverCoordinate = null;\r\n    }\r\n};\r\n\r\nTC.wrap.control.Draw.prototype.clickHandler = function (evt) {\r\n    const self = this;\r\n    if (self.parent.map.view === TC.Consts.view.PRINTING) {\r\n        return;\r\n    }\r\n    if (self._mdPx) { // No operamos si el clic es consecuencia es en realidad un drag\r\n        const dx = self._mdPx[0] - evt.clientX;\r\n        const dy = self._mdPx[1] - evt.clientY;\r\n        if (dx * dx + dy * dy > self.interaction.squaredClickTolerance_) {\r\n            return;\r\n        }\r\n    }\r\n    if (self.sketch) {\r\n        var coords = self.sketch.getGeometry().getCoordinates();\r\n        self.parent.trigger(TC.Consts.event.POINT, {\r\n            point: coords[coords.length - 1]\r\n        });\r\n    }\r\n};\r\n\r\nTC.wrap.control.Draw.prototype.pointerdownHandler = function (evt) {\r\n    const self = this;\r\n    self._mdPx = [evt.clientX, evt.clientY];\r\n};\r\n\r\nTC.wrap.control.Draw.prototype.getMeasureData = function () {\r\n    var self = this;\r\n\r\n    var formatLength = function (line, data) {\r\n        line = new ol.geom.LineString(TC.Util.reproject(line.getCoordinates(), self.parent.map.crs, self.parent.map.options.utmCrs));\r\n        data.length = line.getLength();\r\n    };\r\n\r\n    var formatArea = function (polygon, data) {\r\n        polygon = new ol.geom.Polygon([TC.Util.reproject(polygon.getLinearRing(0).getCoordinates(), self.parent.map.crs, self.parent.map.options.utmCrs)]);\r\n        data.area = polygon.getArea();\r\n        var ring = polygon.getLinearRing(0);\r\n        data.perimeter = ol.geom.flat.linearRingLength(ring.flatCoordinates, 0, ring.flatCoordinates.length, ring.stride);\r\n    };\r\n\r\n    var result = {\r\n        units: ol.proj.Units.METERS\r\n    };\r\n    if (this.sketch) {\r\n        var geom = this.sketch.getGeometry();\r\n        if (geom instanceof ol.geom.Polygon) {\r\n            formatArea(geom, result);\r\n        }\r\n        else if (geom instanceof ol.geom.LineString) {\r\n            formatLength(geom, result);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n// Función para reproyectar el dibujo actual\r\nconst drawProjectionChangeHandler = function (ctl, e) {\r\n    if (ctl.sketch) {\r\n        const oldProj = e.oldValue.getProjection();\r\n        const newProj = e.target.get(e.key).getProjection();\r\n        if (oldProj.getCode() !== newProj.getCode()) {\r\n            const geom = ctl.sketch.getGeometry();\r\n            geom.transform(oldProj, newProj);\r\n            ctl.interaction.sketchPoint_.getGeometry().transform(oldProj, newProj);\r\n            const flatCoordinates = [];\r\n            var sketchCoords;\r\n            if (ctl.parent.mode === TC.Consts.geom.POLYGON) {\r\n                sketchCoords = ctl.interaction.sketchCoords_[0];\r\n            }\r\n            else {\r\n                sketchCoords = ctl.interaction.sketchCoords_;\r\n            }\r\n            ol.geom.flat.deflateCoordinates(flatCoordinates, 0, sketchCoords, geom.stride);\r\n            const transformFn = ol.proj.getTransform(oldProj, newProj);\r\n            transformFn(flatCoordinates, flatCoordinates, geom.stride);\r\n            sketchCoords = ol.geom.flat.inflateCoordinates(flatCoordinates, 0, flatCoordinates.length, geom.stride);\r\n            if (ctl.parent.mode === TC.Consts.geom.POLYGON) {\r\n                ctl.interaction.sketchCoords_ = [sketchCoords];\r\n            }\r\n            else {\r\n                ctl.interaction.sketchCoords_ = sketchCoords;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nconst isLastPoint = (point, coords) => {\r\n    const lastPoint = coords[coords.length - 1];\r\n    return point[0] === lastPoint[0] && point[1] === lastPoint[1];\r\n};\r\n\r\nTC.wrap.control.Draw.prototype.activate = function (mode) {\r\n    var self = this;\r\n\r\n    var type;\r\n    switch (mode) {\r\n        case TC.Consts.geom.POLYGON:\r\n            type = ol.geom.GeometryType.POLYGON;\r\n            break;\r\n        case TC.Consts.geom.MULTIPOLYGON:\r\n            type = ol.geom.GeometryType.MULTI_POLYGON;\r\n            break;\r\n        case TC.Consts.geom.POINT:\r\n            type = ol.geom.GeometryType.POINT;\r\n            break;\r\n        case TC.Consts.geom.MULTIPOINT:\r\n            type = ol.geom.GeometryType.MULTI_POINT;\r\n            break;\r\n        case TC.Consts.geom.MULTIPOLYLINE:\r\n            type = ol.geom.GeometryType.MULTI_LINE_STRING;\r\n            break;\r\n        default:\r\n            type = ol.geom.GeometryType.LINE_STRING;\r\n            break;\r\n    }\r\n    if (self.parent.map) {\r\n        Promise.all([self.parent.map.wrap.getMap(), self.parent.getLayer()]).then(function (objects) {\r\n            const olMap = objects[0];\r\n            const layer = objects[1];\r\n            if (layer) {\r\n                layer.wrap.getLayer().then(function (olLayer) {\r\n\r\n                    if (!self.viewport) self.viewport = olMap.getViewport();\r\n\r\n                    if (self.interaction) {\r\n                        olMap.removeInteraction(self.interaction);\r\n                        if (self._pointerdownHandler) {\r\n                            self.viewport.removeEventListener('pointerdown', self._pointerdownHandler);\r\n                            self._pointerdownHandler = null;\r\n                        }\r\n                        if (self._clickHandler) {\r\n                            self.viewport.removeEventListener('click', self._clickHandler);\r\n                            self._clickHandler = null;\r\n                        }\r\n                        if (self._mouseMoveHandler && self._mouseOverHandler) {\r\n                            self.viewport.removeEventListener(MOUSEMOVE, self._mouseMoveHandler);\r\n                            self.viewport.removeEventListener(MOUSEOVER, self._mouseOverHandler);\r\n                        }\r\n                    }\r\n\r\n                    if (self.snapInteraction) {\r\n                        olMap.removeInteraction(self.snapInteraction);\r\n                    }\r\n\r\n                    if (mode) {\r\n                        self._pointerdownHandler = self.pointerdownHandler.bind(self);\r\n                        self._clickHandler = self.clickHandler.bind(self);\r\n                        self.viewport.addEventListener('pointerdown', self._pointerdownHandler);\r\n                        // No usar TC.Consts.event.CLICK, porque eso en móviles es pointerdown\r\n                        // y salta prematuramente\r\n                        self.viewport.addEventListener('click', self._clickHandler);\r\n                        if (self.parent.measure) {\r\n                            self._mouseMoveHandler = self.mouseMoveHandler.bind(self);\r\n                            self._mouseOverHandler = self.mouseOverHandler.bind(self);\r\n                            self.viewport.addEventListener(MOUSEMOVE, self._mouseMoveHandler);\r\n                            self.viewport.addEventListener(MOUSEOVER, self._mouseOverHandler);\r\n                        }\r\n\r\n                        var drawOptions = {\r\n                            type: type,\r\n                            snapTolerance: 0,\r\n                            condition: function () {\r\n                                if (ol.events.condition.shiftKeyOnly(arguments[0])) {\r\n                                    const hole = olMap.forEachFeatureAtPixel(olMap.getPixelFromCoordinate(arguments[0].coordinate), function (feature) {\r\n                                        if (ol.geom.GeometryType.POLYGON === feature.getGeometry().getType() ||\r\n                                            ol.geom.GeometryType.MULTI_POLYGON === feature.getGeometry().getType()) {\r\n                                            return feature;\r\n                                        }\r\n                                        return null;\r\n                                    },\r\n                                        {\r\n                                            hitTolerance: hitTolerance\r\n                                        });\r\n                                }\r\n\r\n                                if (self.parent.map.view === TC.Consts.view.PRINTING) {\r\n                                    return null;\r\n                                }\r\n\r\n                                return true;\r\n                            }\r\n                        };\r\n                        if (olLayer) {\r\n                            drawOptions.source = olLayer.getSource();\r\n                        }\r\n                        if (mode === TC.Consts.geom.RECTANGLE) {\r\n                            drawOptions.type = ol.geom.GeometryType.LINE_STRING;\r\n                            drawOptions.maxPoints = 2;\r\n                            drawOptions.geometryFunction = function (coordinates, geometry) {\r\n                                const start = coordinates[0];\r\n                                const end = coordinates[1];\r\n                                const newCoords = [[start, [start[0], end[1]], end, [end[0], start[1]], start]];\r\n                                if (geometry) {\r\n                                    geometry.setCoordinates(newCoords);\r\n                                }\r\n                                else {\r\n                                    geometry = new ol.geom.Polygon(newCoords);\r\n                                }\r\n                                return geometry;\r\n                            };\r\n                        }\r\n\r\n                        self.interaction = new ol.interaction.Draw(drawOptions);\r\n\r\n                        self.setStyle();\r\n\r\n                        self.interaction.on('drawstart', function (evt) {\r\n                            let previousFeature;\r\n                            self.sketch = evt.feature;\r\n                            if (self.parent.options.extensible &&\r\n                                !self._extending &&\r\n                                (self.parent.mode === TC.Consts.geom.POLYLINE ||\r\n                                    self.parent.mode === TC.Consts.geom.MULTIPOLYLINE)) {\r\n                                const firstPoint = evt.feature.getGeometry().getCoordinates()[0];\r\n                                previousFeature = self.parent.layer.features\r\n                                    .find(f => isLastPoint(firstPoint, f.getCoordinates()));\r\n                                if (previousFeature) {\r\n                                    self.interaction.abortDrawing();\r\n                                    self._extending = true;\r\n                                    const olFeat = previousFeature.wrap.feature;\r\n                                    // Pasamos el sketch a un estado inicial, como si estuviéramos dibujando nuevo\r\n                                    previousFeature.layer.removeFeature(previousFeature);\r\n                                    self.interaction.extend(olFeat);\r\n                                }\r\n                            }\r\n                            self.parent.trigger(TC.Consts.event.DRAWSTART, { feature: previousFeature });\r\n                        }, this);\r\n\r\n                        self.interaction.on('drawend', function (evt) {\r\n                            delete self._extending;\r\n                            const overlayStyle = evt.target.overlay_.getStyle();\r\n                            if (!evt.feature.getStyle()) {\r\n                                evt.feature.setStyle(Array.isArray(overlayStyle) ? overlayStyle.map(function (style) {\r\n                                    return style.clone();\r\n                                }) : overlayStyle);\r\n                            }\r\n                            if (self.parent.measure) {\r\n                                self.parent.trigger(TC.Consts.event.MEASURE, self.getMeasureData());\r\n                            }\r\n                            TC.wrap.Feature.createFeature(self.sketch).then(function (feat) {\r\n                                const endFn = function () {\r\n                                    self.parent.trigger(TC.Consts.event.DRAWEND, { feature: feat });\r\n                                    self.sketch = null;\r\n                                    self.interaction.setActive(true);\r\n                                };\r\n                                if (self.parent.mode === TC.Consts.geom.RECTANGLE) {\r\n                                    const delay = 400;\r\n                                    const dblClickInteraction = self.interaction\r\n                                        .getMap()\r\n                                        .getInteractions()\r\n                                        .getArray()\r\n                                        .filter(i => i instanceof ol.interaction.DoubleClickZoom)[0];\r\n                                    // Desactivamos temporalmente el zoom por doble clic para evitar que se lance accidentalmente\r\n                                    if (dblClickInteraction && dblClickInteraction.getActive()) {\r\n                                        dblClickInteraction.setActive(false);\r\n                                        setTimeout(function () {\r\n                                            dblClickInteraction.setActive(true);\r\n                                        }, delay);\r\n                                    }\r\n                                    self.interaction.setActive(false);\r\n                                    setTimeout(endFn, delay); // Retardo para evitar pulsaciones accidentales en dobles clics del usuario\r\n                                }\r\n                                else {\r\n                                    endFn();\r\n                                }\r\n                            });\r\n                        }, this);\r\n\r\n                        self._projectionChangeHandler = function (e) {\r\n                            drawProjectionChangeHandler(self, e);\r\n                        };\r\n                        olMap.on('change:view', self._projectionChangeHandler);\r\n\r\n                        olMap.addInteraction(self.interaction);\r\n\r\n                        if (self.parent.options.snapping || self.parent.options.extensible) {\r\n                            var snapOptions = {};\r\n                            if (olLayer) {\r\n                                snapOptions.source = olLayer.getSource();\r\n                            }\r\n                            else if (self.parent.options.snapping instanceof TC.Layer) {\r\n                                snapOptions.source = self.parent.options.snapping.wrap.layer.getSource();\r\n                            }\r\n                            self.snapInteraction = new ol.interaction.Snap(snapOptions);\r\n                            olMap.addInteraction(self.snapInteraction);\r\n                        }\r\n                    }\r\n\r\n                    self.redoStack = [];\r\n                });\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\nTC.wrap.control.Draw.prototype.deactivate = function () {\r\n    var self = this;\r\n    if (self.parent.map) {\r\n        Promise.all([self.parent.map.wrap.getMap(), self.parent.getLayer()]).then(function (objects) {\r\n            const olMap = objects[0];\r\n            const layer = objects[1];\r\n            if (self.viewport) {\r\n                if (self._pointerdownHandler) {\r\n                    self.viewport.removeEventListener('pointerdown', self._pointerdownHandler);\r\n                    self._pointerdownHandler = null;\r\n                }\r\n                if (self._clickHandler) {\r\n                    self.viewport.removeEventListener(TC.Consts.event.CLICK, self._clickHandler);\r\n                    self._clickHandler = null;\r\n                }\r\n            }\r\n            if (layer && !self.parent.persistent) {\r\n                layer.clearFeatures();\r\n            }\r\n            if (self.interaction) {\r\n                olMap.removeInteraction(self.interaction);\r\n                self.interaction = null;\r\n            }\r\n            if (self._projectionChangeHandler) {\r\n                olMap.un('change:view', self._projectionChangeHandler);\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\n//El valor devuelto es lo que va al stack de redo\r\nTC.wrap.control.Draw.prototype.popCoordinate = function () {\r\n    var self = this;\r\n    var result = null;\r\n    if (self.interaction) {\r\n        var feature = self.interaction.sketchFeature_;\r\n        if (feature) {\r\n            var coords;\r\n            var geom = feature.getGeometry();\r\n\r\n            if (geom instanceof ol.geom.Polygon) {\r\n                coords = geom.getCoordinates()[0];\r\n            }\r\n            else if (geom instanceof ol.geom.LineString) {\r\n                coords = geom.getCoordinates();\r\n            }\r\n            if (coords.length > 1) {\r\n\r\n                var puntos;\r\n                if (geom instanceof ol.geom.Polygon)\r\n                    puntos = self.interaction.sketchCoords_[0];\r\n                else if (geom instanceof ol.geom.LineString)\r\n                    puntos = self.interaction.sketchCoords_;\r\n\r\n                /*\r\n                Al menos con linestring, no necesariamente hay que quitar el último\r\n                Porque OL mete en coordinates del sketchFeature_ tanto el último marcado como el que flota detrás del cursor\r\n                Para comprobar que realmente es ése, podemos contrastarlo con self.interaction.sketchPoint_.getGeometry().getCoordinates()\r\n                */\r\n                var flyingPointContained = false;\r\n                if (self.interaction.sketchPoint_) {\r\n                    var flyingPoint = self.interaction.sketchPoint_.getGeometry().getCoordinates();\r\n                    for (var i = 0; i < coords.length; i++) {\r\n                        if (coords[i][0] == flyingPoint[0] && coords[i][1] == flyingPoint[1]) {\r\n                            flyingPointContained = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                var index;\r\n                if (flyingPointContained) index = puntos.length - 2;\r\n                else index = puntos.length - 1;\r\n\r\n                result = puntos[index];\r\n                puntos.splice(index, 1);\r\n\r\n                if (geom instanceof ol.geom.Polygon) {\r\n                    geom.setCoordinates([puntos]);\r\n                    self.interaction.sketchLine_.getGeometry().setCoordinates(puntos);\r\n                }\r\n                else {\r\n                    geom.setCoordinates(puntos);\r\n                }\r\n\r\n\r\n                feature.setGeometry(geom);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.control.Draw.prototype.pushCoordinate = function (coord) {\r\n    var self = this;\r\n    var result = false;\r\n    if (self.interaction) {\r\n        var feature = self.interaction.sketchFeature_;\r\n        if (feature) {\r\n            var coords;\r\n            var geom = feature.getGeometry();\r\n\r\n            if (geom instanceof ol.geom.Polygon) {\r\n                coords = geom.getCoordinates()[0];\r\n            } else if (geom instanceof ol.geom.LineString) {\r\n                coords = geom.getCoordinates();\r\n            }\r\n            //coords.push(coord);\r\n\r\n            var puntos;\r\n            if (geom instanceof ol.geom.Polygon) {\r\n                puntos = self.interaction.sketchCoords_[0];\r\n                //self.interaction.sketchCoords_[0].push(coord);\r\n                //geom.setCoordinates([fullCoords], ol.geom.GeometryLayout.XY);\r\n            } else if (geom instanceof ol.geom.LineString) {\r\n\r\n                puntos = self.interaction.sketchCoords_;\r\n            }\r\n\r\n            //Si hay punto volador, hay que meter la coordenada justo antes\r\n            var flyingPointContained = false;\r\n            if (self.interaction.sketchPoint_) {\r\n                var flyingPoint = self.interaction.sketchPoint_.getGeometry().getCoordinates();\r\n                for (var i = 0; i < coords.length; i++) {\r\n                    if (coords[i][0] == flyingPoint[0] && coords[i][1] == flyingPoint[1]) {\r\n                        flyingPointContained = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            let index;\r\n            if (flyingPointContained) {\r\n                index = puntos.length - 1;\r\n            }\r\n            else {\r\n                index = puntos.length;\r\n            }\r\n            puntos.splice(index, 0, coord);\r\n\r\n            if (geom instanceof ol.geom.LineString)\r\n                geom.setCoordinates(puntos, ol.geom.GeometryLayout.XY);\r\n            else {\r\n                geom.setCoordinates([puntos], ol.geom.GeometryLayout.XY);\r\n                self.interaction.sketchLine_.getGeometry().setCoordinates(puntos);\r\n                //feature.setGeometry(geom);\r\n            }\r\n\r\n\r\n            result = true;\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.control.Draw.prototype.undo = function () {\r\n    var self = this;\r\n    var result = false;\r\n\r\n    var coord = self.popCoordinate();\r\n    if (coord) {\r\n        self.redoStack.push(coord);\r\n        result = true;\r\n    }\r\n\r\n    self.parent.trigger(TC.Consts.event.MEASUREPARTIAL, self.getMeasureData());\r\n\r\n    return result;\r\n};\r\n\r\nTC.wrap.control.Draw.prototype.redo = function () {\r\n    var self = this;\r\n    var result = false;\r\n\r\n    if (self.redoStack.length > 0) {\r\n        self.pushCoordinate(self.redoStack.pop());\r\n        result = true;\r\n    }\r\n\r\n    self.parent.trigger(TC.Consts.event.MEASUREPARTIAL, self.getMeasureData());\r\n\r\n    return result;\r\n};\r\n\r\nTC.wrap.control.Draw.prototype.end = function () {\r\n    var self = this;\r\n    if (self.interaction && self.interaction.sketchFeature_)\r\n        self.interaction.finishDrawing();\r\n};\r\n\r\nTC.wrap.control.Draw.prototype.setStyle = function () {\r\n    const self = this;\r\n    if (self.interaction) {\r\n        let olStyle;\r\n        const parentStyles = self.parent.styles;\r\n        switch (self.parent.mode) {\r\n            case TC.Consts.geom.RECTANGLE:\r\n                if (parentStyles.line) {\r\n                    olStyle = createNativeStyle({\r\n                        styles: {\r\n                            line: parentStyles.line,\r\n                            point: false,\r\n                            polygon: false\r\n                        }\r\n                    });\r\n                }\r\n                break;\r\n            case TC.Consts.geom.POLYGON:\r\n            case TC.Consts.geom.MULTIPOLYGON:\r\n                if (parentStyles.polygon) {\r\n                    olStyle = createNativeStyle({\r\n                        styles: {\r\n                            polygon: parentStyles.polygon,\r\n                            line: false,\r\n                            point: false\r\n                        }\r\n                    });\r\n                }\r\n                break;\r\n            case TC.Consts.geom.POINT:\r\n            case TC.Consts.geom.MULTIPOINT:\r\n                if (parentStyles.point) {\r\n                    olStyle = createNativeStyle({\r\n                        styles: {\r\n                            point: parentStyles.point,\r\n                            line: false,\r\n                            polygon: false\r\n                        }\r\n                    });\r\n                }\r\n                break;\r\n            case TC.Consts.geom.MULTIPOLYLINE:\r\n            default:\r\n                if (parentStyles.line) {\r\n                    const styleOptions = {\r\n                        styles: {\r\n                            line: parentStyles.line,\r\n                            point: false,\r\n                            polygon: false\r\n                        }\r\n                    };\r\n                    const defaultStyle = createNativeStyle(styleOptions);\r\n                    if (self.parent.options.extensible && parentStyles.point) {\r\n                        const activeStyle = createNativeStyle({\r\n                            styles: {\r\n                                line: parentStyles.line,\r\n                                point: parentStyles.point,\r\n                                polygon: false\r\n                            }\r\n                        });\r\n                        olStyle = function () {\r\n                            if (self.interaction?.sketchPoint_) {\r\n                                const pointCoords = self.interaction.sketchPoint_\r\n                                    .getGeometry()\r\n                                    .getCoordinates();\r\n                                const previousFeatureFound = self.parent.layer.features\r\n                                    .some(f => isLastPoint(pointCoords, f.getCoordinates()));\r\n                                if (previousFeatureFound) {\r\n                                    return activeStyle;\r\n                                }\r\n                            }\r\n                            return defaultStyle;\r\n                        }\r\n                    }\r\n                    else {\r\n                        olStyle = defaultStyle;\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n        self.interaction.overlay_.setStyle(olStyle);\r\n    }\r\n};\r\n\r\nTC.wrap.control.Draw.prototype.setVisibility = function (visibility) {\r\n    const self = this;\r\n    if (self.interaction) {\r\n        self.interaction.getOverlay().setVisible(visibility)\r\n    }\r\n}\r\n\r\nTC.wrap.control.OfflineMapMaker.prototype.getRequestSchemas = function (options) {\r\n    var extent = options.extent;\r\n    var layers = options.layers;\r\n    var result = new Array(layers.length);\r\n    for (var i = 0, len = result.length; i < len; i++) {\r\n        var layer = layers[i];\r\n        var schema = {\r\n            layerId: layer.id,\r\n            tileMatrixSet: layer.matrixSet\r\n        };\r\n        var olSource = layer.wrap.layer.getSource();\r\n        if (olSource.getUrls) {\r\n            schema.url = olSource.getUrls()[0];\r\n        }\r\n        if (olSource.getTileGrid) {\r\n            var tileGrid = olSource.getTileGrid();\r\n            var resolutions = tileGrid.getResolutions();\r\n            var matrixIds = tileGrid.getMatrixIds();\r\n            var node = layer.getLayerNodeByName(layer.layerNames);\r\n            var tmsLimits = null;\r\n            for (var j = 0, llen = node.TileMatrixSetLink.length; j < llen; j++) {\r\n                var tmsl = node.TileMatrixSetLink[j];\r\n                if (tmsl.TileMatrixSet === layer.matrixSet) {\r\n                    tmsLimits = tmsl.TileMatrixSetLimits;\r\n                    break;\r\n                }\r\n            }\r\n            schema.tileMatrixLimits = [];\r\n            resolutions.forEach(function (resolution, idx) {\r\n                var origin = tileGrid.getOrigin(idx);\r\n                var tileSize = tileGrid.getTileSize(idx);\r\n                var unitsPerTile = tileSize * resolution;\r\n                var tml = {\r\n                    mId: matrixIds[idx],\r\n                    res: resolution,\r\n                    origin: origin,\r\n                    tSize: tileSize,\r\n                    cl: Math.floor((extent[0] - origin[0]) / unitsPerTile),\r\n                    cr: Math.floor((extent[2] - origin[0]) / unitsPerTile),\r\n                    rt: Math.floor((origin[1] - extent[3]) / unitsPerTile),\r\n                    rb: Math.floor((origin[1] - extent[1]) / unitsPerTile)\r\n                };\r\n                if (tmsLimits) {\r\n                    var tmsLimit = tmsLimits[idx];\r\n                    if (tmsLimit) {\r\n                        tml.cl = Math.max(tml.cl, tmsLimit.MinTileCol);\r\n                        tml.cr = Math.min(tml.cr, tmsLimit.MaxTileCol);\r\n                        tml.rt = Math.max(tml.rt, tmsLimit.MinTileRow);\r\n                        tml.rb = Math.min(tml.rb, tmsLimit.MaxTileRow);\r\n                    }\r\n                }\r\n                if (tml.cl <= tml.cr && tml.rt <= tml.rb) {\r\n                    schema.tileMatrixLimits.push(tml);\r\n                }\r\n            });\r\n        }\r\n        result[i] = schema;\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.control.OfflineMapMaker.prototype.getGetTilePattern = function (layer) {\r\n    var result = \"\";\r\n    var olSource = layer.wrap.layer.getSource();\r\n    if (olSource.getUrls) {\r\n        result = olSource.getUrls()[0];\r\n    }\r\n    if (layer.options.encoding !== TC.Consts.WMTSEncoding.RESTFUL) {\r\n        if (result.indexOf('?') < 0) {\r\n            result = result + '?';\r\n        }\r\n        if (result.indexOf('?') === result.length - 1) {\r\n            result = result + 'layer=' + layer.layerNames + '&style=default&tilematrixset=' + encodeURIComponent(layer.matrixSet) +\r\n                '&Service=WMTS&Request=GetTile&Version=1.0.0&Format=' + encodeURIComponent(layer.format) +\r\n                '&TileMatrix={TileMatrix}&TileCol={TileCol}&TileRow={TileRow}';\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nconst createHaloStroke1 = function (width) {\r\n    return new ol.style.Stroke({\r\n        color: '#ffffff',\r\n        width: width + 4\r\n    });\r\n};\r\n\r\nconst createHaloStroke2 = function (width) {\r\n    return new ol.style.Stroke({\r\n        color: '#000000',\r\n        width: width + 6\r\n    });\r\n};\r\n\r\nconst addHaloToStyle = function (style) {\r\n    if (!style) {\r\n        style = [];\r\n    }\r\n    if (style instanceof ol.style.Style) {\r\n        style = [style];\r\n    }\r\n    style = style.slice();\r\n    const mainStyle = style[0];\r\n    if (mainStyle) {\r\n        const image = mainStyle.getImage();\r\n        var strokeWidth;\r\n        if (image instanceof ol.style.RegularShape) {\r\n            strokeWidth = image.getStroke().getWidth();\r\n            const radius = image.getRadius();\r\n            const haloPart1 = mainStyle.clone();\r\n            haloPart1.setImage(new ol.style.Circle({\r\n                radius: radius,\r\n                stroke: createHaloStroke1(strokeWidth)\r\n            }));\r\n            style.unshift(haloPart1);\r\n            const haloPart2 = mainStyle.clone();\r\n            haloPart2.setImage(new ol.style.Circle({\r\n                radius: radius,\r\n                stroke: createHaloStroke2(strokeWidth)\r\n            }));\r\n            style.unshift(haloPart2);\r\n        }\r\n        const stroke = mainStyle.getStroke();\r\n        if (stroke) {\r\n            strokeWidth = stroke.getWidth();\r\n            style.unshift(new ol.style.Style({\r\n                stroke: createHaloStroke1(strokeWidth)\r\n            }));\r\n            style.unshift(new ol.style.Style({\r\n                stroke: createHaloStroke2(strokeWidth)\r\n            }));\r\n        }\r\n        return style;\r\n    }\r\n    return null;\r\n};\r\n\r\nconst createSelectedStyle = function (feat) {\r\n    let originalStyle = feat._originalStyle = feat._originalStyle || feat.getStyle();\r\n    if (!feat._originalStyle && feat._wrap.parent.layer) {\r\n        originalStyle = feat._wrap.parent.layer.wrap.layer.getStyle();\r\n    }\r\n    if (!originalStyle) {\r\n        originalStyle = createNativeStyle({}, feat);\r\n    }\r\n    if (TC.Util.isFunction(originalStyle)) {\r\n        return function (f, r) {\r\n            return addHaloToStyle(originalStyle(f, r));\r\n        };\r\n    }\r\n    return addHaloToStyle(originalStyle);\r\n};\r\n\r\nconst setSelectedStyle = function (feat) {\r\n    updateSelectedStyle.call(feat);\r\n    feat.changed();\r\n    //feat._changeListenerKey = ol.events.listen(feat, CHANGE, updateSelectedStyle, feat);\r\n};\r\n\r\nconst removeSelectedStyle = function (feat) {\r\n    //ol.events.unlistenByKey(feat._changeListenerKey);\r\n    if (Object.prototype.hasOwnProperty.call(feat, '_originalStyle')) {\r\n        feat.setStyle(feat._originalStyle);\r\n    }\r\n    delete feat._originalStyle;\r\n};\r\n\r\nconst updateSelectedStyle = function () {\r\n    this.style_ = createSelectedStyle(this);\r\n    this.styleFunction_ = !this.style_ ? undefined : ol.Feature.createStyleFunction(this.style_);\r\n};\r\n\r\nTC.wrap.control.Modify.prototype.activate = function () {\r\n    const self = this;\r\n    if (self.parent.map) {\r\n        Promise.all([self.parent.map.wrap.getMap(), self.parent.layer.wrap.getLayer()]).then(function (olObjects) {\r\n            const olMap = olObjects[0];\r\n            const olLayer = olObjects[1];\r\n            if (self.selectInteraction) {\r\n                olMap.removeInteraction(self.selectInteraction);\r\n            }\r\n            var select = new ol.interaction.Select({\r\n                layers: [olLayer],\r\n                hitTolerance: hitTolerance,\r\n                style: null\r\n            });\r\n            self.selectInteraction = select;\r\n            olMap.addInteraction(select);\r\n            var getWrapperFeature = function (elm) {\r\n                return elm._wrap.parent;\r\n            };\r\n            select.on('select', function (event) {\r\n                if (event.selected.length > 0) {\r\n                    self.parent.trigger(TC.Consts.event.FEATURESSELECT, { ctrl: self, features: event.selected.map(getWrapperFeature) });\r\n                }\r\n                if (event.deselected.length > 0) {\r\n                    if (event.selected.length === 0) {\r\n                        self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { ctrl: self.parent, features: event.deselected.map(getWrapperFeature) });\r\n                    }\r\n                }\r\n            });\r\n            if (self.modifyInteraction) {\r\n                olMap.removeInteraction(self.modifyInteraction);\r\n            }\r\n            var modify = new ol.interaction.Modify({\r\n                features: select.getFeatures()\r\n            });\r\n            modify.on('modifyend', function (e) {\r\n                e.features.forEach(function (feature) {\r\n                    feature._wrap.parent.geometry = feature._wrap.getGeometry();\r\n                    self.parent.trigger(TC.Consts.event.FEATUREMODIFY, { feature: feature._wrap.parent, layer: self.parent.layer });\r\n                });\r\n            });\r\n            self.modifyInteraction = modify;\r\n            olMap.addInteraction(modify);\r\n\r\n            if (self.snapInteraction) {\r\n                olMap.removeInteraction(self.snapInteraction);\r\n            }\r\n            if (self.parent.snapping) {\r\n                self.snapInteraction = new ol.interaction.Snap({\r\n                    source: olLayer.getSource()\r\n                });\r\n                olMap.addInteraction(self.snapInteraction);\r\n            }\r\n\r\n            if (!self._onMouseMove) {\r\n                self._onMouseMove = function (e) {\r\n                    const viewport = olMap.getViewport();\r\n                    var hit = false;\r\n\r\n                    var pixel = olMap.getEventPixel(e);\r\n                    hit = olMap.forEachFeatureAtPixel(pixel, function (feature, layer) {\r\n                        if (self.parent.layer && layer === self.parent.layer.wrap.layer) {\r\n                            return true;\r\n                        }\r\n                        return false;\r\n                    },\r\n                        {\r\n                            hitTolerance: hitTolerance\r\n                        });\r\n\r\n                    if (hit) {\r\n                        viewport.style.cursor = 'pointer';\r\n                    } else {\r\n                        viewport.style.cursor = '';\r\n                        //self.parent.trigger(TC.Consts.event.FEATUREOUT);\r\n                    }\r\n                };\r\n            }\r\n\r\n            olMap.getViewport().addEventListener(MOUSEMOVE, self._onMouseMove);\r\n        });\r\n    }\r\n};\r\n\r\nTC.wrap.control.Modify.prototype.deactivate = function () {\r\n    const self = this;\r\n    if (self.modifyInteraction) {\r\n        self.modifyInteraction.setActive(false);\r\n        self.selectInteraction.setActive(false);\r\n        self.parent.map.wrap.getMap().then(function (olMap) {\r\n            olMap.getViewport().removeEventListener(MOUSEMOVE, self._onMouseMove);\r\n            olMap.removeInteraction(self.modifyInteraction);\r\n            olMap.removeInteraction(self.selectInteraction);\r\n            self.modifyInteraction = null;\r\n            self.selectInteraction = null;\r\n        });\r\n    }\r\n};\r\n\r\nTC.wrap.control.Modify.prototype.getSelectedFeatures = function () {\r\n    var self = this;\r\n    var result = [];\r\n    if (self.selectInteraction) {\r\n        self.selectInteraction.getFeatures().forEach(function (elm) {\r\n            result.push(elm._wrap.parent);\r\n        });\r\n    }\r\n    return result;\r\n};\r\n\r\nTC.wrap.control.Modify.prototype.setSelectedFeatures = function (features) {\r\n    var self = this;\r\n    if (self.selectInteraction) {\r\n        self.selectInteraction.features_.clear();\r\n        self.selectInteraction.features_.extend(features.map(f => f.wrap.feature));\r\n    }\r\n};\r\n\r\nTC.wrap.control.Modify.prototype.unselectFeatures = function (features) {\r\n    features = features || [];\r\n    const self = this;\r\n    const selectedFeatures = self.selectInteraction ? self.selectInteraction.getFeatures() : null;\r\n    if (selectedFeatures) {\r\n        const unselectedFeatures = [];\r\n        selectedFeatures.getArray().slice().forEach(function (olFeature) {\r\n            if (!features.length || features.indexOf(olFeature) >= 0) {\r\n                selectedFeatures.remove(olFeature);\r\n                unselectedFeatures.push(olFeature._wrap.parent);\r\n            }\r\n        });\r\n        if (unselectedFeatures.length) {\r\n            self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { features: unselectedFeatures });\r\n        }\r\n    }\r\n};\r\n\r\nTC.wrap.control.Edit.prototype.cancel = function (_deactivate, _cancelTxt) {\r\n    var self = this;\r\n    self.points = [];\r\n    self.histPoints = [];\r\n    //var layer = self.control && self.control.layer || self.modifyInteraction && self.modifyInteraction.layer;\r\n    //if (!self.session || ((self.modifyInteraction && self.modifyInteraction.modified) || (self.session.featuresAdded && self.session.featuresAdded.length)) && cancelTxt && !confirm(cancelTxt))\r\n    //    return;\r\n    if (self.selectInteraction) {\r\n        var features = self.selectInteraction.getFeatures();\r\n        self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { ctrl: self.parent, feature: features.get(0) });\r\n        features.clear();\r\n        self.selectInteraction.setActive(false);\r\n    }\r\n    //if (self.drawInteraction) {\r\n    //    self.drawInteraction.abortDrawing_();\r\n    //    if (deactivate) {\r\n    //        self.drawInteraction.setActive(false);\r\n    //    }\r\n    //}\r\n    //if(self.modifyInteraction)\r\n    //{\r\n    //    if (self.modifyInteraction.feature)\r\n    //        self.modifyInteraction.unselectFeature(self.modifyInteraction.feature);\r\n    //    if (deactivate)\r\n    //    {\r\n    //        self.modifyInteraction.deactivate();\r\n    //    }   \r\n    //}\r\n    ////if (self.session.featuresAdded && self.session.featuresAdded.length > 0) {\r\n    ////    layer.removeFeatures(self.session.featuresAdded);\r\n    ////    self.session.featuresAdded = [];\r\n    ////}\r\n    //self.parent.trigger(TC.Consts.event.EDITIONCANCEL, { ctrl: self });\r\n    ////no se por que hostias se cambia el renderIntent a las features\r\n    //layer.features.forEach(function (feat) {\r\n    //    feat.renderIntent = \"\";\r\n    //});    \r\n    //layer.removeAllFeatures();\r\n    //layer.addFeatures(self.session.features);        \r\n    //self.clearSession();\r\n};\r\n\r\nTC.wrap.control.Edit.prototype.deleteFeatures = function (features) {\r\n    var self = this;\r\n    if (Array.isArray(features)) {\r\n        var olFeatures = features.map(function (elm) {\r\n            return elm.wrap.feature;\r\n        });\r\n        self.parent.layer.wrap.getLayer().then(function (olLayer) {\r\n            var selectedFeatures = self.selectInteraction ? self.selectInteraction.getFeatures() : null;\r\n            for (var i = 0, len = olFeatures.length; i < len; i++) {\r\n                var olFeature = olFeatures[i];\r\n                if (selectedFeatures) {\r\n                    selectedFeatures.remove(olFeature);\r\n                    self.parent.trigger(TC.Consts.event.FEATURESUNSELECT, { feature: olFeature._wrap.parent });\r\n                }\r\n                olLayer.getSource().removeFeature(olFeature);\r\n                self.parent.trigger(TC.Consts.event.FEATUREREMOVE, { feature: olFeature._wrap.parent });\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\n//TC.wrap.control.Edit.prototype.clearSession = function () {\r\n//    var self = this;\r\n//    delete self.session;\r\n//};\r\n\r\nTC.wrap.Feature.prototype.toGML = function (_version, srsName) {\r\n    var parser = new ol.format.GML({\r\n        srsName: srsName\r\n    });\r\n    var xml = parser.writeGeometryNode(this.feature.getGeometry());\r\n    //elimino los aributos srsName de los hijos en geometrias compuestas Polygon->LinearRing etc;\r\n    var polygons = xml.querySelector(\"MultiSurface,MultiPolygon,Polygon\");\r\n    if (polygons) {\r\n        polygons.querySelectorAll(\"Polygon,LinearRing\").forEach(item => item.removeAttribute(\"srsName\"));\r\n    }\r\n    //id para INSPIRE\r\n    xml.firstChild.setAttribute(\"gml:id\", xml.firstChild.tagName + \".\" + TC.getUID());\r\n    //reemplazo todos los <loquesea por <gml:loquesea y </loquesea por </gml:loquesea\r\n    return new XMLSerializer()\r\n        .serializeToString(xml.firstChild)\r\n        .replace(/\\<\\/?\\w/gm, function (str) {\r\n            var pos = str.indexOf(\"/\") > 0 ? str.indexOf(\"/\") + 1 : 1;\r\n            return str.substring(0, pos) + \"gml:\" + str.substring(pos);\r\n        });\r\n    //return new XMLSerializer().serializeToString(xml.firstChild).replace(/\\</gm, \"<gml:\");\r\n};\r\n\r\n\r\nTC.wrap.Feature.prototype.toGeoJSON = function () {\r\n    var parser = new ol.format.GeoJSON();\r\n    return parser.writeGeometry(this.feature.getGeometry());\r\n};\r\n\r\nTC.wrap.Geometry.write = function (options) {\r\n    options = options || {};\r\n    var geometry;\r\n    switch (options.format) {\r\n        default:\r\n            options.parser = new ol.format.GeoJSON();\r\n    }\r\n    switch (options.type) {\r\n        case TC.Consts.geom.POLYLINE:\r\n            geometry = new ol.geom.LineString(options.coordinates);\r\n            break;\r\n        case TC.Consts.geom.POLYGON:\r\n            geometry = new ol.geom.Polygon(options.coordinates);\r\n            break;\r\n        case TC.Consts.geom.MULTIPOINT:\r\n            geometry = new ol.geom.MultiPoint(options.coordinates);\r\n            break;\r\n        case TC.Consts.geom.MULTIPOLYLINE:\r\n            geometry = new ol.geom.MultiLineString(options.coordinates);\r\n            break;\r\n        case TC.Consts.geom.MULTIPOLYGON:\r\n            geometry = new ol.geom.MultiPolygon(options.coordinates);\r\n            break;\r\n        case TC.Consts.geom.POINT:\r\n        default:\r\n            geometry = new ol.geom.Point(options.coordinates);\r\n            break;\r\n    }\r\n    return options.parser.writeGeometry(geometry);\r\n};\r\n\r\nTC.wrap.Geometry.toGeoJSON = function (options) {\r\n    return TC.wrap.Geometry.write(options);\r\n};\r\n\r\nexport default wrap;","__webpack_require__.h = () => (\"29049f88fc13eccdbe64\")"],"names":[],"sourceRoot":""}